webpackHotUpdate("vendor",{

/***/ "./node_modules/connected-react-router/immutable.js":
/*!**********************************************************!*\
  !*** ./node_modules/connected-react-router/immutable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/immutable */ "./node_modules/connected-react-router/lib/immutable.js");

/***/ }),

/***/ "./node_modules/connected-react-router/lib/immutable.js":
/*!**************************************************************!*\
  !*** ./node_modules/connected-react-router/lib/immutable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = exports.createMatchSelector = exports.getAction = exports.getLocation = exports.routerMiddleware = exports.connectRouter = exports.ConnectedRouter = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.LOCATION_CHANGE = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _createAll = __webpack_require__(/*! ./createAll */ "./node_modules/connected-react-router/lib/createAll.js");

var _createAll2 = _interopRequireDefault(_createAll);

var _immutable = __webpack_require__(/*! ./structure/immutable */ "./node_modules/connected-react-router/lib/structure/immutable/index.js");

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var _get__2 = _get__('createAll')(_get__('immutableStructure'));

var LOCATION_CHANGE = _get__2.LOCATION_CHANGE,
    CALL_HISTORY_METHOD = _get__2.CALL_HISTORY_METHOD,
    push = _get__2.push,
    replace = _get__2.replace,
    go = _get__2.go,
    goBack = _get__2.goBack,
    goForward = _get__2.goForward,
    routerActions = _get__2.routerActions,
    ConnectedRouter = _get__2.ConnectedRouter,
    connectRouter = _get__2.connectRouter,
    routerMiddleware = _get__2.routerMiddleware,
    getLocation = _get__2.getLocation,
    getAction = _get__2.getAction,
    createMatchSelector = _get__2.createMatchSelector;
exports.LOCATION_CHANGE = LOCATION_CHANGE;
exports.CALL_HISTORY_METHOD = CALL_HISTORY_METHOD;
exports.push = push;
exports.replace = replace;
exports.go = go;
exports.goBack = goBack;
exports.goForward = goForward;
exports.routerActions = routerActions;
exports.ConnectedRouter = ConnectedRouter;
exports.connectRouter = connectRouter;
exports.routerMiddleware = routerMiddleware;
exports.getLocation = getLocation;
exports.getAction = getAction;
exports.createMatchSelector = createMatchSelector;

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'createAll':
      return _createAll2.default;

    case 'immutableStructure':
      return _immutable2.default;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;
exports.default = _RewireAPI__;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_typeof, "_typeof", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_createAll2, "_createAll2", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_immutable2, "_immutable2", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_get__2, "_get__2", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(LOCATION_CHANGE, "LOCATION_CHANGE", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(CALL_HISTORY_METHOD, "CALL_HISTORY_METHOD", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(push, "push", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(replace, "replace", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(go, "go", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(goBack, "goBack", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(goForward, "goForward", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(routerActions, "routerActions", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(ConnectedRouter, "ConnectedRouter", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(connectRouter, "connectRouter", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(routerMiddleware, "routerMiddleware", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(getLocation, "getLocation", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(getAction, "getAction", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(createMatchSelector, "createMatchSelector", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_getGlobalObject, "_getGlobalObject", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_RewireModuleId__, "_RewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_getRewireModuleId__, "_getRewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_getRewireRegistry__, "_getRewireRegistry__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_getRewiredData__, "_getRewiredData__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(INTENTIONAL_UNDEFINED, "INTENTIONAL_UNDEFINED", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_RewireAPI__, "_RewireAPI__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_get__, "_get__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_get_original__, "_get_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_assign__, "_assign__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_set_original__, "_set_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_update_operation__, "_update_operation__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_set__, "_set__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_reset__, "_reset__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  reactHotLoader.register(_with__, "_with__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/immutable.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/connected-react-router/lib/structure/immutable/getIn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/connected-react-router/lib/structure/immutable/getIn.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
/* Code from github.com/erikras/redux-form by Erik Rasmussen */


var _immutable = __webpack_require__(/*! immutable */ "./node_modules/connected-react-router/node_modules/immutable/dist/immutable.js");

var _getIn = __webpack_require__(/*! ../plain/getIn */ "./node_modules/connected-react-router/lib/structure/plain/getIn.js");

var _getIn2 = _interopRequireDefault(_getIn);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var getIn = function getIn(state, path) {
  return _get__('Iterable').isIterable(state) ? state.getIn(path) : _get__('plainGetIn')(state, path);
};

exports.default = _get__('getIn');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'Iterable':
      return _immutable.Iterable;

    case 'plainGetIn':
      return _getIn2.default;

    case 'getIn':
      return getIn;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof getIn === 'undefined' ? 'undefined' : _typeof(getIn);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(getIn, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(getIn)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_typeof, "_typeof", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_getIn2, "_getIn2", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(getIn, "getIn", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_getGlobalObject, "_getGlobalObject", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_RewireModuleId__, "_RewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_getRewireModuleId__, "_getRewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_getRewireRegistry__, "_getRewireRegistry__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_getRewiredData__, "_getRewiredData__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(INTENTIONAL_UNDEFINED, "INTENTIONAL_UNDEFINED", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_RewireAPI__, "_RewireAPI__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_get__, "_get__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_get_original__, "_get_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_assign__, "_assign__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_set_original__, "_set_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_update_operation__, "_update_operation__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_set__, "_set__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_reset__, "_reset__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_with__, "_with__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(_typeOfOriginalExport, "_typeOfOriginalExport", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  reactHotLoader.register(addNonEnumerableProperty, "addNonEnumerableProperty", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/getIn.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/connected-react-router/lib/structure/immutable/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/connected-react-router/lib/structure/immutable/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _immutable = __webpack_require__(/*! immutable */ "./node_modules/connected-react-router/node_modules/immutable/dist/immutable.js");

var _getIn = __webpack_require__(/*! ./getIn */ "./node_modules/connected-react-router/lib/structure/immutable/getIn.js");

var _getIn2 = _interopRequireDefault(_getIn);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var structure = {
  fromJS: function fromJS(jsValue) {
    return _get__('fromJS')(jsValue, function (key, value) {
      return _get__('Iterable').isIndexed(value) ? value.toList() : value.toMap();
    });
  },
  getIn: _get__('getIn'),
  merge: function merge(state, payload) {
    return state.merge(payload);
  },
  toJS: function toJS(value) {
    return _get__('Iterable').isIterable(value) ? value.toJS() : value;
  }
};
exports.default = _get__('structure');

function _getGlobalObject() {
  try {
    if (!!global) {
      return global;
    }
  } catch (e) {
    try {
      if (!!window) {
        return window;
      }
    } catch (e) {
      return this;
    }
  }
}

;
var _RewireModuleId__ = null;

function _getRewireModuleId__() {
  if (_RewireModuleId__ === null) {
    var globalVariable = _getGlobalObject();

    if (!globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__) {
      globalVariable.__$$GLOBAL_REWIRE_NEXT_MODULE_ID__ = 0;
    }

    _RewireModuleId__ = __$$GLOBAL_REWIRE_NEXT_MODULE_ID__++;
  }

  return _RewireModuleId__;
}

function _getRewireRegistry__() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__) {
    theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
  }

  return __$$GLOBAL_REWIRE_REGISTRY__;
}

function _getRewiredData__() {
  var moduleId = _getRewireModuleId__();

  var registry = _getRewireRegistry__();

  var rewireData = registry[moduleId];

  if (!rewireData) {
    registry[moduleId] = Object.create(null);
    rewireData = registry[moduleId];
  }

  return rewireData;
}

(function registerResetAll() {
  var theGlobalVariable = _getGlobalObject();

  if (!theGlobalVariable['__rewire_reset_all__']) {
    theGlobalVariable['__rewire_reset_all__'] = function () {
      theGlobalVariable.__$$GLOBAL_REWIRE_REGISTRY__ = Object.create(null);
    };
  }
})();

var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
var _RewireAPI__ = {};

(function () {
  function addPropertyToAPIObject(name, value) {
    Object.defineProperty(_RewireAPI__, name, {
      value: value,
      enumerable: false,
      configurable: true
    });
  }

  addPropertyToAPIObject('__get__', _get__);
  addPropertyToAPIObject('__GetDependency__', _get__);
  addPropertyToAPIObject('__Rewire__', _set__);
  addPropertyToAPIObject('__set__', _set__);
  addPropertyToAPIObject('__reset__', _reset__);
  addPropertyToAPIObject('__ResetDependency__', _reset__);
  addPropertyToAPIObject('__with__', _with__);
})();

function _get__(variableName) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _get_original__(variableName);
  } else {
    var value = rewireData[variableName];

    if (value === INTENTIONAL_UNDEFINED) {
      return undefined;
    } else {
      return value;
    }
  }
}

function _get_original__(variableName) {
  switch (variableName) {
    case 'fromJS':
      return _immutable.fromJS;

    case 'Iterable':
      return _immutable.Iterable;

    case 'getIn':
      return _getIn2.default;

    case 'structure':
      return structure;
  }

  return undefined;
}

function _assign__(variableName, value) {
  var rewireData = _getRewiredData__();

  if (rewireData[variableName] === undefined) {
    return _set_original__(variableName, value);
  } else {
    return rewireData[variableName] = value;
  }
}

function _set_original__(variableName, _value) {
  switch (variableName) {}

  return undefined;
}

function _update_operation__(operation, variableName, prefix) {
  var oldValue = _get__(variableName);

  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;

  _assign__(variableName, newValue);

  return prefix ? newValue : oldValue;
}

function _set__(variableName, value) {
  var rewireData = _getRewiredData__();

  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
    Object.keys(variableName).forEach(function (name) {
      rewireData[name] = variableName[name];
    });
  } else {
    if (value === undefined) {
      rewireData[variableName] = INTENTIONAL_UNDEFINED;
    } else {
      rewireData[variableName] = value;
    }

    return function () {
      _reset__(variableName);
    };
  }
}

function _reset__(variableName) {
  var rewireData = _getRewiredData__();

  delete rewireData[variableName];

  if (Object.keys(rewireData).length == 0) {
    delete _getRewireRegistry__()[_getRewireModuleId__];
  }

  ;
}

function _with__(object) {
  var rewireData = _getRewiredData__();

  var rewiredVariableNames = Object.keys(object);
  var previousValues = {};

  function reset() {
    rewiredVariableNames.forEach(function (variableName) {
      rewireData[variableName] = previousValues[variableName];
    });
  }

  return function (callback) {
    rewiredVariableNames.forEach(function (variableName) {
      previousValues[variableName] = rewireData[variableName];
      rewireData[variableName] = object[variableName];
    });
    var result = callback();

    if (!!result && typeof result.then == 'function') {
      result.then(reset).catch(reset);
    } else {
      reset();
    }

    return result;
  };
}

var _typeOfOriginalExport = typeof structure === 'undefined' ? 'undefined' : _typeof(structure);

function addNonEnumerableProperty(name, value) {
  Object.defineProperty(structure, name, {
    value: value,
    enumerable: false,
    configurable: true
  });
}

if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(structure)) {
  addNonEnumerableProperty('__get__', _get__);
  addNonEnumerableProperty('__GetDependency__', _get__);
  addNonEnumerableProperty('__Rewire__', _set__);
  addNonEnumerableProperty('__set__', _set__);
  addNonEnumerableProperty('__reset__', _reset__);
  addNonEnumerableProperty('__ResetDependency__', _reset__);
  addNonEnumerableProperty('__with__', _with__);
  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
}

exports.__get__ = _get__;
exports.__GetDependency__ = _get__;
exports.__Rewire__ = _set__;
exports.__set__ = _set__;
exports.__ResetDependency__ = _reset__;
exports.__RewireAPI__ = _RewireAPI__;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_typeof, "_typeof", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_getIn2, "_getIn2", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(structure, "structure", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_getGlobalObject, "_getGlobalObject", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_RewireModuleId__, "_RewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_getRewireModuleId__, "_getRewireModuleId__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_getRewireRegistry__, "_getRewireRegistry__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_getRewiredData__, "_getRewiredData__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(INTENTIONAL_UNDEFINED, "INTENTIONAL_UNDEFINED", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_RewireAPI__, "_RewireAPI__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_get__, "_get__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_get_original__, "_get_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_assign__, "_assign__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_set_original__, "_set_original__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_update_operation__, "_update_operation__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_set__, "_set__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_reset__, "_reset__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_with__, "_with__", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(_typeOfOriginalExport, "_typeOfOriginalExport", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  reactHotLoader.register(addNonEnumerableProperty, "addNonEnumerableProperty", "/Users/iain/Projects/react-ssr/node_modules/connected-react-router/lib/structure/immutable/index.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/connected-react-router/node_modules/immutable/dist/immutable.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/connected-react-router/node_modules/immutable/dist/immutable.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) {
   true ? module.exports = factory() : undefined;
})(this, function () {
  'use strict';

  var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }

    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
    return isIterable(value) ? value : Seq(value);
  }

  createClass(KeyedIterable, Iterable);

  function KeyedIterable(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  createClass(IndexedIterable, Iterable);

  function IndexedIterable(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  createClass(SetIterable, Iterable);

  function SetIterable(value) {
    return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;
  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;
  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@'; // Used for setting prototype methods that IE8 chokes on.

  var DELETE = 'delete'; // Constants describing the size of trie nodes.

  var SHIFT = 5; // Resulted in best performance after ______?

  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1; // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.

  var NOT_SET = {}; // Boolean references, Rough equivalent of `bool &`.

  var CHANGE_LENGTH = {
    value: false
  };
  var DID_ALTER = {
    value: false
  };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  } // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.


  function OwnerID() {} // http://jsperf.com/copy-array-inline


  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);

    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }

    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }

    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32

      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }

      index = uint32Index;
    }

    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
  }
  /* global Symbol */


  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;
  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

  function Iterator(next) {
    this.next = next;
  }

  Iterator.prototype.toString = function () {
    return '[Iterator]';
  };

  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
    return this.toString();
  };

  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };

  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? iteratorResult.value = value : iteratorResult = {
      value: value,
      done: false
    };
    return iteratorResult;
  }

  function iteratorDone() {
    return {
      value: undefined,
      done: true
    };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);

    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);

  function Seq(value) {
    return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
  }

  Seq.of = function ()
  /*...values*/
  {
    return Seq(arguments);
  };

  Seq.prototype.toSeq = function () {
    return this;
  };

  Seq.prototype.toString = function () {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function () {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }

    return this;
  }; // abstract __iterateUncached(fn, reverse)


  Seq.prototype.__iterate = function (fn, reverse) {
    return seqIterate(this, fn, reverse, true);
  }; // abstract __iteratorUncached(type, reverse)


  Seq.prototype.__iterator = function (type, reverse) {
    return seqIterator(this, type, reverse, true);
  };

  createClass(KeyedSeq, Seq);

  function KeyedSeq(value) {
    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
  }

  KeyedSeq.prototype.toKeyedSeq = function () {
    return this;
  };

  createClass(IndexedSeq, Seq);

  function IndexedSeq(value) {
    return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
  }

  IndexedSeq.of = function ()
  /*...values*/
  {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function () {
    return this;
  };

  IndexedSeq.prototype.toString = function () {
    return this.__toString('Seq [', ']');
  };

  IndexedSeq.prototype.__iterate = function (fn, reverse) {
    return seqIterate(this, fn, reverse, false);
  };

  IndexedSeq.prototype.__iterator = function (type, reverse) {
    return seqIterator(this, type, reverse, false);
  };

  createClass(SetSeq, Seq);

  function SetSeq(value) {
    return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
  }

  SetSeq.of = function ()
  /*...values*/
  {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function () {
    return this;
  };

  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;
  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
  Seq.prototype[IS_SEQ_SENTINEL] = true;
  createClass(ArraySeq, IndexedSeq);

  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  ArraySeq.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function (fn, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;

    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  ArraySeq.prototype.__iterator = function (type, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;
    var ii = 0;
    return new Iterator(function () {
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
    });
  };

  createClass(ObjectSeq, KeyedSeq);

  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  ObjectSeq.prototype.get = function (key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }

    return this._object[key];
  };

  ObjectSeq.prototype.has = function (key) {
    return this._object.hasOwnProperty(key);
  };

  ObjectSeq.prototype.__iterate = function (fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;

    for (var ii = 0; ii <= maxIndex; ii++) {
      var key = keys[reverse ? maxIndex - ii : ii];

      if (fn(object[key], key, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  ObjectSeq.prototype.__iterator = function (type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;
    var ii = 0;
    return new Iterator(function () {
      var key = keys[reverse ? maxIndex - ii : ii];
      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
    });
  };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
  createClass(IterableSeq, IndexedSeq);

  function IterableSeq(iterable) {
    this._iterable = iterable;
    this.size = iterable.length || iterable.size;
  }

  IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterable = this._iterable;
    var iterator = getIterator(iterable);
    var iterations = 0;

    if (isIterator(iterator)) {
      var step;

      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }

    return iterations;
  };

  IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterable = this._iterable;
    var iterator = getIterator(iterable);

    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }

    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  createClass(IteratorSeq, IndexedSeq);

  function IteratorSeq(iterator) {
    this._iterator = iterator;
    this._iteratorCache = [];
  }

  IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;

    while (iterations < cache.length) {
      if (fn(cache[iterations], iterations++, this) === false) {
        return iterations;
      }
    }

    var step;

    while (!(step = iterator.next()).done) {
      var val = step.value;
      cache[iterations] = val;

      if (fn(val, iterations++, this) === false) {
        break;
      }
    }

    return iterations;
  };

  IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    return new Iterator(function () {
      if (iterations >= cache.length) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        cache[iterations] = step.value;
      }

      return iteratorValue(type, iterations, cache[iterations++]);
    });
  }; // # pragma Helper functions


  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
    }

    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of values: ' + value);
    }

    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) || typeof value === 'object' && new ObjectSeq(value);

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
    }

    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;

    if (cache) {
      var maxIndex = cache.length - 1;

      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];

        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }

      return ii;
    }

    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;

    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function () {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }

    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ? fromJSWith(converter, json, '', {
      '': json
    }) : fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
        return fromJSWith(converter, v, k, json);
      }));
    }

    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
        return fromJSWith(converter, v, k, json);
      }));
    }

    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }

    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }

    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }
  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */


  function is(valueA, valueB) {
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }

    if (!valueA || !valueB) {
      return false;
    }

    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();

      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }

      if (!valueA || !valueB) {
        return false;
      }
    }

    if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
      return true;
    }

    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function (v, k) {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;

    var bSize = b.__iterate(function (v, k) {
      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }

    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);

    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }

      EMPTY_REPEAT = this;
    }
  }

  Repeat.prototype.toString = function () {
    if (this.size === 0) {
      return 'Repeat []';
    }

    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function (searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function (begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
  };

  Repeat.prototype.reverse = function () {
    return this;
  };

  Repeat.prototype.indexOf = function (searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }

    return -1;
  };

  Repeat.prototype.lastIndexOf = function (searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }

    return -1;
  };

  Repeat.prototype.__iterate = function (fn, reverse) {
    for (var ii = 0; ii < this.size; ii++) {
      if (fn(this._value, ii, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  Repeat.prototype.__iterator = function (type, reverse) {
    var this$0 = this;
    var ii = 0;
    return new Iterator(function () {
      return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
    });
  };

  Repeat.prototype.equals = function (other) {
    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
  };

  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }

    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;

    if (end === undefined) {
      end = Infinity;
    }

    step = step === undefined ? 1 : Math.abs(step);

    if (end < start) {
      step = -step;
    }

    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);

    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }

      EMPTY_RANGE = this;
    }
  }

  Range.prototype.toString = function () {
    if (this.size === 0) {
      return 'Range []';
    }

    return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
  };

  Range.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };

  Range.prototype.includes = function (searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };

  Range.prototype.slice = function (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);

    if (end <= begin) {
      return new Range(0, 0);
    }

    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  };

  Range.prototype.indexOf = function (searchValue) {
    var offsetValue = searchValue - this._start;

    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;

      if (index >= 0 && index < this.size) {
        return index;
      }
    }

    return -1;
  };

  Range.prototype.lastIndexOf = function (searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function (fn, reverse) {
    var maxIndex = this.size - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;

    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(value, ii, this) === false) {
        return ii + 1;
      }

      value += reverse ? -step : step;
    }

    return ii;
  };

  Range.prototype.__iterator = function (type, reverse) {
    var maxIndex = this.size - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;
    var ii = 0;
    return new Iterator(function () {
      var v = value;
      value += reverse ? -step : step;
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
    });
  };

  Range.prototype.equals = function (other) {
    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };

  var EMPTY_RANGE;
  createClass(Collection, Iterable);

  function Collection() {
    throw TypeError('Abstract');
  }

  createClass(KeyedCollection, Collection);

  function KeyedCollection() {}

  createClass(IndexedCollection, Collection);

  function IndexedCollection() {}

  createClass(SetCollection, Collection);

  function SetCollection() {}

  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;
  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
    a = a | 0; // int

    b = b | 0; // int

    var c = a & 0xffff;
    var d = b & 0xffff; // Shift by 0 fixes the sign on the high part.

    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
  }; // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.

  function smi(i32) {
    return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }

    if (typeof o.valueOf === 'function') {
      o = o.valueOf();

      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }

    if (o === true) {
      return 1;
    }

    var type = typeof o;

    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }

      var h = o | 0;

      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }

      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }

      return smi(h);
    }

    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }

    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }

    if (type === 'object') {
      return hashJSObj(o);
    }

    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }

    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];

    if (hash === undefined) {
      hash = hashString(string);

      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }

      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }

    return hash;
  } // http://jsperf.com/hashing-strings


  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;

    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }

    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;

    if (usingWeakMap) {
      hash = weakMap.get(obj);

      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];

    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];

      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);

      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;

    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function () {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };

      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  } // Get references to ES5 object methods.


  var isExtensible = Object.isExtensible; // True if Object.defineProperty works as expected. IE8 fails this test.

  var canDefineProperty = function () {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }(); // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.


  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1:
          // Element
          return node.uniqueID;

        case 9:
          // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  } // If possible, use a WeakMap.


  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;

  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;
  var UID_HASH_KEY = '__immutablehash__';

  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
  }

  createClass(Map, KeyedCollection); // @pragma Construction

  function Map(value) {
    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  Map.of = function () {
    var keyValues = SLICE$0.call(arguments, 0);
    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }

        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function () {
    return this.__toString('Map {', '}');
  }; // @pragma Access


  Map.prototype.get = function (k, notSetValue) {
    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
  }; // @pragma Modification


  Map.prototype.set = function (k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.setIn = function (keyPath, v) {
    return this.updateIn(keyPath, NOT_SET, function () {
      return v;
    });
  };

  Map.prototype.remove = function (k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteIn = function (keyPath) {
    return this.updateIn(keyPath, function () {
      return NOT_SET;
    });
  };

  Map.prototype.update = function (k, notSetValue, updater) {
    return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
  };

  Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }

    var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
    return updatedValue === NOT_SET ? undefined : updatedValue;
  };

  Map.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyMap();
  }; // @pragma Composition


  Map.prototype.merge = function ()
  /*...iters*/
  {
    return mergeIntoMapWith(this, undefined, arguments);
  };

  Map.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoMapWith(this, merger, iters);
  };

  Map.prototype.mergeIn = function (keyPath) {
    var iters = SLICE$0.call(arguments, 1);
    return this.updateIn(keyPath, emptyMap(), function (m) {
      return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
    });
  };

  Map.prototype.mergeDeep = function ()
  /*...iters*/
  {
    return mergeIntoMapWith(this, deepMerger, arguments);
  };

  Map.prototype.mergeDeepWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoMapWith(this, deepMergerWith(merger), iters);
  };

  Map.prototype.mergeDeepIn = function (keyPath) {
    var iters = SLICE$0.call(arguments, 1);
    return this.updateIn(keyPath, emptyMap(), function (m) {
      return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
    });
  };

  Map.prototype.sort = function (comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function (mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  }; // @pragma Mutability


  Map.prototype.withMutations = function (fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  };

  Map.prototype.asMutable = function () {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  };

  Map.prototype.asImmutable = function () {
    return this.__ensureOwner();
  };

  Map.prototype.wasAltered = function () {
    return this.__altered;
  };

  Map.prototype.__iterator = function (type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var iterations = 0;
    this._root && this._root.iterate(function (entry) {
      iterations++;
      return fn(entry[1], entry[0], this$0);
    }, reverse);
    return iterations;
  };

  Map.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;
  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn; // #pragma Trie Nodes

  function ArrayMapNode(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }

  ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    var entries = this.entries;

    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }

    return notSetValue;
  };

  ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var entries = this.entries;
    var idx = 0;

    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }

    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && entries.length === 1) {
      return; // undefined
    }

    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new ArrayMapNode(ownerID, newEntries);
  };

  function BitmapIndexedNode(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }

  BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
  };

  BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var bit = 1 << keyHashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;

    if (!exists && value === NOT_SET) {
      return this;
    }

    var idx = popCount(bitmap & bit - 1);
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : undefined;
    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

    if (newNode === node) {
      return this;
    }

    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }

    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }

    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }

    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  };

  function HashArrayMapNode(ownerID, count, nodes) {
    this.ownerID = ownerID;
    this.count = count;
    this.nodes = nodes;
  }

  HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
  };

  HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];

    if (removed && !node) {
      return this;
    }

    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

    if (newNode === node) {
      return this;
    }

    var newCount = this.count;

    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;

      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }

    return new HashArrayMapNode(ownerID, newCount, newNodes);
  };

  function HashCollisionNode(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }

  HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    var entries = this.entries;

    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }

    return notSetValue;
  };

  HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var removed = value === NOT_SET;

    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }

      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
    }

    var entries = this.entries;
    var idx = 0;

    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }

    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  };

  function ValueNode(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
  }

  ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  };

  ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);

    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }

    SetRef(didAlter);

    if (removed) {
      SetRef(didChangeSize);
      return; // undefined
    }

    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }

      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }

    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
  }; // #pragma Iterators


  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;

    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  };

  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;

    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];

      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  };

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  };

  createClass(MapIterator, Iterator);

  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  MapIterator.prototype.next = function () {
    var type = this._type;
    var stack = this._stack;

    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex;

      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;

        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;

        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];

          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }

            stack = this._stack = mapIteratorFrame(subNode, stack);
          }

          continue;
        }
      }

      stack = this._stack = this._stack.__prev;
    }

    return iteratorDone();
  };

  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;

  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;

    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }

      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);

      if (!didAlter.value) {
        return map;
      }

      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }

    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }

    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }

      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }

    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var newNode;
    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }

    var node = new ValueNode(ownerID, hash(key), [key, value]);

    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }

    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);

    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];

      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }

    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);

    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }

    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];

    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);

      if (!isIterable(value)) {
        iter = iter.map(function (v) {
          return fromJS(v);
        });
      }

      iters.push(iter);
    }

    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function (existing, value, key) {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }

      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function (x) {
      return x.size !== 0;
    });

    if (iters.length === 0) {
      return collection;
    }

    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }

    return collection.withMutations(function (collection) {
      var mergeIntoMap = merger ? function (value, key) {
        collection.update(key, NOT_SET, function (existing) {
          return existing === NOT_SET ? value : merger(existing, value, key);
        });
      } : function (value, key) {
        collection.set(key, value);
      };

      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();

    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }

    invariant(isNotSet || existing && existing.set, 'invalid keyPath');
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - (x >> 1 & 0x55555555);
    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
    x = x + (x >> 4) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;

    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }

    var newArray = new Array(newLen);
    var after = 0;

    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }

    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;

    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }

    var newArray = new Array(newLen);
    var after = 0;

    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }

      newArray[ii] = array[ii + after];
    }

    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
  createClass(List, IndexedCollection); // @pragma Construction

  function List(value) {
    var empty = emptyList();

    if (value === null || value === undefined) {
      return empty;
    }

    if (isList(value)) {
      return value;
    }

    var iter = IndexedIterable(value);
    var size = iter.size;

    if (size === 0) {
      return empty;
    }

    assertNotInfinite(size);

    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }

    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) {
        return list.set(i, v);
      });
    });
  }

  List.of = function ()
  /*...values*/
  {
    return this(arguments);
  };

  List.prototype.toString = function () {
    return this.__toString('List [', ']');
  }; // @pragma Access


  List.prototype.get = function (index, notSetValue) {
    index = wrapIndex(this, index);

    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }

    return notSetValue;
  }; // @pragma Modification


  List.prototype.set = function (index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function (index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };

  List.prototype.insert = function (index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyList();
  };

  List.prototype.push = function ()
  /*...values*/
  {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function () {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function ()
  /*...values*/
  {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function () {
    return setListBounds(this, 1);
  }; // @pragma Composition


  List.prototype.merge = function ()
  /*...iters*/
  {
    return mergeIntoListWith(this, undefined, arguments);
  };

  List.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoListWith(this, merger, iters);
  };

  List.prototype.mergeDeep = function ()
  /*...iters*/
  {
    return mergeIntoListWith(this, deepMerger, arguments);
  };

  List.prototype.mergeDeepWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoListWith(this, deepMergerWith(merger), iters);
  };

  List.prototype.setSize = function (size) {
    return setListBounds(this, 0, size);
  }; // @pragma Iteration


  List.prototype.slice = function (begin, end) {
    var size = this.size;

    if (wholeSlice(begin, end, size)) {
      return this;
    }

    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
  };

  List.prototype.__iterator = function (type, reverse) {
    var index = 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
    });
  };

  List.prototype.__iterate = function (fn, reverse) {
    var index = 0;
    var values = iterateList(this, reverse);
    var value;

    while ((value = values()) !== DONE) {
      if (fn(value, index++, this) === false) {
        break;
      }
    }

    return index;
  };

  List.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      return this;
    }

    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
  };

  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;
  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;

  function VNode(array, ownerID) {
    this.array = array;
    this.ownerID = ownerID;
  } // TODO: seems like these methods are very similar


  VNode.prototype.removeBefore = function (ownerID, level, index) {
    if (index === level ? 1 << level :  false || this.array.length === 0) {
      return this;
    }

    var originIndex = index >>> level & MASK;

    if (originIndex >= this.array.length) {
      return new VNode([], ownerID);
    }

    var removingFirst = originIndex === 0;
    var newChild;

    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);

      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }

    if (removingFirst && !newChild) {
      return this;
    }

    var editable = editableVNode(this, ownerID);

    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        editable.array[ii] = undefined;
      }
    }

    if (newChild) {
      editable.array[originIndex] = newChild;
    }

    return editable;
  };

  VNode.prototype.removeAfter = function (ownerID, level, index) {
    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
      return this;
    }

    var sizeIndex = index - 1 >>> level & MASK;

    if (sizeIndex >= this.array.length) {
      return this;
    }

    var newChild;

    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);

      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
        return this;
      }
    }

    var editable = editableVNode(this, ownerID);
    editable.array.splice(sizeIndex + 1);

    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }

    return editable;
  };

  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;
    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;

      if (to > SIZE) {
        to = SIZE;
      }

      return function () {
        if (from === to) {
          return DONE;
        }

        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : left - offset >> level;
      var to = (right - offset >> level) + 1;

      if (to > SIZE) {
        to = SIZE;
      }

      return function () {
        do {
          if (values) {
            var value = values();

            if (value !== DONE) {
              return value;
            }

            values = null;
          }

          if (from === to) {
            return DONE;
          }

          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;

  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function (list) {
        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
      });
    }

    index += list._origin;
    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);

    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }

    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = index >>> level & MASK;
    var nodeHas = node && idx < node.array.length;

    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);

      if (newLowerNode === lowerNode) {
        return node;
      }

      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);
    newNode = editableVNode(node, ownerID);

    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }

    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }

    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }

    if (rawIndex < 1 << list._level + SHIFT) {
      var node = list._root;
      var level = list._level;

      while (node && level > 0) {
        node = node.array[rawIndex >>> level & MASK];
        level -= SHIFT;
      }

      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }

    if (end !== undefined) {
      end = end | 0;
    }

    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;

    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    } // If it's going to end after it starts, it's empty.


    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root; // New origin might need creating a higher root.

    var offsetShift = 0;

    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }

    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity); // New size might need creating a higher root.

    while (newTailOffset >= 1 << newLevel + SHIFT) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    } // Locate or create the new tail.


    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail; // Merge Tail into tree.

    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;

      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = oldTailOffset >>> level & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }

      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
    } // If the size has been reduced, there's a chance the tail needs to be trimmed.


    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    } // If the new origin is within the tail, then we do not need a root.


    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin); // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0; // Identify the new top root node of the subtree of the old root.

      while (newRoot) {
        var beginIndex = newOrigin >>> newLevel & MASK;

        if (beginIndex !== newTailOffset >>> newLevel & MASK) {
          break;
        }

        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }

        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      } // Trim the new sides of the new root.


      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }

      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }

      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }

    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;

    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);

      if (iter.size > maxSize) {
        maxSize = iter.size;
      }

      if (!isIterable(value)) {
        iter = iter.map(function (v) {
          return fromJS(v);
        });
      }

      iters.push(iter);
    }

    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }

    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
  }

  createClass(OrderedMap, Map); // @pragma Construction

  function OrderedMap(value) {
    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  OrderedMap.of = function ()
  /*...values*/
  {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function () {
    return this.__toString('OrderedMap {', '}');
  }; // @pragma Access


  OrderedMap.prototype.get = function (k, notSetValue) {
    var index = this._map.get(k);

    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  }; // @pragma Modification


  OrderedMap.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;

      this._map.clear();

      this._list.clear();

      return this;
    }

    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function (k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function (k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function () {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._list.__iterate(function (entry) {
      return entry && fn(entry[1], entry[0], this$0);
    }, reverse);
  };

  OrderedMap.prototype.__iterator = function (type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    var newList = this._list.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }

    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;
  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;

  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;

    if (v === NOT_SET) {
      // removed
      if (!has) {
        return omap;
      }

      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function (entry, idx) {
          return entry !== undefined && i !== idx;
        });
        newMap = newList.toKeyedSeq().map(function (entry) {
          return entry[0];
        }).flip().toMap();

        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }

        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }

    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }

    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);

  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  ToKeyedSequence.prototype.get = function (key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function (key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function () {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function () {
    var this$0 = this;
    var reversedSequence = reverseFactory(this, true);

    if (!this._useKeys) {
      reversedSequence.valueSeq = function () {
        return this$0._iter.toSeq().reverse();
      };
    }

    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function (mapper, context) {
    var this$0 = this;
    var mappedSequence = mapFactory(this, mapper, context);

    if (!this._useKeys) {
      mappedSequence.valueSeq = function () {
        return this$0._iter.toSeq().map(mapper, context);
      };
    }

    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var ii;
    return this._iter.__iterate(this._useKeys ? function (v, k) {
      return fn(v, k, this$0);
    } : (ii = reverse ? resolveSize(this) : 0, function (v) {
      return fn(v, reverse ? --ii : ii++, this$0);
    }), reverse);
  };

  ToKeyedSequence.prototype.__iterator = function (type, reverse) {
    if (this._useKeys) {
      return this._iter.__iterator(type, reverse);
    }

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    var ii = reverse ? resolveSize(this) : 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
    });
  };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
  createClass(ToIndexedSequence, IndexedSeq);

  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  ToIndexedSequence.prototype.includes = function (value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var iterations = 0;
    return this._iter.__iterate(function (v) {
      return fn(v, iterations++, this$0);
    }, reverse);
  };

  ToIndexedSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value, step);
    });
  };

  createClass(ToSetSequence, SetSeq);

  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  ToSetSequence.prototype.has = function (key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._iter.__iterate(function (v) {
      return fn(v, v, this$0);
    }, reverse);
  };

  ToSetSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };

  createClass(FromEntriesSequence, KeyedSeq);

  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  FromEntriesSequence.prototype.entrySeq = function () {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._iter.__iterate(function (entry) {
      // Check if entry exists first so array access doesn't throw for holes
      // in the parent iteration.
      if (entry) {
        validateEntry(entry);
        var indexedIterable = isIterable(entry);
        return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
      }
    }, reverse);
  };

  FromEntriesSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      while (true) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value; // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.

        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
        }
      }
    });
  };

  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;

    flipSequence.flip = function () {
      return iterable;
    };

    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()

      reversedSequence.flip = function () {
        return iterable.reverse();
      };

      return reversedSequence;
    };

    flipSequence.has = function (key) {
      return iterable.includes(key);
    };

    flipSequence.includes = function (key) {
      return iterable.has(key);
    };

    flipSequence.cacheResult = cacheResultThrough;

    flipSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k) {
        return fn(k, v, this$0) !== false;
      }, reverse);
    };

    flipSequence.__iteratorUncached = function (type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);

        return new Iterator(function () {
          var step = iterator.next();

          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }

          return step;
        });
      }

      return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
    };

    return flipSequence;
  }

  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;

    mappedSequence.has = function (key) {
      return iterable.has(key);
    };

    mappedSequence.get = function (key, notSetValue) {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
    };

    mappedSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$0) !== false;
      }, reverse);
    };

    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      return new Iterator(function () {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value;
        var key = entry[0];
        return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
      });
    };

    return mappedSequence;
  }

  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;

    reversedSequence.reverse = function () {
      return iterable;
    };

    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);

        flipSequence.reverse = function () {
          return iterable.flip();
        };

        return flipSequence;
      };
    }

    reversedSequence.get = function (key, notSetValue) {
      return iterable.get(useKeys ? key : -1 - key, notSetValue);
    };

    reversedSequence.has = function (key) {
      return iterable.has(useKeys ? key : -1 - key);
    };

    reversedSequence.includes = function (value) {
      return iterable.includes(value);
    };

    reversedSequence.cacheResult = cacheResultThrough;

    reversedSequence.__iterate = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k) {
        return fn(v, k, this$0);
      }, !reverse);
    };

    reversedSequence.__iterator = function (type, reverse) {
      return iterable.__iterator(type, !reverse);
    };

    return reversedSequence;
  }

  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);

    if (useKeys) {
      filterSequence.has = function (key) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };

      filterSequence.get = function (key, notSetValue) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
      };
    }

    filterSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);

      return iterations;
    };

    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var iterations = 0;
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();

          if (step.done) {
            return step;
          }

          var entry = step.value;
          var key = entry[0];
          var value = entry[1];

          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    };

    return filterSequence;
  }

  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();

    iterable.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
        return a + 1;
      });
    });

    return groups.asImmutable();
  }

  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();

    iterable.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, iterable), function (a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      });
    });

    var coerce = iterableClass(iterable);
    return groups.map(function (arr) {
      return reify(iterable, coerce(arr));
    });
  }

  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size; // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32

    if (begin !== undefined) {
      begin = begin | 0;
    }

    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize); // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.

    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    } // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.


    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;

    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable); // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0

    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
      };
    }

    sliceSeq.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (sliceSize === 0) {
        return 0;
      }

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;

      iterable.__iterate(function (v, k) {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
        }
      });

      return iterations;
    };

    sliceSeq.__iteratorUncached = function (type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      } // Don't bother instantiating parent iterator if taking 0.


      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);

      var skipped = 0;
      var iterations = 0;
      return new Iterator(function () {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }

        if (++iterations > sliceSize) {
          return iteratorDone();
        }

        var step = iterator.next();

        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    };

    return sliceSeq;
  }

  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);

    takeSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
      });

      return iterations;
    };

    takeSequence.__iteratorUncached = function (type, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }

      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var iterating = true;
      return new Iterator(function () {
        if (!iterating) {
          return iteratorDone();
        }

        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value;
        var k = entry[0];
        var v = entry[1];

        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }

        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };

    return takeSequence;
  }

  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);

    skipSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var isSkipping = true;
      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });

      return iterations;
    };

    skipSequence.__iteratorUncached = function (type, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }

      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var skipping = true;
      var iterations = 0;
      return new Iterator(function () {
        var step, k, v;

        do {
          step = iterator.next();

          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }

          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);

        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };

    return skipSequence;
  }

  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function (v) {
      if (!isIterable(v)) {
        v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }

      return v;
    }).filter(function (v) {
      return v.size !== 0;
    });

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];

      if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);

    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }

    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(function (sum, seq) {
      if (sum !== undefined) {
        var size = seq.size;

        if (size !== undefined) {
          return sum + size;
        }
      }
    }, 0);
    return concatSeq;
  }

  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);

    flatSequence.__iterateUncached = function (fn, reverse) {
      var iterations = 0;
      var stopped = false;

      function flatDeep(iter, currentDepth) {
        var this$0 = this;

        iter.__iterate(function (v, k) {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }

          return !stopped;
        }, reverse);
      }

      flatDeep(iterable, 0);
      return iterations;
    };

    flatSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(type, reverse);

      var stack = [];
      var iterations = 0;
      return new Iterator(function () {
        while (iterator) {
          var step = iterator.next();

          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }

          var v = step.value;

          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }

          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }

        return iteratorDone();
      });
    };

    return flatSequence;
  }

  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(function (v, k) {
      return coerce(mapper.call(context, v, k, iterable));
    }).flatten(true);
  }

  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 - 1;

    interposedSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;

      iterable.__iterate(function (v, k) {
        return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
      }, reverse);

      return iterations;
    };

    interposedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);

      var iterations = 0;
      var step;
      return new Iterator(function () {
        if (!step || iterations % 2) {
          step = iterator.next();

          if (step.done) {
            return step;
          }
        }

        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
      });
    };

    return interposedSequence;
  }

  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }

    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(function (v, k) {
      return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
    }).toArray();
    entries.sort(function (a, b) {
      return comparator(a[3], b[3]) || a[2] - b[2];
    }).forEach(isKeyedIterable ? function (v, i) {
      entries[i].length = 2;
    } : function (v, i) {
      entries[i] = v[1];
    });
    return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
  }

  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }

    if (mapper) {
      var entry = iterable.toSeq().map(function (v, k) {
        return [v, mapper(v, k, iterable)];
      }).reduce(function (a, b) {
        return maxCompare(comparator, a[1], b[1]) ? b : a;
      });
      return entry && entry[0];
    } else {
      return iterable.reduce(function (a, b) {
        return maxCompare(comparator, a, b) ? b : a;
      });
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a); // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.

    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
  }

  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function (i) {
      return i.size;
    }).min(); // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.

    zipSequence.__iterate = function (fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);

      var step;
      var iterations = 0;

      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }

      return iterations;
    };

    zipSequence.__iteratorUncached = function (type, reverse) {
      var iterators = iters.map(function (i) {
        return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
      });
      var iterations = 0;
      var isDone = false;
      return new Iterator(function () {
        var steps;

        if (!isDone) {
          steps = iterators.map(function (i) {
            return i.next();
          });
          isDone = steps.some(function (s) {
            return s.done;
          });
        }

        if (isDone) {
          return iteratorDone();
        }

        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
          return s.value;
        })));
      });
    };

    return zipSequence;
  } // #pragma Helper Functions


  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();

      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);

    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }

      iter = getIterator(Iterable(keyPath));
    }

    return iter;
  }

  createClass(Record, KeyedCollection);

  function Record(defaultValues, name) {
    var hasInitialized;

    var RecordType = function Record(values) {
      if (values instanceof RecordType) {
        return values;
      }

      if (!(this instanceof RecordType)) {
        return new RecordType(values);
      }

      if (!hasInitialized) {
        hasInitialized = true;
        var keys = Object.keys(defaultValues);
        setProps(RecordTypePrototype, keys);
        RecordTypePrototype.size = keys.length;
        RecordTypePrototype._name = name;
        RecordTypePrototype._keys = keys;
        RecordTypePrototype._defaultValues = defaultValues;
      }

      this._map = Map(values);
    };

    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
    RecordTypePrototype.constructor = RecordType;
    return RecordType;
  }

  Record.prototype.toString = function () {
    return this.__toString(recordName(this) + ' {', '}');
  }; // @pragma Access


  Record.prototype.has = function (k) {
    return this._defaultValues.hasOwnProperty(k);
  };

  Record.prototype.get = function (k, notSetValue) {
    if (!this.has(k)) {
      return notSetValue;
    }

    var defaultVal = this._defaultValues[k];
    return this._map ? this._map.get(k, defaultVal) : defaultVal;
  }; // @pragma Modification


  Record.prototype.clear = function () {
    if (this.__ownerID) {
      this._map && this._map.clear();
      return this;
    }

    var RecordType = this.constructor;
    return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
  };

  Record.prototype.set = function (k, v) {
    if (!this.has(k)) {
      throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
    }

    if (this._map && !this._map.has(k)) {
      var defaultVal = this._defaultValues[k];

      if (v === defaultVal) {
        return this;
      }
    }

    var newMap = this._map && this._map.set(k, v);

    if (this.__ownerID || newMap === this._map) {
      return this;
    }

    return makeRecord(this, newMap);
  };

  Record.prototype.remove = function (k) {
    if (!this.has(k)) {
      return this;
    }

    var newMap = this._map && this._map.remove(k);

    if (this.__ownerID || newMap === this._map) {
      return this;
    }

    return makeRecord(this, newMap);
  };

  Record.prototype.wasAltered = function () {
    return this._map.wasAltered();
  };

  Record.prototype.__iterator = function (type, reverse) {
    var this$0 = this;
    return KeyedIterable(this._defaultValues).map(function (_, k) {
      return this$0.get(k);
    }).__iterator(type, reverse);
  };

  Record.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return KeyedIterable(this._defaultValues).map(function (_, k) {
      return this$0.get(k);
    }).__iterate(fn, reverse);
  };

  Record.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map && this._map.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }

    return makeRecord(this, newMap, ownerID);
  };

  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;

  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {// Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function () {
        return this.get(name);
      },
      set: function (value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection); // @pragma Construction

  function Set(value) {
    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  Set.of = function ()
  /*...values*/
  {
    return this(arguments);
  };

  Set.fromKeys = function (value) {
    return this(KeyedIterable(value).keySeq());
  };

  Set.prototype.toString = function () {
    return this.__toString('Set {', '}');
  }; // @pragma Access


  Set.prototype.has = function (value) {
    return this._map.has(value);
  }; // @pragma Modification


  Set.prototype.add = function (value) {
    return updateSet(this, this._map.set(value, true));
  };

  Set.prototype.remove = function (value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function () {
    return updateSet(this, this._map.clear());
  }; // @pragma Composition


  Set.prototype.union = function () {
    var iters = SLICE$0.call(arguments, 0);
    iters = iters.filter(function (x) {
      return x.size !== 0;
    });

    if (iters.length === 0) {
      return this;
    }

    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }

    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetIterable(iters[ii]).forEach(function (value) {
          return set.add(value);
        });
      }
    });
  };

  Set.prototype.intersect = function () {
    var iters = SLICE$0.call(arguments, 0);

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetIterable(iter);
    });
    var originalSet = this;
    return this.withMutations(function (set) {
      originalSet.forEach(function (value) {
        if (!iters.every(function (iter) {
          return iter.includes(value);
        })) {
          set.remove(value);
        }
      });
    });
  };

  Set.prototype.subtract = function () {
    var iters = SLICE$0.call(arguments, 0);

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetIterable(iter);
    });
    var originalSet = this;
    return this.withMutations(function (set) {
      originalSet.forEach(function (value) {
        if (iters.some(function (iter) {
          return iter.includes(value);
        })) {
          set.remove(value);
        }
      });
    });
  };

  Set.prototype.merge = function () {
    return this.union.apply(this, arguments);
  };

  Set.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return this.union.apply(this, iters);
  };

  Set.prototype.sort = function (comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function (mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function () {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._map.__iterate(function (_, k) {
      return fn(k, k, this$0);
    }, reverse);
  };

  Set.prototype.__iterator = function (type, reverse) {
    return this._map.map(function (_, k) {
      return k;
    }).__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }

    return this.__make(newMap, ownerID);
  };

  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;
  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;
  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }

    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;

  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set); // @pragma Construction

  function OrderedSet(value) {
    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  OrderedSet.of = function ()
  /*...values*/
  {
    return this(arguments);
  };

  OrderedSet.fromKeys = function (value) {
    return this(KeyedIterable(value).keySeq());
  };

  OrderedSet.prototype.toString = function () {
    return this.__toString('OrderedSet {', '}');
  };

  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;
  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;

  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection); // @pragma Construction

  function Stack(value) {
    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
  }

  Stack.of = function ()
  /*...values*/
  {
    return this(arguments);
  };

  Stack.prototype.toString = function () {
    return this.__toString('Stack [', ']');
  }; // @pragma Access


  Stack.prototype.get = function (index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);

    while (head && index--) {
      head = head.next;
    }

    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function () {
    return this._head && this._head.value;
  }; // @pragma Modification


  Stack.prototype.push = function ()
  /*...values*/
  {
    if (arguments.length === 0) {
      return this;
    }

    var newSize = this.size + arguments.length;
    var head = this._head;

    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments[ii],
        next: head
      };
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function (iter) {
    iter = IndexedIterable(iter);

    if (iter.size === 0) {
      return this;
    }

    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.reverse().forEach(function (value) {
      newSize++;
      head = {
        value: value,
        next: head
      };
    });

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function () {
    return this.slice(1);
  };

  Stack.prototype.unshift = function ()
  /*...values*/
  {
    return this.push.apply(this, arguments);
  };

  Stack.prototype.unshiftAll = function (iter) {
    return this.pushAll(iter);
  };

  Stack.prototype.shift = function () {
    return this.pop.apply(this, arguments);
  };

  Stack.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyStack();
  };

  Stack.prototype.slice = function (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);

    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection.prototype.slice.call(this, begin, end);
    }

    var newSize = this.size - resolvedBegin;
    var head = this._head;

    while (resolvedBegin--) {
      head = head.next;
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  }; // @pragma Mutability


  Stack.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeStack(this.size, this._head, ownerID, this.__hash);
  }; // @pragma Iteration


  Stack.prototype.__iterate = function (fn, reverse) {
    if (reverse) {
      return this.reverse().__iterate(fn);
    }

    var iterations = 0;
    var node = this._head;

    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }

      node = node.next;
    }

    return iterations;
  };

  Stack.prototype.__iterator = function (type, reverse) {
    if (reverse) {
      return this.reverse().__iterator(type);
    }

    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }

      return iteratorDone();
    });
  };

  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;
  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;

  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;

  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }
  /**
   * Contributes additional methods to a constructor
   */


  function mixin(ctor, methods) {
    var keyCopier = function (key) {
      ctor.prototype[key] = methods[key];
    };

    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;
  mixin(Iterable, {
    // ### Conversion to other types
    toArray: function () {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);

      this.valueSeq().__iterate(function (v, i) {
        array[i] = v;
      });

      return array;
    },
    toIndexedSeq: function () {
      return new ToIndexedSequence(this);
    },
    toJS: function () {
      return this.toSeq().map(function (value) {
        return value && typeof value.toJS === 'function' ? value.toJS() : value;
      }).__toJS();
    },
    toJSON: function () {
      return this.toSeq().map(function (value) {
        return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
      }).__toJS();
    },
    toKeyedSeq: function () {
      return new ToKeyedSequence(this, true);
    },
    toMap: function () {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },
    toObject: function () {
      assertNotInfinite(this.size);
      var object = {};

      this.__iterate(function (v, k) {
        object[k] = v;
      });

      return object;
    },
    toOrderedMap: function () {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },
    toOrderedSet: function () {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },
    toSet: function () {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },
    toSetSeq: function () {
      return new ToSetSequence(this);
    },
    toSeq: function () {
      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
    },
    toStack: function () {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },
    toList: function () {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },
    // ### Common JavaScript methods and properties
    toString: function () {
      return '[Iterable]';
    },
    __toString: function (head, tail) {
      if (this.size === 0) {
        return head + tail;
      }

      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    concat: function () {
      var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },
    includes: function (searchValue) {
      return this.some(function (value) {
        return is(value, searchValue);
      });
    },
    entries: function () {
      return this.__iterator(ITERATE_ENTRIES);
    },
    every: function (predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;

      this.__iterate(function (v, k, c) {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });

      return returnValue;
    },
    filter: function (predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },
    find: function (predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },
    forEach: function (sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },
    join: function (separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;

      this.__iterate(function (v) {
        isFirst ? isFirst = false : joined += separator;
        joined += v !== null && v !== undefined ? v.toString() : '';
      });

      return joined;
    },
    keys: function () {
      return this.__iterator(ITERATE_KEYS);
    },
    map: function (mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },
    reduce: function (reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;

      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }

      this.__iterate(function (v, k, c) {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });

      return reduction;
    },
    reduceRight: function (reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },
    reverse: function () {
      return reify(this, reverseFactory(this, true));
    },
    slice: function (begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },
    some: function (predicate, context) {
      return !this.every(not(predicate), context);
    },
    sort: function (comparator) {
      return reify(this, sortFactory(this, comparator));
    },
    values: function () {
      return this.__iterator(ITERATE_VALUES);
    },
    // ### More sequential methods
    butLast: function () {
      return this.slice(0, -1);
    },
    isEmpty: function () {
      return this.size !== undefined ? this.size === 0 : !this.some(function () {
        return true;
      });
    },
    count: function (predicate, context) {
      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
    },
    countBy: function (grouper, context) {
      return countByFactory(this, grouper, context);
    },
    equals: function (other) {
      return deepEqual(this, other);
    },
    entrySeq: function () {
      var iterable = this;

      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }

      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();

      entriesSequence.fromEntrySeq = function () {
        return iterable.toSeq();
      };

      return entriesSequence;
    },
    filterNot: function (predicate, context) {
      return this.filter(not(predicate), context);
    },
    findEntry: function (predicate, context, notSetValue) {
      var found = notSetValue;

      this.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });

      return found;
    },
    findKey: function (predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },
    findLast: function (predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },
    findLastEntry: function (predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },
    findLastKey: function (predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },
    first: function () {
      return this.find(returnTrue);
    },
    flatMap: function (mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },
    flatten: function (depth) {
      return reify(this, flattenFactory(this, depth, true));
    },
    fromEntrySeq: function () {
      return new FromEntriesSequence(this);
    },
    get: function (searchKey, notSetValue) {
      return this.find(function (_, key) {
        return is(key, searchKey);
      }, undefined, notSetValue);
    },
    getIn: function (searchKeyPath, notSetValue) {
      var nested = this; // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {

      var iter = forceIterator(searchKeyPath);
      var step;

      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;

        if (nested === NOT_SET) {
          return notSetValue;
        }
      }

      return nested;
    },
    groupBy: function (grouper, context) {
      return groupByFactory(this, grouper, context);
    },
    has: function (searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },
    hasIn: function (searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },
    isSubset: function (iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function (value) {
        return iter.includes(value);
      });
    },
    isSuperset: function (iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },
    keyOf: function (searchValue) {
      return this.findKey(function (value) {
        return is(value, searchValue);
      });
    },
    keySeq: function () {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },
    last: function () {
      return this.toSeq().reverse().first();
    },
    lastKeyOf: function (searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },
    max: function (comparator) {
      return maxFactory(this, comparator);
    },
    maxBy: function (mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },
    min: function (comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },
    minBy: function (mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },
    rest: function () {
      return this.slice(1);
    },
    skip: function (amount) {
      return this.slice(Math.max(0, amount));
    },
    skipLast: function (amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },
    skipWhile: function (predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },
    skipUntil: function (predicate, context) {
      return this.skipWhile(not(predicate), context);
    },
    sortBy: function (mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },
    take: function (amount) {
      return this.slice(0, Math.max(0, amount));
    },
    takeLast: function (amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },
    takeWhile: function (predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },
    takeUntil: function (predicate, context) {
      return this.takeWhile(not(predicate), context);
    },
    valueSeq: function () {
      return this.toIndexedSeq();
    },
    // ### Hashable Object
    hashCode: function () {
      return this.__hash || (this.__hash = hashIterable(this));
    } // ### Internal
    // abstract __iterate(fn, reverse)
    // abstract __iterator(type, reverse)

  }); // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;

  IterablePrototype.inspect = IterablePrototype.toSource = function () {
    return this.toString();
  };

  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;
  mixin(KeyedIterable, {
    // ### More sequential methods
    flip: function () {
      return reify(this, flipFactory(this));
    },
    mapEntries: function (mapper, context) {
      var this$0 = this;
      var iterations = 0;
      return reify(this, this.toSeq().map(function (v, k) {
        return mapper.call(context, [k, v], iterations++, this$0);
      }).fromEntrySeq());
    },
    mapKeys: function (mapper, context) {
      var this$0 = this;
      return reify(this, this.toSeq().flip().map(function (k, v) {
        return mapper.call(context, k, v, this$0);
      }).flip());
    }
  });
  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;

  KeyedIterablePrototype.__toStringMapper = function (v, k) {
    return JSON.stringify(k) + ': ' + quoteString(v);
  };

  mixin(IndexedIterable, {
    // ### Conversion to other types
    toKeyedSeq: function () {
      return new ToKeyedSequence(this, false);
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    filter: function (predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },
    findIndex: function (predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },
    indexOf: function (searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },
    lastIndexOf: function (searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },
    reverse: function () {
      return reify(this, reverseFactory(this, false));
    },
    slice: function (begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },
    splice: function (index, removeNum
    /*, ...values*/
    ) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);

      if (numArgs === 0 || numArgs === 2 && !removeNum) {
        return this;
      } // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.


      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
    },
    // ### More collection methods
    findLastIndex: function (predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },
    first: function () {
      return this.get(0);
    },
    flatten: function (depth) {
      return reify(this, flattenFactory(this, depth, false));
    },
    get: function (index, notSetValue) {
      index = wrapIndex(this, index);
      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
        return key === index;
      }, undefined, notSetValue);
    },
    has: function (index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
    },
    interpose: function (separator) {
      return reify(this, interposeFactory(this, separator));
    },
    interleave: function ()
    /*...iterables*/
    {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);

      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }

      return reify(this, interleaved);
    },
    keySeq: function () {
      return Range(0, this.size);
    },
    last: function () {
      return this.get(-1);
    },
    skipWhile: function (predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },
    zip: function ()
    /*, ...iterables */
    {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },
    zipWith: function (zipper
    /*, ...iterables */
    ) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }
  });
  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
  mixin(SetIterable, {
    // ### ES6 Collection methods (ES6 Array and Map)
    get: function (value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },
    includes: function (value) {
      return this.has(value);
    },
    // ### More sequential methods
    keySeq: function () {
      return this.valueSeq();
    }
  });
  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes; // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);
  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype); // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  }

  function neg(predicate) {
    return function () {
      return -predicate.apply(this, arguments);
    };
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }

    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;

    var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
    } : function (v, k) {
      h = h + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function (v) {
      h = 31 * h + hash(v) | 0;
    } : function (v) {
      h = h + hash(v) | 0;
    });

    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {
    Iterable: Iterable,
    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,
    Record: Record,
    Range: Range,
    Repeat: Repeat,
    is: is,
    fromJS: fromJS
  };
  return Immutable;
});

/***/ }),

/***/ "./node_modules/immutable/dist/immutable.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.es.js ***!
  \*****************************************************/
/*! exports provided: default, version, Collection, Iterable, Seq, Map, OrderedMap, List, Stack, Set, OrderedSet, Record, Range, Repeat, is, fromJS, hash, isImmutable, isCollection, isKeyed, isIndexed, isAssociative, isOrdered, isValueObject, get, getIn, has, hasIn, merge, mergeDeep, mergeWith, mergeDeepWith, remove, removeIn, set, setIn, update, updateIn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collection", function() { return Collection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Iterable", function() { return Iterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Seq", function() { return Seq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedMap", function() { return OrderedMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Set", function() { return Set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedSet", function() { return OrderedSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Record", function() { return Record; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Repeat", function() { return Repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromJS", function() { return fromJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImmutable", function() { return isImmutable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCollection", function() { return isCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKeyed", function() { return isKeyed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIndexed", function() { return isIndexed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAssociative", function() { return isAssociative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOrdered", function() { return isOrdered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValueObject", function() { return isValueObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIn", function() { return getIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasIn", function() { return hasIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDeep", function() { return mergeDeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeWith", function() { return mergeWith$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWith", function() { return mergeDeepWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIn", function() { return removeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setIn", function() { return setIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateIn", function() { return updateIn; });
(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Used for setting prototype methods that IE8 chokes on.


var DELETE = 'delete'; // Constants describing the size of trie nodes.

var SHIFT = 5; // Resulted in best performance after ______?

var SIZE = 1 << SHIFT;
var MASK = SIZE - 1; // A consistent shared value representing "not set" which equals nothing other
// than itself, and nothing that could be provided externally.

var NOT_SET = {}; // Boolean references, Rough equivalent of `bool &`.

function MakeRef() {
  return {
    value: false
  };
}

function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
} // A function which returns a value representing an "owner" for transient writes
// to tries. The return value will only ever equal itself, and will not equal
// the return of any subsequent call of this function.


function OwnerID() {}

function ensureSize(iter) {
  if (iter.size === undefined) {
    iter.size = iter.__iterate(returnTrue);
  }

  return iter.size;
}

function wrapIndex(iter, index) {
  // This implements "is array index" which the ECMAString spec defines as:
  //
  //     A String property name P is an array index if and only if
  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
  //     to 2^32−1.
  //
  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
  if (typeof index !== 'number') {
    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32

    if ('' + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }

    index = uint32Index;
  }

  return index < 0 ? ensureSize(iter) + index : index;
}

function returnTrue() {
  return true;
}

function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
}

function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}

function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}

function resolveIndex(index, size, defaultIndex) {
  // Sanitize indices using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;
}

function isNeg(value) {
  // Account for -0 which is negative, but not less than 0.
  return value < 0 || value === 0 && 1 / value === -Infinity;
} // Note: value is unchanged to not break immutable-devtools.


var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';

function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}

var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';

function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}

var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';

function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}

function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}

var Collection = function Collection(value) {
  return isCollection(value) ? value : Seq(value);
};

var KeyedCollection =
/*@__PURE__*/
function (Collection) {
  function KeyedCollection(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  if (Collection) KeyedCollection.__proto__ = Collection;
  KeyedCollection.prototype = Object.create(Collection && Collection.prototype);
  KeyedCollection.prototype.constructor = KeyedCollection;
  return KeyedCollection;
}(Collection);

var IndexedCollection =
/*@__PURE__*/
function (Collection) {
  function IndexedCollection(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  if (Collection) IndexedCollection.__proto__ = Collection;
  IndexedCollection.prototype = Object.create(Collection && Collection.prototype);
  IndexedCollection.prototype.constructor = IndexedCollection;
  return IndexedCollection;
}(Collection);

var SetCollection =
/*@__PURE__*/
function (Collection) {
  function SetCollection(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  if (Collection) SetCollection.__proto__ = Collection;
  SetCollection.prototype = Object.create(Collection && Collection.prototype);
  SetCollection.prototype.constructor = SetCollection;
  return SetCollection;
}(Collection);

Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';

function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}

var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';

function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}

function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}

var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';

function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}

var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

var Iterator = function Iterator(next) {
  this.next = next;
};

Iterator.prototype.toString = function toString() {
  return '[Iterator]';
};

Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;

Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
  return this.toString();
};

Iterator.prototype[ITERATOR_SYMBOL] = function () {
  return this;
};

function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value: value,
    done: false
  };
  return iteratorResult;
}

function iteratorDone() {
  return {
    value: undefined,
    done: true
  };
}

function hasIterator(maybeIterable) {
  return !!getIteratorFn(maybeIterable);
}

function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === 'function';
}

function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}

function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);

  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === 'string') {
    return true;
  }

  return value && typeof value === 'object' && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? // Only {length: 0} is considered Array-like.
  Object.keys(value).length === 1 : // An object is only Array-like if it has a property where the last value
  // in the array-like may be found (which could be undefined).
  value.hasOwnProperty(value.length - 1));
}

var Seq =
/*@__PURE__*/
function (Collection$$1) {
  function Seq(value) {
    return value === null || value === undefined ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }

  if (Collection$$1) Seq.__proto__ = Collection$$1;
  Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);
  Seq.prototype.constructor = Seq;

  Seq.prototype.toSeq = function toSeq() {
    return this;
  };

  Seq.prototype.toString = function toString() {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }

    return this;
  }; // abstract __iterateUncached(fn, reverse)


  Seq.prototype.__iterate = function __iterate(fn, reverse) {
    var cache = this._cache;

    if (cache) {
      var size = cache.length;
      var i = 0;

      while (i !== size) {
        var entry = cache[reverse ? size - ++i : i++];

        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }

      return i;
    }

    return this.__iterateUncached(fn, reverse);
  }; // abstract __iteratorUncached(type, reverse)


  Seq.prototype.__iterator = function __iterator(type, reverse) {
    var cache = this._cache;

    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }

        var entry = cache[reverse ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }

    return this.__iteratorUncached(type, reverse);
  };

  return Seq;
}(Collection);

var KeyedSeq =
/*@__PURE__*/
function (Seq) {
  function KeyedSeq(value) {
    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }

  if (Seq) KeyedSeq.__proto__ = Seq;
  KeyedSeq.prototype = Object.create(Seq && Seq.prototype);
  KeyedSeq.prototype.constructor = KeyedSeq;

  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {
    return this;
  };

  return KeyedSeq;
}(Seq);

var IndexedSeq =
/*@__PURE__*/
function (Seq) {
  function IndexedSeq(value) {
    return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }

  if (Seq) IndexedSeq.__proto__ = Seq;
  IndexedSeq.prototype = Object.create(Seq && Seq.prototype);
  IndexedSeq.prototype.constructor = IndexedSeq;

  IndexedSeq.of = function of()
  /*...values*/
  {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {
    return this;
  };

  IndexedSeq.prototype.toString = function toString() {
    return this.__toString('Seq [', ']');
  };

  return IndexedSeq;
}(Seq);

var SetSeq =
/*@__PURE__*/
function (Seq) {
  function SetSeq(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }

  if (Seq) SetSeq.__proto__ = Seq;
  SetSeq.prototype = Object.create(Seq && Seq.prototype);
  SetSeq.prototype.constructor = SetSeq;

  SetSeq.of = function of()
  /*...values*/
  {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function toSetSeq() {
    return this;
  };

  return SetSeq;
}(Seq);

Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true; // #pragma Root Sequences

var ArraySeq =
/*@__PURE__*/
function (IndexedSeq) {
  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;
  ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
  ArraySeq.prototype.constructor = ArraySeq;

  ArraySeq.prototype.get = function get(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;

    while (i !== size) {
      var ii = reverse ? size - ++i : i++;

      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }

    return i;
  };

  ArraySeq.prototype.__iterator = function __iterator(type, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }

      var ii = reverse ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };

  return ArraySeq;
}(IndexedSeq);

var ObjectSeq =
/*@__PURE__*/
function (KeyedSeq) {
  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;
  ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);
  ObjectSeq.prototype.constructor = ObjectSeq;

  ObjectSeq.prototype.get = function get(key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }

    return this._object[key];
  };

  ObjectSeq.prototype.has = function has(key) {
    return hasOwnProperty.call(this._object, key);
  };

  ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;

    while (i !== size) {
      var key = keys[reverse ? size - ++i : i++];

      if (fn(object[key], key, this) === false) {
        break;
      }
    }

    return i;
  };

  ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }

      var key = keys[reverse ? size - ++i : i++];
      return iteratorValue(type, key, object[key]);
    });
  };

  return ObjectSeq;
}(KeyedSeq);

ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;

var CollectionSeq =
/*@__PURE__*/
function (IndexedSeq) {
  function CollectionSeq(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }

  if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;
  CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);
  CollectionSeq.prototype.constructor = CollectionSeq;

  CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;

    if (isIterator(iterator)) {
      var step;

      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }

    return iterations;
  };

  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var collection = this._collection;
    var iterator = getIterator(collection);

    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }

    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  return CollectionSeq;
}(IndexedSeq); // # pragma Helper functions


var EMPTY_SEQ;

function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}

function keyedSeqFromValue(value) {
  var seq = Array.isArray(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;

  if (seq) {
    return seq.fromEntrySeq();
  }

  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }

  throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);
}

function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);

  if (seq) {
    return seq;
  }

  throw new TypeError('Expected Array or collection object of values: ' + value);
}

function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);

  if (seq) {
    return seq;
  }

  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }

  throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);
}

function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;
}

var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';

function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}

function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}

function isValueObject(maybeValue) {
  return Boolean(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');
}
/**
 * An extension of the "same-value" algorithm as [described for use by ES6 Map
 * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
 *
 * NaN is considered the same as NaN, however -0 and 0 are considered the same
 * value, which is different from the algorithm described by
 * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
 *
 * This is extended further to allow Objects to describe the values they
 * represent, by way of `valueOf` or `equals` (and `hashCode`).
 *
 * Note: because of this extension, the key equality of Immutable.Map and the
 * value equality of Immutable.Set will differ from ES6 Map and Set.
 *
 * ### Defining custom values
 *
 * The easiest way to describe the value an object represents is by implementing
 * `valueOf`. For example, `Date` represents a value by returning a unix
 * timestamp for `valueOf`:
 *
 *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
 *     var date2 = new Date(1234567890000);
 *     date1.valueOf(); // 1234567890000
 *     assert( date1 !== date2 );
 *     assert( Immutable.is( date1, date2 ) );
 *
 * Note: overriding `valueOf` may have other implications if you use this object
 * where JavaScript expects a primitive, such as implicit string coercion.
 *
 * For more complex types, especially collections, implementing `valueOf` may
 * not be performant. An alternative is to implement `equals` and `hashCode`.
 *
 * `equals` takes another object, presumably of similar type, and returns true
 * if it is equal. Equality is symmetrical, so the same result should be
 * returned if this and the argument are flipped.
 *
 *     assert( a.equals(b) === b.equals(a) );
 *
 * `hashCode` returns a 32bit integer number representing the object which will
 * be used to determine how to store the value object in a Map or Set. You must
 * provide both or neither methods, one must not exist without the other.
 *
 * Also, an important relationship between these methods must be upheld: if two
 * values are equal, they *must* return the same hashCode. If the values are not
 * equal, they might have the same hashCode; this is called a hash collision,
 * and while undesirable for performance reasons, it is acceptable.
 *
 *     if (a.equals(b)) {
 *       assert( a.hashCode() === b.hashCode() );
 *     }
 *
 * All Immutable collections are Value Objects: they implement `equals()`
 * and `hashCode()`.
 */


function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }

  if (!valueA || !valueB) {
    return false;
  }

  if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();

    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }

    if (!valueA || !valueB) {
      return false;
    }
  }

  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}

var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
  a |= 0; // int

  b |= 0; // int

  var c = a & 0xffff;
  var d = b & 0xffff; // Shift by 0 fixes the sign on the high part.

  return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
}; // v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit.

function smi(i32) {
  return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;
}

var defaultValueOf = Object.prototype.valueOf;

function hash(o) {
  switch (typeof o) {
    case 'boolean':
      // The hash values for built-in constants are a 1 value for each 5-byte
      // shift region expect for the first, which encodes the value. This
      // reduces the odds of a hash collision for these common values.
      return o ? 0x42108421 : 0x42108420;

    case 'number':
      return hashNumber(o);

    case 'string':
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);

    case 'object':
    case 'function':
      if (o === null) {
        return 0x42108422;
      }

      if (typeof o.hashCode === 'function') {
        // Drop any high bits from accidentally long hash codes.
        return smi(o.hashCode(o));
      }

      if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {
        o = o.valueOf(o);
      }

      return hashJSObj(o);

    case 'undefined':
      return 0x42108423;

    default:
      if (typeof o.toString === 'function') {
        return hashString(o.toString());
      }

      throw new Error('Value type ' + typeof o + ' cannot be hashed.');
  }
} // Compress arbitrarily large numbers into smi hashes.


function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }

  var hash = n | 0;

  if (hash !== n) {
    hash ^= n * 0xffffffff;
  }

  while (n > 0xffffffff) {
    n /= 0xffffffff;
    hash ^= n;
  }

  return smi(hash);
}

function cachedHashString(string) {
  var hashed = stringHashCache[string];

  if (hashed === undefined) {
    hashed = hashString(string);

    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }

    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }

  return hashed;
} // http://jsperf.com/hashing-strings


function hashString(string) {
  // This is the hash from JVM
  // The hash code for a string is computed as
  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  // where s[i] is the ith character of the string and n is the length of
  // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  // (exclusive) by dropping high bits.
  var hashed = 0;

  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }

  return smi(hashed);
}

function hashJSObj(obj) {
  var hashed;

  if (usingWeakMap) {
    hashed = weakMap.get(obj);

    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = obj[UID_HASH_KEY];

  if (hashed !== undefined) {
    return hashed;
  }

  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];

    if (hashed !== undefined) {
      return hashed;
    }

    hashed = getIENodeHash(obj);

    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = ++objHashUID;

  if (objHashUID & 0x40000000) {
    objHashUID = 0;
  }

  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== undefined && isExtensible(obj) === false) {
    throw new Error('Non-extensible objects are not allowed as keys.');
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    // Since we can't define a non-enumerable property on the object
    // we'll hijack one of the less-used non-enumerable properties to
    // save our hash on it. Since this is a function it will not show up in
    // `JSON.stringify` which is what we want.
    obj.propertyIsEnumerable = function () {
      return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
    };

    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== undefined) {
    // At this point we couldn't get the IE `uniqueID` to use as a hash
    // and we couldn't use a non-enumerable property to exploit the
    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
    // itself.
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error('Unable to set a non-enumerable property on object.');
  }

  return hashed;
} // Get references to ES5 object methods.


var isExtensible = Object.isExtensible; // True if Object.defineProperty works as expected. IE8 fails this test.

var canDefineProperty = function () {
  try {
    Object.defineProperty({}, '@', {});
    return true;
  } catch (e) {
    return false;
  }
}(); // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
// and avoid memory leaks from the IE cloneNode bug.


function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        // Element
        return node.uniqueID;

      case 9:
        // Document
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
} // If possible, use a WeakMap.


var usingWeakMap = typeof WeakMap === 'function';
var weakMap;

if (usingWeakMap) {
  weakMap = new WeakMap();
}

var objHashUID = 0;
var UID_HASH_KEY = '__immutablehash__';

if (typeof Symbol === 'function') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}

var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};

var ToKeyedSequence =
/*@__PURE__*/
function (KeyedSeq$$1) {
  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;
  ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
  ToKeyedSequence.prototype.constructor = ToKeyedSequence;

  ToKeyedSequence.prototype.get = function get(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function has(key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function valueSeq() {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function reverse() {
    var this$1 = this;
    var reversedSequence = reverseFactory(this, true);

    if (!this._useKeys) {
      reversedSequence.valueSeq = function () {
        return this$1._iter.toSeq().reverse();
      };
    }

    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function map(mapper, context) {
    var this$1 = this;
    var mappedSequence = mapFactory(this, mapper, context);

    if (!this._useKeys) {
      mappedSequence.valueSeq = function () {
        return this$1._iter.toSeq().map(mapper, context);
      };
    }

    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    return this._iter.__iterate(function (v, k) {
      return fn(v, k, this$1);
    }, reverse);
  };

  ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {
    return this._iter.__iterator(type, reverse);
  };

  return ToKeyedSequence;
}(KeyedSeq);

ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;

var ToIndexedSequence =
/*@__PURE__*/
function (IndexedSeq$$1) {
  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;
  ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
  ToIndexedSequence.prototype.constructor = ToIndexedSequence;

  ToIndexedSequence.prototype.includes = function includes(value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    var i = 0;
    reverse && ensureSize(this);
    return this._iter.__iterate(function (v) {
      return fn(v, reverse ? this$1.size - ++i : i++, this$1);
    }, reverse);
  };

  ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {
    var this$1 = this;

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    var i = 0;
    reverse && ensureSize(this);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);
    });
  };

  return ToIndexedSequence;
}(IndexedSeq);

var ToSetSequence =
/*@__PURE__*/
function (SetSeq$$1) {
  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;
  ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);
  ToSetSequence.prototype.constructor = ToSetSequence;

  ToSetSequence.prototype.has = function has(key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    return this._iter.__iterate(function (v) {
      return fn(v, v, this$1);
    }, reverse);
  };

  ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };

  return ToSetSequence;
}(SetSeq);

var FromEntriesSequence =
/*@__PURE__*/
function (KeyedSeq$$1) {
  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;
  FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);
  FromEntriesSequence.prototype.constructor = FromEntriesSequence;

  FromEntriesSequence.prototype.entrySeq = function entrySeq() {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    return this._iter.__iterate(function (entry) {
      // Check if entry exists first so array access doesn't throw for holes
      // in the parent iteration.
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);
      }
    }, reverse);
  };

  FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      while (true) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value; // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.

        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
        }
      }
    });
  };

  return FromEntriesSequence;
}(KeyedSeq);

ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;

  flipSequence.flip = function () {
    return collection;
  };

  flipSequence.reverse = function () {
    var reversedSequence = collection.reverse.apply(this); // super.reverse()

    reversedSequence.flip = function () {
      return collection.reverse();
    };

    return reversedSequence;
  };

  flipSequence.has = function (key) {
    return collection.includes(key);
  };

  flipSequence.includes = function (key) {
    return collection.has(key);
  };

  flipSequence.cacheResult = cacheResultThrough;

  flipSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;
    return collection.__iterate(function (v, k) {
      return fn(k, v, this$1) !== false;
    }, reverse);
  };

  flipSequence.__iteratorUncached = function (type, reverse) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse);

      return new Iterator(function () {
        var step = iterator.next();

        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }

        return step;
      });
    }

    return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
  };

  return flipSequence;
}

function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;

  mappedSequence.has = function (key) {
    return collection.has(key);
  };

  mappedSequence.get = function (key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };

  mappedSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;
    return collection.__iterate(function (v, k, c) {
      return fn(mapper.call(context, v, k, c), k, this$1) !== false;
    }, reverse);
  };

  mappedSequence.__iteratorUncached = function (type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);

    return new Iterator(function () {
      var step = iterator.next();

      if (step.done) {
        return step;
      }

      var entry = step.value;
      var key = entry[0];
      return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
    });
  };

  return mappedSequence;
}

function reverseFactory(collection, useKeys) {
  var this$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;

  reversedSequence.reverse = function () {
    return collection;
  };

  if (collection.flip) {
    reversedSequence.flip = function () {
      var flipSequence = flipFactory(collection);

      flipSequence.reverse = function () {
        return collection.flip();
      };

      return flipSequence;
    };
  }

  reversedSequence.get = function (key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };

  reversedSequence.has = function (key) {
    return collection.has(useKeys ? key : -1 - key);
  };

  reversedSequence.includes = function (value) {
    return collection.includes(value);
  };

  reversedSequence.cacheResult = cacheResultThrough;

  reversedSequence.__iterate = function (fn, reverse) {
    var this$1 = this;
    var i = 0;
    reverse && ensureSize(collection);
    return collection.__iterate(function (v, k) {
      return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);
    }, !reverse);
  };

  reversedSequence.__iterator = function (type, reverse) {
    var i = 0;
    reverse && ensureSize(collection);

    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);

    return new Iterator(function () {
      var step = iterator.next();

      if (step.done) {
        return step;
      }

      var entry = step.value;
      return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);
    });
  };

  return reversedSequence;
}

function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);

  if (useKeys) {
    filterSequence.has = function (key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };

    filterSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }

  filterSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;
    var iterations = 0;

    collection.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    }, reverse);

    return iterations;
  };

  filterSequence.__iteratorUncached = function (type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);

    var iterations = 0;
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value;
        var key = entry[0];
        var value = entry[1];

        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };

  return filterSequence;
}

function countByFactory(collection, grouper, context) {
  var groups = Map().asMutable();

  collection.__iterate(function (v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function (a) {
      return a + 1;
    });
  });

  return groups.asImmutable();
}

function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();

  collection.__iterate(function (v, k) {
    groups.update(grouper.call(context, v, k, collection), function (a) {
      return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
    });
  });

  var coerce = collectionClass(collection);
  return groups.map(function (arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}

function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;

  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }

  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize); // begin or end will be NaN if they were provided as negative numbers and
  // this collection's size is unknown. In that case, cache first so there is
  // a known size and these do not resolve to NaN.

  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  } // Note: resolvedEnd is undefined when the original sequence's length is
  // unknown and this slice did not supply an end and should contain all
  // elements after resolvedBegin.
  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.


  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;

  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }

  var sliceSeq = makeSequence(collection); // If collection.size is undefined, the size of the realized sliceSeq is
  // unknown at this point unless the number of items to slice is 0

  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;

  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function (index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }

  sliceSeq.__iterateUncached = function (fn, reverse) {
    var this$1 = this;

    if (sliceSize === 0) {
      return 0;
    }

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;

    collection.__iterate(function (v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;
      }
    });

    return iterations;
  };

  sliceSeq.__iteratorUncached = function (type, reverse) {
    if (sliceSize !== 0 && reverse) {
      return this.cacheResult().__iterator(type, reverse);
    } // Don't bother instantiating parent iterator if taking 0.


    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }

    var iterator = collection.__iterator(type, reverse);

    var skipped = 0;
    var iterations = 0;
    return new Iterator(function () {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }

      if (++iterations > sliceSize) {
        return iteratorDone();
      }

      var step = iterator.next();

      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }

      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, undefined, step);
      }

      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };

  return sliceSeq;
}

function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);

  takeSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterations = 0;

    collection.__iterate(function (v, k, c) {
      return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);
    });

    return iterations;
  };

  takeSequence.__iteratorUncached = function (type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);

    var iterating = true;
    return new Iterator(function () {
      if (!iterating) {
        return iteratorDone();
      }

      var step = iterator.next();

      if (step.done) {
        return step;
      }

      var entry = step.value;
      var k = entry[0];
      var v = entry[1];

      if (!predicate.call(context, v, k, this$1)) {
        iterating = false;
        return iteratorDone();
      }

      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };

  return takeSequence;
}

function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);

  skipSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var isSkipping = true;
    var iterations = 0;

    collection.__iterate(function (v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    });

    return iterations;
  };

  skipSequence.__iteratorUncached = function (type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);

    var skipping = true;
    var iterations = 0;
    return new Iterator(function () {
      var step;
      var k;
      var v;

      do {
        step = iterator.next();

        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }

          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, undefined, step);
          }

          return iteratorValue(type, iterations++, step.value[1], step);
        }

        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1));
      } while (skipping);

      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };

  return skipSequence;
}

function concatFactory(collection, values) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values).map(function (v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }

    return v;
  }).filter(function (v) {
    return v.size !== 0;
  });

  if (iters.length === 0) {
    return collection;
  }

  if (iters.length === 1) {
    var singleton = iters[0];

    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }

  var concatSeq = new ArraySeq(iters);

  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }

  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function (sum, seq) {
    if (sum !== undefined) {
      var size = seq.size;

      if (size !== undefined) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}

function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);

  flatSequence.__iterateUncached = function (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterations = 0;
    var stopped = false;

    function flatDeep(iter, currentDepth) {
      iter.__iterate(function (v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;

          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }

        return !stopped;
      }, reverse);
    }

    flatDeep(collection, 0);
    return iterations;
  };

  flatSequence.__iteratorUncached = function (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterator = collection.__iterator(type, reverse);

    var stack = [];
    var iterations = 0;
    return new Iterator(function () {
      while (iterator) {
        var step = iterator.next();

        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }

        var v = step.value;

        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }

        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }

      return iteratorDone();
    });
  };

  return flatSequence;
}

function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function (v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}

function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;

  interposedSequence.__iterateUncached = function (fn, reverse) {
    var this$1 = this;
    var iterations = 0;

    collection.__iterate(function (v) {
      return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;
    }, reverse);

    return iterations;
  };

  interposedSequence.__iteratorUncached = function (type, reverse) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse);

    var iterations = 0;
    var step;
    return new Iterator(function () {
      if (!step || iterations % 2) {
        step = iterator.next();

        if (step.done) {
          return step;
        }
      }

      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };

  return interposedSequence;
}

function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }

  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries = collection.toSeq().map(function (v, k) {
    return [k, v, index++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries.sort(function (a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(isKeyedCollection ? function (v, i) {
    entries[i].length = 2;
  } : function (v, i) {
    entries[i] = v[1];
  });
  return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);
}

function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }

  if (mapper) {
    var entry = collection.toSeq().map(function (v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function (a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }

  return collection.reduce(function (a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}

function maxCompare(comparator, a, b) {
  var comp = comparator(b, a); // b is considered the new max if the comparator declares them equal, but
  // they are not equal and b is in fact a nullish value.

  return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
}

function zipWithFactory(keyIter, zipper, iters, zipAll) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function (i) {
    return i.size;
  });
  zipSequence.size = zipAll ? sizes.max() : sizes.min(); // Note: this a generic base implementation of __iterate in terms of
  // __iterator which may be more generically useful in the future.

  zipSequence.__iterate = function (fn, reverse) {
    /* generic:
    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      iterations++;
      if (fn(step.value[1], step.value[0], this) === false) {
        break;
      }
    }
    return iterations;
    */
    // indexed:
    var iterator = this.__iterator(ITERATE_VALUES, reverse);

    var step;
    var iterations = 0;

    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }

    return iterations;
  };

  zipSequence.__iteratorUncached = function (type, reverse) {
    var iterators = iters.map(function (i) {
      return i = Collection(i), getIterator(reverse ? i.reverse() : i);
    });
    var iterations = 0;
    var isDone = false;
    return new Iterator(function () {
      var steps;

      if (!isDone) {
        steps = iterators.map(function (i) {
          return i.next();
        });
        isDone = zipAll ? steps.every(function (s) {
          return s.done;
        }) : steps.some(function (s) {
          return s.done;
        });
      }

      if (isDone) {
        return iteratorDone();
      }

      return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
        return s.value;
      })));
    });
  };

  return zipSequence;
} // #pragma Helper Functions


function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}

function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError('Expected [K, V] tuple: ' + entry);
  }
}

function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}

function makeSequence(collection) {
  return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
}

function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();

    this.size = this._iter.size;
    return this;
  }

  return Seq.prototype.cacheResult.call(this);
}

function defaultComparator(a, b) {
  if (a === undefined && b === undefined) {
    return 0;
  }

  if (a === undefined) {
    return 1;
  }

  if (b === undefined) {
    return -1;
  }

  return a > b ? 1 : a < b ? -1 : 0;
} // http://jsperf.com/copy-array-inline


function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);

  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }

  return newArr;
}

function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}

function assertNotInfinite(size) {
  invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
}

function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
    return keyPath;
  }

  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }

  throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);
}

function isPlainObj(value) {
  return value && (typeof value.constructor !== 'function' || value.constructor.name === 'Object');
}
/**
 * Returns true if the value is a potentially-persistent data structure, either
 * provided by Immutable.js or a plain Array or Object.
 */


function isDataStructure(value) {
  return typeof value === 'object' && (isImmutable(value) || Array.isArray(value) || isPlainObj(value));
}
/**
 * Converts a value to a string, adding quotes if a string was provided.
 */


function quoteString(value) {
  try {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}

function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}

function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === 'function' ? collection.get(key) : collection[key];
}

function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }

  var to = {};

  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }

  return to;
}

function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError('Cannot update non-data-structure value: ' + collection);
  }

  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError('Cannot update immutable value without .remove() method: ' + collection);
    }

    return collection.remove(key);
  }

  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }

  var collectionCopy = shallowCopy(collection);

  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }

  return collectionCopy;
}

function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError('Cannot update non-data-structure value: ' + collection);
  }

  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError('Cannot update immutable value without .set() method: ' + collection);
    }

    return collection.set(key, value);
  }

  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }

  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}

function updateIn(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }

  var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}

function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;

  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }

  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError('Cannot update within non-data-structure value in path [' + keyPath.slice(0, i).map(quoteString) + ']: ' + existing);
  }

  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
}

function setIn(collection, keyPath, value) {
  return updateIn(collection, keyPath, NOT_SET, function () {
    return value;
  });
}

function setIn$1(keyPath, v) {
  return setIn(this, keyPath, v);
}

function removeIn(collection, keyPath) {
  return updateIn(collection, keyPath, function () {
    return NOT_SET;
  });
}

function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}

function update(collection, key, notSetValue, updater) {
  return updateIn(collection, [key], notSetValue, updater);
}

function update$1(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update(this, key, notSetValue, updater);
}

function updateIn$1(keyPath, notSetValue, updater) {
  return updateIn(this, keyPath, notSetValue, updater);
}

function merge() {
  var iters = [],
      len = arguments.length;

  while (len--) iters[len] = arguments[len];

  return mergeIntoKeyedWith(this, iters);
}

function mergeWith(merger) {
  var iters = [],
      len = arguments.length - 1;

  while (len-- > 0) iters[len] = arguments[len + 1];

  if (typeof merger !== 'function') {
    throw new TypeError('Invalid merger function: ' + merger);
  }

  return mergeIntoKeyedWith(this, iters, merger);
}

function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];

  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);

    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }

  if (iters.length === 0) {
    return collection;
  }

  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }

  return collection.withMutations(function (collection) {
    var mergeIntoCollection = merger ? function (value, key) {
      update(collection, key, NOT_SET, function (oldVal) {
        return oldVal === NOT_SET ? value : merger(oldVal, value, key);
      });
    } : function (value, key) {
      collection.set(key, value);
    };

    for (var ii = 0; ii < iters.length; ii++) {
      iters[ii].forEach(mergeIntoCollection);
    }
  });
}

function merge$1(collection) {
  var sources = [],
      len = arguments.length - 1;

  while (len-- > 0) sources[len] = arguments[len + 1];

  return mergeWithSources(collection, sources);
}

function mergeWith$1(merger, collection) {
  var sources = [],
      len = arguments.length - 2;

  while (len-- > 0) sources[len] = arguments[len + 2];

  return mergeWithSources(collection, sources, merger);
}

function mergeDeep(collection) {
  var sources = [],
      len = arguments.length - 1;

  while (len-- > 0) sources[len] = arguments[len + 1];

  return mergeDeepWithSources(collection, sources);
}

function mergeDeepWith(merger, collection) {
  var sources = [],
      len = arguments.length - 2;

  while (len-- > 0) sources[len] = arguments[len + 2];

  return mergeDeepWithSources(collection, sources, merger);
}

function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}

function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError('Cannot merge into non-data-structure value: ' + collection);
  }

  if (isImmutable(collection)) {
    return typeof merger === 'function' && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }

  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray ? function (value) {
    // Copy on write
    if (merged === collection) {
      merged = shallowCopy(merged);
    }

    merged.push(value);
  } : function (value, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;

    if (!hasVal || nextVal !== merged[key]) {
      // Copy on write
      if (merged === collection) {
        merged = shallowCopy(merged);
      }

      merged[key] = nextVal;
    }
  };

  for (var i = 0; i < sources.length; i++) {
    Collection$$1(sources[i]).forEach(mergeItem);
  }

  return merged;
}

function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }

  return deepMerger;
}

function mergeDeep$1() {
  var iters = [],
      len = arguments.length;

  while (len--) iters[len] = arguments[len];

  return mergeDeepWithSources(this, iters);
}

function mergeDeepWith$1(merger) {
  var iters = [],
      len = arguments.length - 1;

  while (len-- > 0) iters[len] = arguments[len + 1];

  return mergeDeepWithSources(this, iters, merger);
}

function mergeIn(keyPath) {
  var iters = [],
      len = arguments.length - 1;

  while (len-- > 0) iters[len] = arguments[len + 1];

  return updateIn(this, keyPath, emptyMap(), function (m) {
    return mergeWithSources(m, iters);
  });
}

function mergeDeepIn(keyPath) {
  var iters = [],
      len = arguments.length - 1;

  while (len-- > 0) iters[len] = arguments[len + 1];

  return updateIn(this, keyPath, emptyMap(), function (m) {
    return mergeDeepWithSources(m, iters);
  });
}

function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}

function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}

function asImmutable() {
  return this.__ensureOwner();
}

function wasAltered() {
  return this.__altered;
}

var Map =
/*@__PURE__*/
function (KeyedCollection$$1) {
  function Map(value) {
    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
      var iter = KeyedCollection$$1(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;
  Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);
  Map.prototype.constructor = Map;

  Map.of = function of() {
    var keyValues = [],
        len = arguments.length;

    while (len--) keyValues[len] = arguments[len];

    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }

        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function toString() {
    return this.__toString('Map {', '}');
  }; // @pragma Access


  Map.prototype.get = function get(k, notSetValue) {
    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
  }; // @pragma Modification


  Map.prototype.set = function set(k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.remove = function remove(k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteAll = function deleteAll(keys) {
    var collection = Collection(keys);

    if (collection.size === 0) {
      return this;
    }

    return this.withMutations(function (map) {
      collection.forEach(function (key) {
        return map.remove(key);
      });
    });
  };

  Map.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyMap();
  }; // @pragma Composition


  Map.prototype.sort = function sort(comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function sortBy(mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  };

  Map.prototype.map = function map(mapper, context) {
    return this.withMutations(function (map) {
      map.forEach(function (value, key) {
        map.set(key, mapper.call(context, value, key, map));
      });
    });
  }; // @pragma Mutability


  Map.prototype.__iterator = function __iterator(type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function (entry) {
      iterations++;
      return fn(entry[1], entry[0], this$1);
    }, reverse);
    return iterations;
  };

  Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }

      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  return Map;
}(KeyedCollection);

Map.isMap = isMap;
var MapPrototype = Map.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn$1;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update$1;
MapPrototype.updateIn = updateIn$1;
MapPrototype.merge = MapPrototype.concat = merge;
MapPrototype.mergeWith = mergeWith;
MapPrototype.mergeDeep = mergeDeep$1;
MapPrototype.mergeDeepWith = mergeDeepWith$1;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;

MapPrototype['@@transducer/step'] = function (result, arr) {
  return result.set(arr[0], arr[1]);
};

MapPrototype['@@transducer/result'] = function (obj) {
  return obj.asImmutable();
}; // #pragma Trie Nodes


var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
  this.ownerID = ownerID;
  this.entries = entries;
};

ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  var entries = this.entries;

  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }

  return notSetValue;
};

ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries = this.entries;
  var idx = 0;
  var len = entries.length;

  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }

  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && entries.length === 1) {
    return; // undefined
  }

  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries, key, value);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new ArrayMapNode(ownerID, newEntries);
};

var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};

BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
};

BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;

  if (!exists && value === NOT_SET) {
    return this;
  }

  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : undefined;
  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

  if (newNode === node) {
    return this;
  }

  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }

  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }

  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }

  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};

var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};

HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
};

HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];

  if (removed && !node) {
    return this;
  }

  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

  if (newNode === node) {
    return this;
  }

  var newCount = this.count;

  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;

    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }

  return new HashArrayMapNode(ownerID, newCount, newNodes);
};

var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries;
};

HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  var entries = this.entries;

  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }

  return notSetValue;
};

HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var removed = value === NOT_SET;

  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }

    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;

  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }

  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};

var ValueNode = function ValueNode(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};

ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};

ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);

  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }

  SetRef(didAlter);

  if (removed) {
    SetRef(didChangeSize);
    return; // undefined
  }

  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }

    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }

  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
}; // #pragma Iterators


ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
  var entries = this.entries;

  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};

BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
  var nodes = this.nodes;

  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse ? maxIndex - ii : ii];

    if (node && node.iterate(fn, reverse) === false) {
      return false;
    }
  }
}; // eslint-disable-next-line no-unused-vars


ValueNode.prototype.iterate = function (fn, reverse) {
  return fn(this.entry);
};

var MapIterator =
/*@__PURE__*/
function (Iterator$$1) {
  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;
  MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);
  MapIterator.prototype.constructor = MapIterator;

  MapIterator.prototype.next = function next() {
    var type = this._type;
    var stack = this._stack;

    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = void 0;

      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;

        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;

        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];

          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }

            stack = this._stack = mapIteratorFrame(subNode, stack);
          }

          continue;
        }
      }

      stack = this._stack = this._stack.__prev;
    }

    return iteratorDone();
  };

  return MapIterator;
}(Iterator);

function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}

function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev
  };
}

function makeMap(size, root, ownerID, hash$$1) {
  var map = Object.create(MapPrototype);
  map.size = size;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash$$1;
  map.__altered = false;
  return map;
}

var EMPTY_MAP;

function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}

function updateMap(map, k, v) {
  var newRoot;
  var newSize;

  if (!map._root) {
    if (v === NOT_SET) {
      return map;
    }

    newSize = 1;
    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);

    if (!didAlter.value) {
      return map;
    }

    newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }

  if (map.__ownerID) {
    map.size = newSize;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }

  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}

function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }

    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }

  return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
}

function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}

function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }

  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}

function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }

  var node = new ValueNode(ownerID, hash(key), [key, value]);

  for (var ii = 0; ii < entries.length; ii++) {
    var entry = entries[ii];
    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
  }

  return node;
}

function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);

  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];

    if (node !== undefined && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }

  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}

function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);

  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
  }

  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}

function popCount(x) {
  x -= x >> 1 & 0x55555555;
  x = (x & 0x33333333) + (x >> 2 & 0x33333333);
  x = x + (x >> 4) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}

function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}

function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;

  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }

  var newArray = new Array(newLen);
  var after = 0;

  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }

  return newArray;
}

function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;

  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }

  var newArray = new Array(newLen);
  var after = 0;

  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }

    newArray[ii] = array[ii + after];
  }

  return newArray;
}

var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';

function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}

var List =
/*@__PURE__*/
function (IndexedCollection$$1) {
  function List(value) {
    var empty = emptyList();

    if (value === null || value === undefined) {
      return empty;
    }

    if (isList(value)) {
      return value;
    }

    var iter = IndexedCollection$$1(value);
    var size = iter.size;

    if (size === 0) {
      return empty;
    }

    assertNotInfinite(size);

    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }

    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) {
        return list.set(i, v);
      });
    });
  }

  if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;
  List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
  List.prototype.constructor = List;

  List.of = function of()
  /*...values*/
  {
    return this(arguments);
  };

  List.prototype.toString = function toString() {
    return this.__toString('List [', ']');
  }; // @pragma Access


  List.prototype.get = function get(index, notSetValue) {
    index = wrapIndex(this, index);

    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }

    return notSetValue;
  }; // @pragma Modification


  List.prototype.set = function set(index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function remove(index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };

  List.prototype.insert = function insert(index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyList();
  };

  List.prototype.push = function push()
  /*...values*/
  {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function unshift()
  /*...values*/
  {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function shift() {
    return setListBounds(this, 1);
  }; // @pragma Composition


  List.prototype.concat = function concat()
  /*...collections*/
  {
    var arguments$1 = arguments;
    var seqs = [];

    for (var i = 0; i < arguments.length; i++) {
      var argument = arguments$1[i];
      var seq = IndexedCollection$$1(typeof argument !== 'string' && hasIterator(argument) ? argument : [argument]);

      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }

    if (seqs.length === 0) {
      return this;
    }

    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }

    return this.withMutations(function (list) {
      seqs.forEach(function (seq) {
        return seq.forEach(function (value) {
          return list.push(value);
        });
      });
    });
  };

  List.prototype.setSize = function setSize(size) {
    return setListBounds(this, 0, size);
  };

  List.prototype.map = function map(mapper, context) {
    var this$1 = this;
    return this.withMutations(function (list) {
      for (var i = 0; i < this$1.size; i++) {
        list.set(i, mapper.call(context, list.get(i), i, list));
      }
    });
  }; // @pragma Iteration


  List.prototype.slice = function slice(begin, end) {
    var size = this.size;

    if (wholeSlice(begin, end, size)) {
      return this;
    }

    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
  };

  List.prototype.__iterator = function __iterator(type, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);
    });
  };

  List.prototype.__iterate = function __iterate(fn, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    var value;

    while ((value = values()) !== DONE) {
      if (fn(value, reverse ? --index : index++, this) === false) {
        break;
      }
    }

    return index;
  };

  List.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }

      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
  };

  return List;
}(IndexedCollection);

List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn$1;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update$1;
ListPrototype.updateIn = updateIn$1;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;

ListPrototype['@@transducer/step'] = function (result, arr) {
  return result.push(arr);
};

ListPrototype['@@transducer/result'] = function (obj) {
  return obj.asImmutable();
};

var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
}; // TODO: seems like these methods are very similar


VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
  if (index === level ? 1 << level : this.array.length === 0) {
    return this;
  }

  var originIndex = index >>> level & MASK;

  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }

  var removingFirst = originIndex === 0;
  var newChild;

  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);

    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }

  if (removingFirst && !newChild) {
    return this;
  }

  var editable = editableVNode(this, ownerID);

  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = undefined;
    }
  }

  if (newChild) {
    editable.array[originIndex] = newChild;
  }

  return editable;
};

VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }

  var sizeIndex = index - 1 >>> level & MASK;

  if (sizeIndex >= this.array.length) {
    return this;
  }

  var newChild;

  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);

    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }

  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);

  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }

  return editable;
};

var DONE = {};

function iterateList(list, reverse) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);

  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }

  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;

    if (to > SIZE) {
      to = SIZE;
    }

    return function () {
      if (from === to) {
        return DONE;
      }

      var idx = reverse ? --to : from++;
      return array && array[idx];
    };
  }

  function iterateNode(node, level, offset) {
    var values;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;

    if (to > SIZE) {
      to = SIZE;
    }

    return function () {
      while (true) {
        if (values) {
          var value = values();

          if (value !== DONE) {
            return value;
          }

          values = null;
        }

        if (from === to) {
          return DONE;
        }

        var idx = reverse ? --to : from++;
        values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
      }
    };
  }
}

function makeList(origin, capacity, level, root, tail, ownerID, hash) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash;
  list.__altered = false;
  return list;
}

var EMPTY_LIST;

function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}

function updateList(list, index, value) {
  index = wrapIndex(list, index);

  if (index !== index) {
    return list;
  }

  if (index >= list.size || index < 0) {
    return list.withMutations(function (list) {
      index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
    });
  }

  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();

  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
  }

  if (!didAlter.value) {
    return list;
  }

  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }

  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}

function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;

  if (!nodeHas && value === undefined) {
    return node;
  }

  var newNode;

  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);

    if (newLowerNode === lowerNode) {
      return node;
    }

    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }

  if (nodeHas && node.array[idx] === value) {
    return node;
  }

  if (didAlter) {
    SetRef(didAlter);
  }

  newNode = editableVNode(node, ownerID);

  if (value === undefined && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }

  return newNode;
}

function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }

  return new VNode(node ? node.array.slice() : [], ownerID);
}

function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }

  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;

    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }

    return node;
  }
}

function setListBounds(list, begin, end) {
  // Sanitize begin & end using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  if (begin !== undefined) {
    begin |= 0;
  }

  if (end !== undefined) {
    end |= 0;
  }

  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;

  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  } // If it's going to end after it starts, it's empty.


  if (newOrigin >= newCapacity) {
    return list.clear();
  }

  var newLevel = list._level;
  var newRoot = list._root; // New origin might need creating a higher root.

  var offsetShift = 0;

  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }

  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }

  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity); // New size might need creating a higher root.

  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
    newLevel += SHIFT;
  } // Locate or create the new tail.


  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail; // Merge Tail into tree.

  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;

    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }

    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  } // If the size has been reduced, there's a chance the tail needs to be trimmed.


  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  } // If the new origin is within the tail, then we do not need a root.


  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin); // Otherwise, if the root has been trimmed, garbage collect.
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0; // Identify the new top root node of the subtree of the old root.

    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;

      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }

      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }

      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    } // Trim the new sides of the new root.


    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }

    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
    }

    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }

  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }

  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}

function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}

var OrderedMap =
/*@__PURE__*/
function (Map$$1) {
  function OrderedMap(value) {
    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  if (Map$$1) OrderedMap.__proto__ = Map$$1;
  OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);
  OrderedMap.prototype.constructor = OrderedMap;

  OrderedMap.of = function of()
  /*...values*/
  {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function toString() {
    return this.__toString('OrderedMap {', '}');
  }; // @pragma Access


  OrderedMap.prototype.get = function get(k, notSetValue) {
    var index = this._map.get(k);

    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  }; // @pragma Modification


  OrderedMap.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;

      this._map.clear();

      this._list.clear();

      return this;
    }

    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function set(k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function remove(k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function wasAltered() {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    return this._list.__iterate(function (entry) {
      return entry && fn(entry[1], entry[0], this$1);
    }, reverse);
  };

  OrderedMap.prototype.__iterator = function __iterator(type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    var newList = this._list.__ensureOwner(ownerID);

    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }

      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }

    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  return OrderedMap;
}(Map);

OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

function makeOrderedMap(map, list, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map ? map.size : 0;
  omap._map = map;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}

var EMPTY_ORDERED_MAP;

function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}

function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var list = omap._list;
  var i = map.get(k);
  var has = i !== undefined;
  var newMap;
  var newList;

  if (v === NOT_SET) {
    // removed
    if (!has) {
      return omap;
    }

    if (list.size >= SIZE && list.size >= map.size * 2) {
      newList = list.filter(function (entry, idx) {
        return entry !== undefined && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function (entry) {
        return entry[0];
      }).flip().toMap();

      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
    }
  } else if (has) {
    if (v === list.get(i)[1]) {
      return omap;
    }

    newMap = map;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }

  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = undefined;
    return omap;
  }

  return makeOrderedMap(newMap, newList);
}

var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';

function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}

var Stack =
/*@__PURE__*/
function (IndexedCollection$$1) {
  function Stack(value) {
    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }

  if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;
  Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);
  Stack.prototype.constructor = Stack;

  Stack.of = function of()
  /*...values*/
  {
    return this(arguments);
  };

  Stack.prototype.toString = function toString() {
    return this.__toString('Stack [', ']');
  }; // @pragma Access


  Stack.prototype.get = function get(index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);

    while (head && index--) {
      head = head.next;
    }

    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function peek() {
    return this._head && this._head.value;
  }; // @pragma Modification


  Stack.prototype.push = function push()
  /*...values*/
  {
    var arguments$1 = arguments;

    if (arguments.length === 0) {
      return this;
    }

    var newSize = this.size + arguments.length;
    var head = this._head;

    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection$$1(iter);

    if (iter.size === 0) {
      return this;
    }

    if (this.size === 0 && isStack(iter)) {
      return iter;
    }

    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;

    iter.__iterate(function (value) {
      newSize++;
      head = {
        value: value,
        next: head
      };
    },
    /* reverse */
    true);

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function pop() {
    return this.slice(1);
  };

  Stack.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyStack();
  };

  Stack.prototype.slice = function slice(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);

    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection$$1.prototype.slice.call(this, begin, end);
    }

    var newSize = this.size - resolvedBegin;
    var head = this._head;

    while (resolvedBegin--) {
      head = head.next;
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  }; // @pragma Mutability


  Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }

      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeStack(this.size, this._head, ownerID, this.__hash);
  }; // @pragma Iteration


  Stack.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return new ArraySeq(this.toArray()).__iterate(function (v, k) {
        return fn(v, k, this$1);
      }, reverse);
    }

    var iterations = 0;
    var node = this._head;

    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }

      node = node.next;
    }

    return iterations;
  };

  Stack.prototype.__iterator = function __iterator(type, reverse) {
    if (reverse) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse);
    }

    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }

      return iteratorDone();
    });
  };

  return Stack;
}(IndexedCollection);

Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;

StackPrototype['@@transducer/step'] = function (result, arr) {
  return result.unshift(arr);
};

StackPrototype['@@transducer/result'] = function (obj) {
  return obj.asImmutable();
};

function makeStack(size, head, ownerID, hash) {
  var map = Object.create(StackPrototype);
  map.size = size;
  map._head = head;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}

var EMPTY_STACK;

function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}

var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';

function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}

function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }

  if (a.size === 0 && b.size === 0) {
    return true;
  }

  var notAssociative = !isAssociative(a);

  if (isOrdered(a)) {
    var entries = a.entries();
    return b.every(function (v, k) {
      var entry = entries.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries.next().done;
  }

  var flipped = false;

  if (a.size === undefined) {
    if (b.size === undefined) {
      if (typeof a.cacheResult === 'function') {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }

  var allEqual = true;

  var bSize = b.__iterate(function (v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });

  return allEqual && a.size === bSize;
}
/**
 * Contributes additional methods to a constructor
 */


function mixin(ctor, methods) {
  var keyCopier = function (key) {
    ctor.prototype[key] = methods[key];
  };

  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}

function toJS(value) {
  if (!value || typeof value !== 'object') {
    return value;
  }

  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }

    value = Seq(value);
  }

  if (isKeyed(value)) {
    var result$1 = {};

    value.__iterate(function (v, k) {
      result$1[k] = toJS(v);
    });

    return result$1;
  }

  var result = [];

  value.__iterate(function (v) {
    result.push(toJS(v));
  });

  return result;
}

var Set =
/*@__PURE__*/
function (SetCollection$$1) {
  function Set(value) {
    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
      var iter = SetCollection$$1(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  if (SetCollection$$1) Set.__proto__ = SetCollection$$1;
  Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);
  Set.prototype.constructor = Set;

  Set.of = function of()
  /*...values*/
  {
    return this(arguments);
  };

  Set.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };

  Set.intersect = function intersect(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();
  };

  Set.union = function union(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();
  };

  Set.prototype.toString = function toString() {
    return this.__toString('Set {', '}');
  }; // @pragma Access


  Set.prototype.has = function has(value) {
    return this._map.has(value);
  }; // @pragma Modification


  Set.prototype.add = function add(value) {
    return updateSet(this, this._map.set(value, value));
  };

  Set.prototype.remove = function remove(value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function clear() {
    return updateSet(this, this._map.clear());
  }; // @pragma Composition


  Set.prototype.map = function map(mapper, context) {
    var this$1 = this;
    var removes = [];
    var adds = [];
    this.forEach(function (value) {
      var mapped = mapper.call(context, value, value, this$1);

      if (mapped !== value) {
        removes.push(value);
        adds.push(mapped);
      }
    });
    return this.withMutations(function (set) {
      removes.forEach(function (value) {
        return set.remove(value);
      });
      adds.forEach(function (value) {
        return set.add(value);
      });
    });
  };

  Set.prototype.union = function union() {
    var iters = [],
        len = arguments.length;

    while (len--) iters[len] = arguments[len];

    iters = iters.filter(function (x) {
      return x.size !== 0;
    });

    if (iters.length === 0) {
      return this;
    }

    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }

    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection$$1(iters[ii]).forEach(function (value) {
          return set.add(value);
        });
      }
    });
  };

  Set.prototype.intersect = function intersect() {
    var iters = [],
        len = arguments.length;

    while (len--) iters[len] = arguments[len];

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetCollection$$1(iter);
    });
    var toRemove = [];
    this.forEach(function (value) {
      if (!iters.every(function (iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.subtract = function subtract() {
    var iters = [],
        len = arguments.length;

    while (len--) iters[len] = arguments[len];

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetCollection$$1(iter);
    });
    var toRemove = [];
    this.forEach(function (value) {
      if (iters.some(function (iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.sort = function sort(comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function sortBy(mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function wasAltered() {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function __iterate(fn, reverse) {
    var this$1 = this;
    return this._map.__iterate(function (k) {
      return fn(k, k, this$1);
    }, reverse);
  };

  Set.prototype.__iterator = function __iterator(type, reverse) {
    return this._map.__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }

      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }

    return this.__make(newMap, ownerID);
  };

  return Set;
}(SetCollection);

Set.isSet = isSet;
var SetPrototype = Set.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;

SetPrototype['@@transducer/step'] = function (result, arr) {
  return result.add(arr);
};

SetPrototype['@@transducer/result'] = function (obj) {
  return obj.asImmutable();
};

SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;

function updateSet(set, newMap) {
  if (set.__ownerID) {
    set.size = newMap.size;
    set._map = newMap;
    return set;
  }

  return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
}

function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_SET;

function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
/**
 * Returns a lazy seq of nums from start (inclusive) to end
 * (exclusive), by step, where start defaults to 0, step to 1, and end to
 * infinity. When start is equal to end, returns empty list.
 */


var Range =
/*@__PURE__*/
function (IndexedSeq$$1) {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }

    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;

    if (end === undefined) {
      end = Infinity;
    }

    step = step === undefined ? 1 : Math.abs(step);

    if (end < start) {
      step = -step;
    }

    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);

    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }

      EMPTY_RANGE = this;
    }
  }

  if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;
  Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
  Range.prototype.constructor = Range;

  Range.prototype.toString = function toString() {
    if (this.size === 0) {
      return 'Range []';
    }

    return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
  };

  Range.prototype.get = function get(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };

  Range.prototype.includes = function includes(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };

  Range.prototype.slice = function slice(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);

    if (end <= begin) {
      return new Range(0, 0);
    }

    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  };

  Range.prototype.indexOf = function indexOf(searchValue) {
    var offsetValue = searchValue - this._start;

    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;

      if (index >= 0 && index < this.size) {
        return index;
      }
    }

    return -1;
  };

  Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function __iterate(fn, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;

    while (i !== size) {
      if (fn(value, reverse ? size - ++i : i++, this) === false) {
        break;
      }

      value += reverse ? -step : step;
    }

    return i;
  };

  Range.prototype.__iterator = function __iterator(type, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }

      var v = value;
      value += reverse ? -step : step;
      return iteratorValue(type, reverse ? size - ++i : i++, v);
    });
  };

  Range.prototype.equals = function equals(other) {
    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };

  return Range;
}(IndexedSeq);

var EMPTY_RANGE;

function getIn(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;

  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);

    if (collection === NOT_SET) {
      return notSetValue;
    }
  }

  return collection;
}

function getIn$1(searchKeyPath, notSetValue) {
  return getIn(this, searchKeyPath, notSetValue);
}

function hasIn(collection, keyPath) {
  return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
}

function hasIn$1(searchKeyPath) {
  return hasIn(this, searchKeyPath);
}

function toObject() {
  assertNotInfinite(this.size);
  var object = {};

  this.__iterate(function (v, k) {
    object[k] = v;
  });

  return object;
} // Note: all of these methods are deprecated.


Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  // ### Conversion to other types
  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i = 0;

    this.__iterate(function (v, k) {
      // Keyed collections produce an array of tuples.
      array[i++] = useTuples ? [k, v] : v;
    });

    return array;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    // Use Late Binding here to solve the circular dependency.
    return Map(this.toKeyedSeq());
  },
  toObject: toObject,
  toOrderedMap: function toOrderedMap() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    // Use Late Binding here to solve the circular dependency.
    return Set(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    // Use Late Binding here to solve the circular dependency.
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    // Use Late Binding here to solve the circular dependency.
    return List(isKeyed(this) ? this.valueSeq() : this);
  },
  // ### Common JavaScript methods and properties
  toString: function toString() {
    return '[Collection]';
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }

    return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  concat: function concat() {
    var values = [],
        len = arguments.length;

    while (len--) values[len] = arguments[len];

    return reify(this, concatFactory(this, values));
  },
  includes: function includes(searchValue) {
    return this.some(function (value) {
      return is(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;

    this.__iterate(function (v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });

    return returnValue;
  },
  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },
  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },
  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;

    this.__iterate(function (v) {
      isFirst ? isFirst = false : joined += separator;
      joined += v !== null && v !== undefined ? v.toString() : '';
    });

    return joined;
  },
  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },
  reduce: function reduce$1(reducer, initialReduction, context) {
    return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);
  },
  reduceRight: function reduceRight(reducer, initialReduction, context) {
    return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },
  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  // ### More sequential methods
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty() {
    return this.size !== undefined ? this.size === 0 : !this.some(function () {
      return true;
    });
  },
  count: function count(predicate, context) {
    return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
  },
  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },
  equals: function equals(other) {
    return deepEqual(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;

    if (collection._cache) {
      // We cache as an entries array, so we can just return the cache!
      return new ArraySeq(collection._cache);
    }

    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();

    entriesSequence.fromEntrySeq = function () {
      return collection.toSeq();
    };

    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },
  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;

    this.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });

    return found;
  },
  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },
  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get(searchKey, notSetValue) {
    return this.find(function (_, key) {
      return is(key, searchKey);
    }, undefined, notSetValue);
  },
  getIn: getIn$1,
  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },
  has: function has(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn: hasIn$1,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === 'function' ? iter : Collection(iter);
    return this.every(function (value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function (value) {
      return is(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min(comparator) {
    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },
  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },
  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },
  update: function update(fn) {
    return fn(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  // ### Hashable Object
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  } // ### Internal
  // abstract __iterate(fn, reverse)
  // abstract __iterator(type, reverse)

});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;

CollectionPrototype.inspect = CollectionPrototype.toSource = function () {
  return this.toString();
};

CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  // ### More sequential methods
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context) {
    var this$1 = this;
    var iterations = 0;
    return reify(this, this.toSeq().map(function (v, k) {
      return mapper.call(context, [k, v], iterations++, this$1);
    }).fromEntrySeq());
  },
  mapKeys: function mapKeys(mapper, context) {
    var this$1 = this;
    return reify(this, this.toSeq().flip().map(function (k, v) {
      return mapper.call(context, k, v, this$1);
    }).flip());
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;

KeyedCollectionPrototype.__toStringMapper = function (v, k) {
  return quoteString(k) + ': ' + quoteString(v);
};

mixin(IndexedCollection, {
  // ### Conversion to other types
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, false);
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },
  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === undefined ? -1 : key;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === undefined ? -1 : key;
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice(index, removeNum
  /*, ...values*/
  ) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);

    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    } // If index is negative, it should resolve relative to the size of the
    // collection. However size may be expensive to compute if not cached, so
    // only call count() if the number is in fact negative.


    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
  },
  // ### More collection methods
  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  first: function first(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
      return key === index;
    }, undefined, notSetValue);
  },
  has: function has(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave()
  /*...collections*/
  {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);

    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }

    return reify(this, interleaved);
  },
  keySeq: function keySeq() {
    return Range(0, this.size);
  },
  last: function last(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },
  zip: function zip()
  /*, ...collections */
  {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll()
  /*, ...collections */
  {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper
  /*, ...collections */
  ) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)
  get: function get(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes(value) {
    return this.has(value);
  },
  // ### More sequential methods
  keySeq: function keySeq() {
    return this.valueSeq();
  }
});
SetCollection.prototype.has = CollectionPrototype.includes;
SetCollection.prototype.contains = SetCollection.prototype.includes; // Mixin subclasses

mixin(KeyedSeq, KeyedCollection.prototype);
mixin(IndexedSeq, IndexedCollection.prototype);
mixin(SetSeq, SetCollection.prototype); // #pragma Helper functions

function reduce(collection, reducer, reduction, context, useFirst, reverse) {
  assertNotInfinite(collection.size);

  collection.__iterate(function (v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse);

  return reduction;
}

function keyMapper(v, k) {
  return k;
}

function entryMapper(v, k) {
  return [k, v];
}

function not(predicate) {
  return function () {
    return !predicate.apply(this, arguments);
  };
}

function neg(predicate) {
  return function () {
    return -predicate.apply(this, arguments);
  };
}

function defaultZipper() {
  return arrCopy(arguments);
}

function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }

  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;

  var size = collection.__iterate(keyed ? ordered ? function (v, k) {
    h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
  } : function (v, k) {
    h = h + hashMerge(hash(v), hash(k)) | 0;
  } : ordered ? function (v) {
    h = 31 * h + hash(v) | 0;
  } : function (v) {
    h = h + hash(v) | 0;
  });

  return murmurHashOfSize(size, h);
}

function murmurHashOfSize(size, h) {
  h = imul(h, 0xcc9e2d51);
  h = imul(h << 15 | h >>> -15, 0x1b873593);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 0xe6546b64 | 0) ^ size;
  h = imul(h ^ h >>> 16, 0x85ebca6b);
  h = imul(h ^ h >>> 13, 0xc2b2ae35);
  h = smi(h ^ h >>> 16);
  return h;
}

function hashMerge(a, b) {
  return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int
}

var OrderedSet =
/*@__PURE__*/
function (Set$$1) {
  function OrderedSet(value) {
    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  if (Set$$1) OrderedSet.__proto__ = Set$$1;
  OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);
  OrderedSet.prototype.constructor = OrderedSet;

  OrderedSet.of = function of()
  /*...values*/
  {
    return this(arguments);
  };

  OrderedSet.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };

  OrderedSet.prototype.toString = function toString() {
    return this.__toString('OrderedSet {', '}');
  };

  return OrderedSet;
}(Set);

OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;

function makeOrderedSet(map, ownerID) {
  var set = Object.create(OrderedSetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_ORDERED_SET;

function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}

var Record = function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    var this$1 = this;

    if (values instanceof RecordType) {
      return values;
    }

    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }

    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      var indices = RecordTypePrototype._indices = {}; // Deprecated: left to attempt not to break any external code which
      // relies on a ._name property existing on record instances.
      // Use Record.getDescriptiveName() instead

      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;

      for (var i = 0; i < keys.length; i++) {
        var propName = keys[i];
        indices[propName] = i;

        if (RecordTypePrototype[propName]) {
          /* eslint-disable no-console */
          typeof console === 'object' && console.warn && console.warn('Cannot define ' + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.');
          /* eslint-enable no-console */
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }

    this.__ownerID = undefined;
    this._values = List().withMutations(function (l) {
      l.setSize(this$1._keys.length);
      KeyedCollection(values).forEach(function (v, k) {
        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
      });
    });
  };

  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;

  if (name) {
    RecordType.displayName = name;
  }

  return RecordType;
};

Record.prototype.toString = function toString() {
  var str = recordName(this) + ' { ';
  var keys = this._keys;
  var k;

  for (var i = 0, l = keys.length; i !== l; i++) {
    k = keys[i];
    str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
  }

  return str + ' }';
};

Record.prototype.equals = function equals(other) {
  return this === other || other && this._keys === other._keys && recordSeq(this).equals(recordSeq(other));
};

Record.prototype.hashCode = function hashCode() {
  return recordSeq(this).hashCode();
}; // @pragma Access


Record.prototype.has = function has(k) {
  return this._indices.hasOwnProperty(k);
};

Record.prototype.get = function get(k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }

  var index = this._indices[k];

  var value = this._values.get(index);

  return value === undefined ? this._defaultValues[k] : value;
}; // @pragma Modification


Record.prototype.set = function set(k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);

    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }

  return this;
};

Record.prototype.remove = function remove(k) {
  return this.set(k);
};

Record.prototype.clear = function clear() {
  var newValues = this._values.clear().setSize(this._keys.length);

  return this.__ownerID ? this : makeRecord(this, newValues);
};

Record.prototype.wasAltered = function wasAltered() {
  return this._values.wasAltered();
};

Record.prototype.toSeq = function toSeq() {
  return recordSeq(this);
};

Record.prototype.toJS = function toJS$1() {
  return toJS(this);
};

Record.prototype.entries = function entries() {
  return this.__iterator(ITERATE_ENTRIES);
};

Record.prototype.__iterator = function __iterator(type, reverse) {
  return recordSeq(this).__iterator(type, reverse);
};

Record.prototype.__iterate = function __iterate(fn, reverse) {
  return recordSeq(this).__iterate(fn, reverse);
};

Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }

  var newValues = this._values.__ensureOwner(ownerID);

  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }

  return makeRecord(this, newValues, ownerID);
};

Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn$1;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge;
RecordPrototype.mergeWith = mergeWith;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep$1;
RecordPrototype.mergeDeepWith = mergeDeepWith$1;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn$1;
RecordPrototype.update = update$1;
RecordPrototype.updateIn = updateIn$1;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;

RecordPrototype.inspect = RecordPrototype.toSource = function () {
  return this.toString();
};

function makeRecord(likeRecord, values, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values;
  record.__ownerID = ownerID;
  return record;
}

function recordName(record) {
  return record.constructor.displayName || record.constructor.name || 'Record';
}

function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function (k) {
    return [k, record.get(k)];
  }));
}

function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function () {
        return this.get(name);
      },
      set: function (value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  } catch (error) {// Object.defineProperty failed. Probably IE8.
  }
}
/**
 * Returns a lazy Seq of `value` repeated `times` times. When `times` is
 * undefined, returns an infinite sequence of `value`.
 */


var Repeat =
/*@__PURE__*/
function (IndexedSeq$$1) {
  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }

    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);

    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }

      EMPTY_REPEAT = this;
    }
  }

  if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;
  Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);
  Repeat.prototype.constructor = Repeat;

  Repeat.prototype.toString = function toString() {
    if (this.size === 0) {
      return 'Repeat []';
    }

    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function get(index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function includes(searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function slice(begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
  };

  Repeat.prototype.reverse = function reverse() {
    return this;
  };

  Repeat.prototype.indexOf = function indexOf(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }

    return -1;
  };

  Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }

    return -1;
  };

  Repeat.prototype.__iterate = function __iterate(fn, reverse) {
    var size = this.size;
    var i = 0;

    while (i !== size) {
      if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
        break;
      }
    }

    return i;
  };

  Repeat.prototype.__iterator = function __iterator(type, reverse) {
    var this$1 = this;
    var size = this.size;
    var i = 0;
    return new Iterator(function () {
      return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);
    });
  };

  Repeat.prototype.equals = function equals(other) {
    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
  };

  return Repeat;
}(IndexedSeq);

var EMPTY_REPEAT;

function fromJS(value, converter) {
  return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, {
    '': value
  });
}

function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;

  if (toSeq) {
    if (~stack.indexOf(value)) {
      throw new TypeError('Cannot convert circular structure to Immutable');
    }

    stack.push(value);
    keyPath && key !== '' && keyPath.push(key);
    var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {
      return fromJSWith(stack, converter, v, k, keyPath, value);
    }), keyPath && keyPath.slice());
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }

  return value;
}

function defaultConverter(k, v) {
  return isKeyed(v) ? v.toMap() : v.toList();
}

var version = "4.0.0-rc.11";
var Immutable = {
  version: version,
  Collection: Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,
  Seq: Seq,
  Map: Map,
  OrderedMap: OrderedMap,
  List: List,
  Stack: Stack,
  Set: Set,
  OrderedSet: OrderedSet,
  Record: Record,
  Range: Range,
  Repeat: Repeat,
  is: is,
  fromJS: fromJS,
  hash: hash,
  isImmutable: isImmutable,
  isCollection: isCollection,
  isKeyed: isKeyed,
  isIndexed: isIndexed,
  isAssociative: isAssociative,
  isOrdered: isOrdered,
  isValueObject: isValueObject,
  isSeq: isSeq,
  isList: isList,
  isMap: isMap,
  isOrderedMap: isOrderedMap,
  isStack: isStack,
  isSet: isSet,
  isOrderedSet: isOrderedSet,
  isRecord: isRecord,
  get: get,
  getIn: getIn,
  has: has,
  hasIn: hasIn,
  merge: merge$1,
  mergeDeep: mergeDeep,
  mergeWith: mergeWith$1,
  mergeDeepWith: mergeDeepWith,
  remove: remove,
  removeIn: removeIn,
  set: set,
  setIn: setIn,
  update: update,
  updateIn: updateIn
}; // Note: Iterable is deprecated

var Iterable = Collection;
const _default = Immutable;
/* harmony default export */ __webpack_exports__["default"] = (_default);

;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(DELETE, "DELETE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SHIFT, "SHIFT", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SIZE, "SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MASK, "MASK", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(NOT_SET, "NOT_SET", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MakeRef, "MakeRef", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SetRef, "SetRef", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(OwnerID, "OwnerID", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ensureSize, "ensureSize", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(wrapIndex, "wrapIndex", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(returnTrue, "returnTrue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(wholeSlice, "wholeSlice", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(resolveBegin, "resolveBegin", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(resolveEnd, "resolveEnd", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(resolveIndex, "resolveIndex", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isNeg, "isNeg", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_COLLECTION_SYMBOL, "IS_COLLECTION_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isCollection, "isCollection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_KEYED_SYMBOL, "IS_KEYED_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isKeyed, "isKeyed", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_INDEXED_SYMBOL, "IS_INDEXED_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isIndexed, "isIndexed", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isAssociative, "isAssociative", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Collection, "Collection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(KeyedCollection, "KeyedCollection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IndexedCollection, "IndexedCollection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SetCollection, "SetCollection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_SEQ_SYMBOL, "IS_SEQ_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isSeq, "isSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_RECORD_SYMBOL, "IS_RECORD_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isRecord, "isRecord", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isImmutable, "isImmutable", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_ORDERED_SYMBOL, "IS_ORDERED_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isOrdered, "isOrdered", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ITERATE_KEYS, "ITERATE_KEYS", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ITERATE_VALUES, "ITERATE_VALUES", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ITERATE_ENTRIES, "ITERATE_ENTRIES", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(REAL_ITERATOR_SYMBOL, "REAL_ITERATOR_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(FAUX_ITERATOR_SYMBOL, "FAUX_ITERATOR_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ITERATOR_SYMBOL, "ITERATOR_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Iterator, "Iterator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(iteratorValue, "iteratorValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(iteratorDone, "iteratorDone", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hasIterator, "hasIterator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isIterator, "isIterator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getIterator, "getIterator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getIteratorFn, "getIteratorFn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hasOwnProperty, "hasOwnProperty", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isArrayLike, "isArrayLike", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Seq, "Seq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(KeyedSeq, "KeyedSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IndexedSeq, "IndexedSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SetSeq, "SetSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ArraySeq, "ArraySeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ObjectSeq, "ObjectSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(CollectionSeq, "CollectionSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_SEQ, "EMPTY_SEQ", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptySequence, "emptySequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(keyedSeqFromValue, "keyedSeqFromValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(indexedSeqFromValue, "indexedSeqFromValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(seqFromValue, "seqFromValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(maybeIndexedSeqFromValue, "maybeIndexedSeqFromValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_MAP_SYMBOL, "IS_MAP_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isMap, "isMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isOrderedMap, "isOrderedMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isValueObject, "isValueObject", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(is, "is", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(imul, "imul", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(smi, "smi", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(defaultValueOf, "defaultValueOf", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hash, "hash", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hashNumber, "hashNumber", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(cachedHashString, "cachedHashString", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hashString, "hashString", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hashJSObj, "hashJSObj", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isExtensible, "isExtensible", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(canDefineProperty, "canDefineProperty", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getIENodeHash, "getIENodeHash", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(usingWeakMap, "usingWeakMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(weakMap, "weakMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(objHashUID, "objHashUID", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(UID_HASH_KEY, "UID_HASH_KEY", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(STRING_HASH_CACHE_MIN_STRLEN, "STRING_HASH_CACHE_MIN_STRLEN", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(STRING_HASH_CACHE_MAX_SIZE, "STRING_HASH_CACHE_MAX_SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(STRING_HASH_CACHE_SIZE, "STRING_HASH_CACHE_SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(stringHashCache, "stringHashCache", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ToKeyedSequence, "ToKeyedSequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ToIndexedSequence, "ToIndexedSequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ToSetSequence, "ToSetSequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(FromEntriesSequence, "FromEntriesSequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(flipFactory, "flipFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mapFactory, "mapFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(reverseFactory, "reverseFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(filterFactory, "filterFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(countByFactory, "countByFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(groupByFactory, "groupByFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(sliceFactory, "sliceFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(takeWhileFactory, "takeWhileFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(skipWhileFactory, "skipWhileFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(concatFactory, "concatFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(flattenFactory, "flattenFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(flatMapFactory, "flatMapFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(interposeFactory, "interposeFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(sortFactory, "sortFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(maxFactory, "maxFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(maxCompare, "maxCompare", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(zipWithFactory, "zipWithFactory", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(reify, "reify", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(validateEntry, "validateEntry", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(collectionClass, "collectionClass", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeSequence, "makeSequence", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(cacheResultThrough, "cacheResultThrough", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(defaultComparator, "defaultComparator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(arrCopy, "arrCopy", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(invariant, "invariant", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(assertNotInfinite, "assertNotInfinite", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(coerceKeyPath, "coerceKeyPath", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isPlainObj, "isPlainObj", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isDataStructure, "isDataStructure", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(quoteString, "quoteString", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(has, "has", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(get, "get", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(shallowCopy, "shallowCopy", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(remove, "remove", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(set, "set", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateIn, "updateIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateInDeeply, "updateInDeeply", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(setIn, "setIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(setIn$1, "setIn$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(removeIn, "removeIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(deleteIn, "deleteIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(update, "update", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(update$1, "update$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateIn$1, "updateIn$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(merge, "merge", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeWith, "mergeWith", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeIntoKeyedWith, "mergeIntoKeyedWith", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(merge$1, "merge$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeWith$1, "mergeWith$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeep, "mergeDeep", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeepWith, "mergeDeepWith", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeepWithSources, "mergeDeepWithSources", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeWithSources, "mergeWithSources", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(deepMergerWith, "deepMergerWith", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeep$1, "mergeDeep$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeepWith$1, "mergeDeepWith$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeIn, "mergeIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeDeepIn, "mergeDeepIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(withMutations, "withMutations", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(asMutable, "asMutable", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(asImmutable, "asImmutable", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(wasAltered, "wasAltered", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Map, "Map", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MapPrototype, "MapPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ArrayMapNode, "ArrayMapNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(BitmapIndexedNode, "BitmapIndexedNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(HashArrayMapNode, "HashArrayMapNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(HashCollisionNode, "HashCollisionNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ValueNode, "ValueNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MapIterator, "MapIterator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mapIteratorValue, "mapIteratorValue", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mapIteratorFrame, "mapIteratorFrame", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeMap, "makeMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_MAP, "EMPTY_MAP", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptyMap, "emptyMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateMap, "updateMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateNode, "updateNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isLeafNode, "isLeafNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mergeIntoNode, "mergeIntoNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(createNodes, "createNodes", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(packNodes, "packNodes", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(expandNodes, "expandNodes", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(popCount, "popCount", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(setAt, "setAt", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(spliceIn, "spliceIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(spliceOut, "spliceOut", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MAX_ARRAY_MAP_SIZE, "MAX_ARRAY_MAP_SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MAX_BITMAP_INDEXED_SIZE, "MAX_BITMAP_INDEXED_SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(MIN_HASH_ARRAY_MAP_SIZE, "MIN_HASH_ARRAY_MAP_SIZE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_LIST_SYMBOL, "IS_LIST_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isList, "isList", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(List, "List", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(ListPrototype, "ListPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(VNode, "VNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(DONE, "DONE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(iterateList, "iterateList", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeList, "makeList", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_LIST, "EMPTY_LIST", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptyList, "emptyList", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateList, "updateList", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateVNode, "updateVNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(editableVNode, "editableVNode", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(listNodeFor, "listNodeFor", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(setListBounds, "setListBounds", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getTailOffset, "getTailOffset", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(OrderedMap, "OrderedMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeOrderedMap, "makeOrderedMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_ORDERED_MAP, "EMPTY_ORDERED_MAP", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptyOrderedMap, "emptyOrderedMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateOrderedMap, "updateOrderedMap", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_STACK_SYMBOL, "IS_STACK_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isStack, "isStack", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Stack, "Stack", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(StackPrototype, "StackPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeStack, "makeStack", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_STACK, "EMPTY_STACK", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptyStack, "emptyStack", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IS_SET_SYMBOL, "IS_SET_SYMBOL", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isSet, "isSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(isOrderedSet, "isOrderedSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(deepEqual, "deepEqual", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(mixin, "mixin", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(toJS, "toJS", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Set, "Set", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(SetPrototype, "SetPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(updateSet, "updateSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeSet, "makeSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_SET, "EMPTY_SET", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptySet, "emptySet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Range, "Range", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_RANGE, "EMPTY_RANGE", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getIn, "getIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(getIn$1, "getIn$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hasIn, "hasIn", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hasIn$1, "hasIn$1", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(toObject, "toObject", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(CollectionPrototype, "CollectionPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(KeyedCollectionPrototype, "KeyedCollectionPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(IndexedCollectionPrototype, "IndexedCollectionPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(reduce, "reduce", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(keyMapper, "keyMapper", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(entryMapper, "entryMapper", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(not, "not", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(neg, "neg", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(defaultZipper, "defaultZipper", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(defaultNegComparator, "defaultNegComparator", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hashCollection, "hashCollection", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(murmurHashOfSize, "murmurHashOfSize", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(hashMerge, "hashMerge", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(OrderedSet, "OrderedSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(OrderedSetPrototype, "OrderedSetPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeOrderedSet, "makeOrderedSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_ORDERED_SET, "EMPTY_ORDERED_SET", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(emptyOrderedSet, "emptyOrderedSet", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Record, "Record", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(RecordPrototype, "RecordPrototype", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(makeRecord, "makeRecord", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(recordName, "recordName", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(recordSeq, "recordSeq", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(setProp, "setProp", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Repeat, "Repeat", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(EMPTY_REPEAT, "EMPTY_REPEAT", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(fromJS, "fromJS", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(fromJSWith, "fromJSWith", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(defaultConverter, "defaultConverter", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(version, "version", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Immutable, "Immutable", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(Iterable, "Iterable", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  reactHotLoader.register(_default, "default", "/Users/iain/Projects/react-ssr/node_modules/immutable/dist/immutable.es.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/redux-immutable/dist/combineReducers.js":
/*!**************************************************************!*\
  !*** ./node_modules/redux-immutable/dist/combineReducers.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.es.js");

var _immutable2 = _interopRequireDefault(_immutable);

var _utilities = __webpack_require__(/*! ./utilities */ "./node_modules/redux-immutable/dist/utilities/index.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = function (reducers) {
  var getDefaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _immutable2.default.Map;
  var reducerKeys = Object.keys(reducers); // eslint-disable-next-line space-infix-ops

  return function () {
    var inputState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDefaultState();
    var action = arguments[1]; // eslint-disable-next-line no-process-env

    if (true) {
      var warningMessage = (0, _utilities.getUnexpectedInvocationParameterMessage)(inputState, reducers, action);

      if (warningMessage) {
        // eslint-disable-next-line no-console
        console.error(warningMessage);
      }
    }

    return inputState.withMutations(function (temporaryState) {
      reducerKeys.forEach(function (reducerName) {
        var reducer = reducers[reducerName];
        var currentDomainState = temporaryState.get(reducerName);
        var nextDomainState = reducer(currentDomainState, action);
        (0, _utilities.validateNextState)(nextDomainState, reducerName, action);
        temporaryState.set(reducerName, nextDomainState);
      });
    });
  };
};

module.exports = exports['default'];
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_immutable2, "_immutable2", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/combineReducers.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/combineReducers.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/redux-immutable/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/redux-immutable/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineReducers = undefined;

var _combineReducers2 = __webpack_require__(/*! ./combineReducers */ "./node_modules/redux-immutable/dist/combineReducers.js");

var _combineReducers3 = _interopRequireDefault(_combineReducers2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.combineReducers = _combineReducers3.default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_combineReducers3, "_combineReducers3", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/index.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/index.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/redux-immutable/dist/utilities/getStateName.js":
/*!*********************************************************************!*\
  !*** ./node_modules/redux-immutable/dist/utilities/getStateName.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (action) {
  return action && action.type === '@@redux/INIT' ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
};

module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.es.js");

var _immutable2 = _interopRequireDefault(_immutable);

var _getStateName = __webpack_require__(/*! ./getStateName */ "./node_modules/redux-immutable/dist/utilities/getStateName.js");

var _getStateName2 = _interopRequireDefault(_getStateName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.default = function (state, reducers, action) {
  var reducerNames = Object.keys(reducers);

  if (!reducerNames.length) {
    return 'Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.';
  }

  var stateName = (0, _getStateName2.default)(action);

  if (_immutable2.default.isImmutable ? !_immutable2.default.isImmutable(state) : !_immutable2.default.Iterable.isIterable(state)) {
    return 'The ' + stateName + ' is of unexpected type. Expected argument to be an instance of Immutable.Collection or Immutable.Record with the following properties: "' + reducerNames.join('", "') + '".';
  }

  var unexpectedStatePropertyNames = state.toSeq().keySeq().toArray().filter(function (name) {
    return !reducers.hasOwnProperty(name);
  });

  if (unexpectedStatePropertyNames.length > 0) {
    return 'Unexpected ' + (unexpectedStatePropertyNames.length === 1 ? 'property' : 'properties') + ' "' + unexpectedStatePropertyNames.join('", "') + '" found in ' + stateName + '. Expected to find one of the known reducer property names instead: "' + reducerNames.join('", "') + '". Unexpected properties will be ignored.';
  }

  return null;
};

module.exports = exports['default'];
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_immutable2, "_immutable2", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js");
  reactHotLoader.register(_getStateName2, "_getStateName2", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/redux-immutable/dist/utilities/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/redux-immutable/dist/utilities/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

(function () {
  var enterModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").enterModule;

  enterModule && enterModule(module);
})();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateNextState = exports.getUnexpectedInvocationParameterMessage = exports.getStateName = undefined;

var _getStateName2 = __webpack_require__(/*! ./getStateName */ "./node_modules/redux-immutable/dist/utilities/getStateName.js");

var _getStateName3 = _interopRequireDefault(_getStateName2);

var _getUnexpectedInvocationParameterMessage2 = __webpack_require__(/*! ./getUnexpectedInvocationParameterMessage */ "./node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js");

var _getUnexpectedInvocationParameterMessage3 = _interopRequireDefault(_getUnexpectedInvocationParameterMessage2);

var _validateNextState2 = __webpack_require__(/*! ./validateNextState */ "./node_modules/redux-immutable/dist/utilities/validateNextState.js");

var _validateNextState3 = _interopRequireDefault(_validateNextState2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

exports.getStateName = _getStateName3.default;
exports.getUnexpectedInvocationParameterMessage = _getUnexpectedInvocationParameterMessage3.default;
exports.validateNextState = _validateNextState3.default;
;

(function () {
  var reactHotLoader = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").default;

  var leaveModule = __webpack_require__(/*! react-hot-loader */ "./node_modules/react-hot-loader/index.js").leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(_getStateName3, "_getStateName3", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/index.js");
  reactHotLoader.register(_getUnexpectedInvocationParameterMessage3, "_getUnexpectedInvocationParameterMessage3", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/index.js");
  reactHotLoader.register(_validateNextState3, "_validateNextState3", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/index.js");
  reactHotLoader.register(_interopRequireDefault, "_interopRequireDefault", "/Users/iain/Projects/react-ssr/node_modules/redux-immutable/dist/utilities/index.js");
  leaveModule(module);
})();

;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/redux-immutable/dist/utilities/validateNextState.js":
/*!**************************************************************************!*\
  !*** ./node_modules/redux-immutable/dist/utilities/validateNextState.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (nextState, reducerName, action) {
  // eslint-disable-next-line no-undefined
  if (nextState === undefined) {
    throw new Error('Reducer "' + reducerName + '" returned undefined when handling "' + action.type + '" action. To ignore an action, you must explicitly return the previous state.');
  }
};

module.exports = exports['default'];

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29ubmVjdGVkLXJlYWN0LXJvdXRlci9pbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nvbm5lY3RlZC1yZWFjdC1yb3V0ZXIvbGliL2ltbXV0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29ubmVjdGVkLXJlYWN0LXJvdXRlci9saWIvc3RydWN0dXJlL2ltbXV0YWJsZS9nZXRJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29ubmVjdGVkLXJlYWN0LXJvdXRlci9saWIvc3RydWN0dXJlL2ltbXV0YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29ubmVjdGVkLXJlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxpdGllcy9nZXRTdGF0ZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlsaXRpZXMvZ2V0VW5leHBlY3RlZEludm9jYXRpb25QYXJhbWV0ZXJNZXNzYWdlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbGl0aWVzL3ZhbGlkYXRlTmV4dFN0YXRlLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsInJlcXVpcmUiLCJPYmplY3QiLCJ2YWx1ZSIsImV4cG9ydHMiLCJfdHlwZW9mIiwiU3ltYm9sIiwib2JqIiwiX2NyZWF0ZUFsbCIsIl9jcmVhdGVBbGwyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pbW11dGFibGUiLCJfaW1tdXRhYmxlMiIsImRlZmF1bHQiLCJfZ2V0X18yIiwiX2dldF9fIiwiTE9DQVRJT05fQ0hBTkdFIiwiQ0FMTF9ISVNUT1JZX01FVEhPRCIsInB1c2giLCJyZXBsYWNlIiwiZ28iLCJnb0JhY2siLCJnb0ZvcndhcmQiLCJyb3V0ZXJBY3Rpb25zIiwiQ29ubmVjdGVkUm91dGVyIiwiY29ubmVjdFJvdXRlciIsInJvdXRlck1pZGRsZXdhcmUiLCJnZXRMb2NhdGlvbiIsImdldEFjdGlvbiIsImNyZWF0ZU1hdGNoU2VsZWN0b3IiLCJfUmV3aXJlTW9kdWxlSWRfXyIsImdsb2JhbFZhcmlhYmxlIiwiX2dldEdsb2JhbE9iamVjdCIsIl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18iLCJ0aGVHbG9iYWxWYXJpYWJsZSIsIm1vZHVsZUlkIiwiX2dldFJld2lyZU1vZHVsZUlkX18iLCJyZWdpc3RyeSIsIl9nZXRSZXdpcmVSZWdpc3RyeV9fIiwicmV3aXJlRGF0YSIsIklOVEVOVElPTkFMX1VOREVGSU5FRCIsIl9SZXdpcmVBUElfXyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0IiwiX2dldFJld2lyZWREYXRhX18iLCJfZ2V0X29yaWdpbmFsX18iLCJfc2V0X29yaWdpbmFsX18iLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwib3BlcmF0aW9uIiwiX2Fzc2lnbl9fIiwicHJlZml4IiwidmFyaWFibGVOYW1lIiwiX3Jlc2V0X18iLCJyZXdpcmVkVmFyaWFibGVOYW1lcyIsInByZXZpb3VzVmFsdWVzIiwib2JqZWN0IiwicmVzdWx0IiwiY2FsbGJhY2siLCJyZXNldCIsIl91cGRhdGVfb3BlcmF0aW9uX18iLCJfc2V0X18iLCJfd2l0aF9fIiwiX2dldEluIiwiX2dldEluMiIsImdldEluIiwic3RhdGUiLCJfdHlwZU9mT3JpZ2luYWxFeHBvcnQiLCJhZGROb25FbnVtZXJhYmxlUHJvcGVydHkiLCJzdHJ1Y3R1cmUiLCJmcm9tSlMiLCJtZXJnZSIsInRvSlMiLCJmYWN0b3J5IiwiU0xJQ0UkMCIsIkFycmF5IiwiY3RvciIsInN1cGVyQ2xhc3MiLCJpc0l0ZXJhYmxlIiwiU2VxIiwiY3JlYXRlQ2xhc3MiLCJpc0tleWVkIiwiS2V5ZWRTZXEiLCJpc0luZGV4ZWQiLCJJbmRleGVkU2VxIiwiaXNBc3NvY2lhdGl2ZSIsIlNldFNlcSIsIm1heWJlSXRlcmFibGUiLCJtYXliZUtleWVkIiwibWF5YmVJbmRleGVkIiwibWF5YmVPcmRlcmVkIiwiSXRlcmFibGUiLCJJU19JVEVSQUJMRV9TRU5USU5FTCIsIklTX0tFWUVEX1NFTlRJTkVMIiwiSVNfSU5ERVhFRF9TRU5USU5FTCIsIklTX09SREVSRURfU0VOVElORUwiLCJERUxFVEUiLCJTSElGVCIsIlNJWkUiLCJNQVNLIiwiTk9UX1NFVCIsIkNIQU5HRV9MRU5HVEgiLCJESURfQUxURVIiLCJyZWYiLCJvZmZzZXQiLCJsZW4iLCJNYXRoIiwiYXJyIiwibmV3QXJyIiwiaWkiLCJpdGVyIiwidWludDMySW5kZXgiLCJpbmRleCIsImVuc3VyZVNpemUiLCJiZWdpbiIsInNpemUiLCJlbmQiLCJyZXNvbHZlSW5kZXgiLCJJVEVSQVRFX0tFWVMiLCJJVEVSQVRFX1ZBTFVFUyIsIklURVJBVEVfRU5UUklFUyIsIlJFQUxfSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJJVEVSQVRPUl9TWU1CT0wiLCJJdGVyYXRvciIsInR5cGUiLCJpdGVyYXRvclJlc3VsdCIsImRvbmUiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYXRvciIsIml0ZXJhdG9yRm4iLCJpdGVyYWJsZSIsImVtcHR5U2VxdWVuY2UiLCJzZXFGcm9tVmFsdWUiLCJzZXFJdGVyYXRlIiwic2VxSXRlcmF0b3IiLCJrZXllZFNlcUZyb21WYWx1ZSIsImluZGV4ZWRTZXFGcm9tVmFsdWUiLCJJU19TRVFfU0VOVElORUwiLCJhcnJheSIsIkFycmF5U2VxIiwid3JhcEluZGV4IiwibWF4SW5kZXgiLCJmbiIsInJldmVyc2UiLCJpdGVyYXRvckRvbmUiLCJpdGVyYXRvclZhbHVlIiwia2V5cyIsIk9iamVjdFNlcSIsIm5vdFNldFZhbHVlIiwia2V5IiwiSXRlcmFibGVTZXEiLCJpdGVyYXRvciIsImdldEl0ZXJhdG9yIiwiaXRlcmF0aW9ucyIsImlzSXRlcmF0b3IiLCJzdGVwIiwiSXRlcmF0b3JTZXEiLCJjYWNoZSIsInZhbCIsIm1heWJlU2VxIiwiRU1QVFlfU0VRIiwic2VxIiwiaGFzSXRlcmF0b3IiLCJtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUiLCJpc0FycmF5TGlrZSIsImVudHJ5IiwidXNlS2V5cyIsImNvbnZlcnRlciIsImZyb21KU1dpdGgiLCJqc29uIiwiZnJvbUpTRGVmYXVsdCIsImlzUGxhaW5PYmoiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJhIiwiYiIsImlzT3JkZXJlZCIsIm5vdEFzc29jaWF0aXZlIiwiZW50cmllcyIsImlzIiwiZmxpcHBlZCIsIl8iLCJhbGxFcXVhbCIsImJTaXplIiwidGltZXMiLCJFTVBUWV9SRVBFQVQiLCJSZXBlYXQiLCJ3aG9sZVNsaWNlIiwicmVzb2x2ZUVuZCIsInJlc29sdmVCZWdpbiIsInRoaXMkMCIsIm90aGVyIiwiZGVlcEVxdWFsIiwiaW52YXJpYW50Iiwic3RhcnQiLCJFTVBUWV9SQU5HRSIsIlJhbmdlIiwicG9zc2libGVJbmRleCIsInNlYXJjaFZhbHVlIiwib2Zmc2V0VmFsdWUiLCJ2IiwiVHlwZUVycm9yIiwiQ29sbGVjdGlvbiIsImltdWwiLCJjIiwiZCIsImkzMiIsIm8iLCJoIiwic21pIiwiY2FjaGVkSGFzaFN0cmluZyIsImhhc2hTdHJpbmciLCJoYXNoSlNPYmoiLCJoYXNoIiwic3RyaW5nSGFzaENhY2hlIiwiU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSIsInN0cmluZyIsIndlYWtNYXAiLCJnZXRJRU5vZGVIYXNoIiwib2JqSGFzaFVJRCIsImlzRXh0ZW5zaWJsZSIsImNhbkRlZmluZVByb3BlcnR5Iiwibm9kZSIsInVzaW5nV2Vha01hcCIsIlVJRF9IQVNIX0tFWSIsIlNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4iLCJTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSIsImVtcHR5TWFwIiwiaXNNYXAiLCJLZXllZEl0ZXJhYmxlIiwiYXNzZXJ0Tm90SW5maW5pdGUiLCJtYXAiLCJNYXAiLCJrZXlWYWx1ZXMiLCJpIiwidXBkYXRlTWFwIiwiYXJndW1lbnRzIiwiayIsInVwZGF0ZXIiLCJ1cGRhdGVkVmFsdWUiLCJ1cGRhdGVJbkRlZXBNYXAiLCJmb3JjZUl0ZXJhdG9yIiwibWVyZ2VJbnRvTWFwV2l0aCIsIml0ZXJzIiwibSIsImRlZXBNZXJnZXJXaXRoIiwiT3JkZXJlZE1hcCIsInNvcnRGYWN0b3J5IiwibXV0YWJsZSIsIm93bmVySUQiLCJtYWtlTWFwIiwibWF5YmVNYXAiLCJJU19NQVBfU0VOVElORUwiLCJNYXBQcm90b3R5cGUiLCJBcnJheU1hcE5vZGUiLCJyZW1vdmVkIiwiaWR4IiwiZXhpc3RzIiwiU2V0UmVmIiwiY3JlYXRlTm9kZXMiLCJpc0VkaXRhYmxlIiwibmV3RW50cmllcyIsImFyckNvcHkiLCJCaXRtYXBJbmRleGVkTm9kZSIsImtleUhhc2giLCJiaXQiLCJzaGlmdCIsImJpdG1hcCIsInBvcENvdW50Iiwia2V5SGFzaEZyYWciLCJub2RlcyIsIm5ld05vZGUiLCJ1cGRhdGVOb2RlIiwiZXhwYW5kTm9kZXMiLCJpc0xlYWZOb2RlIiwibmV3Qml0bWFwIiwibmV3Tm9kZXMiLCJzZXRJbiIsInNwbGljZU91dCIsInNwbGljZUluIiwiSGFzaEFycmF5TWFwTm9kZSIsIm5ld0NvdW50IiwicGFja05vZGVzIiwiSGFzaENvbGxpc2lvbk5vZGUiLCJtZXJnZUludG9Ob2RlIiwiVmFsdWVOb2RlIiwia2V5TWF0Y2giLCJtYXBJdGVyYXRvckZyYW1lIiwiTWFwSXRlcmF0b3IiLCJzdGFjayIsIm1hcEl0ZXJhdG9yVmFsdWUiLCJzdWJOb2RlIiwiX19wcmV2IiwicHJldiIsIkVNUFRZX01BUCIsIm5ld1NpemUiLCJuZXdSb290IiwiZGlkQ2hhbmdlU2l6ZSIsIk1ha2VSZWYiLCJkaWRBbHRlciIsImlkeDEiLCJpZHgyIiwicGFja2VkSUkiLCJwYWNrZWROb2RlcyIsImNvdW50IiwiZXhwYW5kZWROb2RlcyIsIml0ZXJhYmxlcyIsIm1lcmdlSW50b0NvbGxlY3Rpb25XaXRoIiwiZXhpc3RpbmciLCJuZXh0VmFsdWUiLCJtZXJnZXIiLCJ4IiwiY29sbGVjdGlvbiIsIm1lcmdlSW50b01hcCIsImlzTm90U2V0Iiwia2V5UGF0aEl0ZXIiLCJleGlzdGluZ1ZhbHVlIiwibmV4dEV4aXN0aW5nIiwibmV4dFVwZGF0ZWQiLCJuZXdBcnJheSIsImNhbkVkaXQiLCJuZXdMZW4iLCJhZnRlciIsIk1BWF9BUlJBWV9NQVBfU0laRSIsIk1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFIiwiTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUiLCJlbXB0eSIsImVtcHR5TGlzdCIsImlzTGlzdCIsIkluZGV4ZWRJdGVyYWJsZSIsIm1ha2VMaXN0IiwibGlzdCIsIkxpc3QiLCJsaXN0Tm9kZUZvciIsInVwZGF0ZUxpc3QiLCJ2YWx1ZXMiLCJvbGRTaXplIiwic2V0TGlzdEJvdW5kcyIsIm1lcmdlSW50b0xpc3RXaXRoIiwiaXRlcmF0ZUxpc3QiLCJtYXliZUxpc3QiLCJJU19MSVNUX1NFTlRJTkVMIiwiTGlzdFByb3RvdHlwZSIsIlZOb2RlIiwib3JpZ2luSW5kZXgiLCJyZW1vdmluZ0ZpcnN0IiwibGV2ZWwiLCJvbGRDaGlsZCIsIm5ld0NoaWxkIiwiZWRpdGFibGUiLCJlZGl0YWJsZVZOb2RlIiwic2l6ZUluZGV4IiwiRE9ORSIsImxlZnQiLCJyaWdodCIsInRhaWxQb3MiLCJnZXRUYWlsT2Zmc2V0IiwidGFpbCIsIml0ZXJhdGVOb2RlT3JMZWFmIiwiaXRlcmF0ZUxlYWYiLCJpdGVyYXRlTm9kZSIsImZyb20iLCJ0byIsImNhcGFjaXR5IiwiRU1QVFlfTElTVCIsIm5ld1RhaWwiLCJ1cGRhdGVWTm9kZSIsIm5vZGVIYXMiLCJsb3dlck5vZGUiLCJuZXdMb3dlck5vZGUiLCJyYXdJbmRleCIsIm93bmVyIiwib2xkT3JpZ2luIiwib2xkQ2FwYWNpdHkiLCJuZXdPcmlnaW4iLCJuZXdDYXBhY2l0eSIsIm5ld0xldmVsIiwib2Zmc2V0U2hpZnQiLCJvbGRUYWlsT2Zmc2V0IiwibmV3VGFpbE9mZnNldCIsIm9sZFRhaWwiLCJiZWdpbkluZGV4IiwibWF4U2l6ZSIsImVtcHR5T3JkZXJlZE1hcCIsImlzT3JkZXJlZE1hcCIsInVwZGF0ZU9yZGVyZWRNYXAiLCJuZXdNYXAiLCJuZXdMaXN0IiwibWFrZU9yZGVyZWRNYXAiLCJvbWFwIiwiRU1QVFlfT1JERVJFRF9NQVAiLCJoYXMiLCJpbmRleGVkIiwiVG9LZXllZFNlcXVlbmNlIiwicmV2ZXJzZWRTZXF1ZW5jZSIsInJldmVyc2VGYWN0b3J5IiwibWFwcGVkU2VxdWVuY2UiLCJtYXBGYWN0b3J5IiwicmVzb2x2ZVNpemUiLCJUb0luZGV4ZWRTZXF1ZW5jZSIsIlRvU2V0U2VxdWVuY2UiLCJGcm9tRW50cmllc1NlcXVlbmNlIiwidmFsaWRhdGVFbnRyeSIsImluZGV4ZWRJdGVyYWJsZSIsImZsaXBTZXF1ZW5jZSIsIm1ha2VTZXF1ZW5jZSIsIm1hcHBlciIsImZsaXBGYWN0b3J5IiwiZmlsdGVyU2VxdWVuY2UiLCJwcmVkaWNhdGUiLCJncm91cHMiLCJncm91cGVyIiwiaXNLZXllZEl0ZXIiLCJjb2VyY2UiLCJpdGVyYWJsZUNsYXNzIiwicmVpZnkiLCJvcmlnaW5hbFNpemUiLCJyZXNvbHZlZEJlZ2luIiwicmVzb2x2ZWRFbmQiLCJzbGljZUZhY3RvcnkiLCJyZXNvbHZlZFNpemUiLCJzbGljZVNpemUiLCJzbGljZVNlcSIsImlzU2VxIiwic2tpcHBlZCIsImlzU2tpcHBpbmciLCJ0YWtlU2VxdWVuY2UiLCJpdGVyYXRpbmciLCJza2lwU2VxdWVuY2UiLCJza2lwcGluZyIsImlzS2V5ZWRJdGVyYWJsZSIsInNpbmdsZXRvbiIsImNvbmNhdFNlcSIsInN1bSIsImZsYXRTZXF1ZW5jZSIsInN0b3BwZWQiLCJjdXJyZW50RGVwdGgiLCJmbGF0RGVlcCIsImludGVycG9zZWRTZXF1ZW5jZSIsImNvbXBhcmF0b3IiLCJtYXhDb21wYXJlIiwiY29tcCIsInppcFNlcXVlbmNlIiwiaXRlcmF0b3JzIiwiaXNEb25lIiwic3RlcHMiLCJzIiwiUmVjb3JkVHlwZSIsImhhc0luaXRpYWxpemVkIiwic2V0UHJvcHMiLCJSZWNvcmRUeXBlUHJvdG90eXBlIiwiUmVjb3JkIiwicmVjb3JkTmFtZSIsImRlZmF1bHRWYWwiLCJtYWtlUmVjb3JkIiwiUmVjb3JkUHJvdG90eXBlIiwicmVjb3JkIiwibmFtZXMiLCJzZXRQcm9wIiwiZ2V0Iiwic2V0IiwiZW1wdHlTZXQiLCJpc1NldCIsIlNldEl0ZXJhYmxlIiwiU2V0IiwidXBkYXRlU2V0Iiwib3JpZ2luYWxTZXQiLCJPcmRlcmVkU2V0IiwibWF5YmVTZXQiLCJJU19TRVRfU0VOVElORUwiLCJTZXRQcm90b3R5cGUiLCJFTVBUWV9TRVQiLCJtYWtlU2V0IiwiZW1wdHlPcmRlcmVkU2V0IiwiaXNPcmRlcmVkU2V0IiwiT3JkZXJlZFNldFByb3RvdHlwZSIsIkVNUFRZX09SREVSRURfU0VUIiwibWFrZU9yZGVyZWRTZXQiLCJlbXB0eVN0YWNrIiwiaXNTdGFjayIsIlN0YWNrIiwiaGVhZCIsIm5leHQiLCJtYWtlU3RhY2siLCJJbmRleGVkQ29sbGVjdGlvbiIsIm1heWJlU3RhY2siLCJJU19TVEFDS19TRU5USU5FTCIsIlN0YWNrUHJvdG90eXBlIiwiRU1QVFlfU1RBQ0siLCJrZXlDb3BpZXIiLCJtZXRob2RzIiwibWl4aW4iLCJ0b0FycmF5IiwidG9JbmRleGVkU2VxIiwidG9KU09OIiwidG9LZXllZFNlcSIsInRvTWFwIiwidG9PYmplY3QiLCJ0b09yZGVyZWRNYXAiLCJ0b09yZGVyZWRTZXQiLCJ0b1NldCIsInRvU2V0U2VxIiwidG9TZXEiLCJ0b1N0YWNrIiwidG9MaXN0IiwidG9TdHJpbmciLCJfX3RvU3RyaW5nIiwiY29uY2F0IiwiY29uY2F0RmFjdG9yeSIsImluY2x1ZGVzIiwiZXZlcnkiLCJyZXR1cm5WYWx1ZSIsImZpbHRlciIsImZpbHRlckZhY3RvcnkiLCJmaW5kIiwiZm9yRWFjaCIsImNvbnRleHQiLCJzaWRlRWZmZWN0Iiwiam9pbiIsInNlcGFyYXRvciIsImpvaW5lZCIsImlzRmlyc3QiLCJyZWR1Y2UiLCJ1c2VGaXJzdCIsInJlZHVjdGlvbiIsInJlZHVjZXIiLCJyZWR1Y2VSaWdodCIsInJldmVyc2VkIiwic2xpY2UiLCJzb21lIiwibm90Iiwic29ydCIsImJ1dExhc3QiLCJpc0VtcHR5IiwiY291bnRCeSIsImNvdW50QnlGYWN0b3J5IiwiZXF1YWxzIiwiZW50cnlTZXEiLCJlbnRyaWVzU2VxdWVuY2UiLCJmaWx0ZXJOb3QiLCJmaW5kRW50cnkiLCJmb3VuZCIsImZpbmRLZXkiLCJmaW5kTGFzdCIsImZpbmRMYXN0RW50cnkiLCJmaW5kTGFzdEtleSIsImZpcnN0IiwiZmxhdE1hcCIsImZsYXRNYXBGYWN0b3J5IiwiZmxhdHRlbiIsImZsYXR0ZW5GYWN0b3J5IiwiZnJvbUVudHJ5U2VxIiwibmVzdGVkIiwiZ3JvdXBCeSIsImdyb3VwQnlGYWN0b3J5IiwiaGFzSW4iLCJpc1N1YnNldCIsImlzU3VwZXJzZXQiLCJrZXlPZiIsImtleVNlcSIsImxhc3QiLCJsYXN0S2V5T2YiLCJtYXgiLCJtYXhGYWN0b3J5IiwibWF4QnkiLCJtaW4iLCJuZWciLCJtaW5CeSIsInJlc3QiLCJza2lwIiwic2tpcExhc3QiLCJza2lwV2hpbGUiLCJza2lwV2hpbGVGYWN0b3J5Iiwic2tpcFVudGlsIiwic29ydEJ5IiwidGFrZSIsInRha2VMYXN0IiwidGFrZVdoaWxlIiwidGFrZVdoaWxlRmFjdG9yeSIsInRha2VVbnRpbCIsInZhbHVlU2VxIiwiaGFzaENvZGUiLCJoYXNoSXRlcmFibGUiLCJJdGVyYWJsZVByb3RvdHlwZSIsImZsaXAiLCJtYXBFbnRyaWVzIiwibWFwS2V5cyIsIktleWVkSXRlcmFibGVQcm90b3R5cGUiLCJKU09OIiwicXVvdGVTdHJpbmciLCJmaW5kSW5kZXgiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJzcGxpY2UiLCJyZW1vdmVOdW0iLCJudW1BcmdzIiwic3BsaWNlZCIsImZpbmRMYXN0SW5kZXgiLCJpbnRlcnBvc2UiLCJpbnRlcnBvc2VGYWN0b3J5IiwiaW50ZXJsZWF2ZSIsInppcHBlZCIsInppcFdpdGhGYWN0b3J5IiwiaW50ZXJsZWF2ZWQiLCJ6aXAiLCJ6aXBXaXRoIiwiemlwcGVyIiwiU3RyaW5nIiwib3JkZXJlZCIsImtleWVkIiwiaGFzaE1lcmdlIiwibXVybXVySGFzaE9mU2l6ZSIsIkltbXV0YWJsZSIsImlzTmVnIiwiSVNfQ09MTEVDVElPTl9TWU1CT0wiLCJCb29sZWFuIiwibWF5YmVDb2xsZWN0aW9uIiwiSVNfS0VZRURfU1lNQk9MIiwiSVNfSU5ERVhFRF9TWU1CT0wiLCJpc0NvbGxlY3Rpb24iLCJLZXllZENvbGxlY3Rpb24iLCJTZXRDb2xsZWN0aW9uIiwiSVNfU0VRX1NZTUJPTCIsIklTX1JFQ09SRF9TWU1CT0wiLCJtYXliZVJlY29yZCIsImlzUmVjb3JkIiwiSVNfT1JERVJFRF9TWU1CT0wiLCJoYXNPd25Qcm9wZXJ0eSIsIk51bWJlciIsImlzSW1tdXRhYmxlIiwiQ29sbGVjdGlvbiQkMSIsIkNvbGxlY3Rpb25TZXEiLCJJU19NQVBfU1lNQk9MIiwibWF5YmVWYWx1ZSIsImlzVmFsdWVPYmplY3QiLCJkZWZhdWx0VmFsdWVPZiIsImhhc2hOdW1iZXIiLCJuIiwiaGFzaGVkIiwid3JpdGFibGUiLCJLZXllZFNlcSQkMSIsInRoaXMkMSIsIkluZGV4ZWRTZXEkJDEiLCJTZXRTZXEkJDEiLCJpbmRleGVkQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25DbGFzcyIsImlzS2V5ZWRDb2xsZWN0aW9uIiwic2l6ZXMiLCJ6aXBBbGwiLCJrZXlQYXRoIiwiaXNEYXRhU3RydWN0dXJlIiwiY29sbGVjdGlvbkNvcHkiLCJzaGFsbG93Q29weSIsInVwZGF0ZUluRGVlcGx5IiwiY29lcmNlS2V5UGF0aCIsIndhc05vdFNldCIsInJlbW92ZSIsImluSW1tdXRhYmxlIiwidXBkYXRlSW4iLCJyZW1vdmVJbiIsInVwZGF0ZSIsIm1lcmdlSW50b0tleWVkV2l0aCIsImNvbGxlY3Rpb25zIiwiY29sbGVjdGlvbiQxIiwibWVyZ2VJbnRvQ29sbGVjdGlvbiIsIm9sZFZhbCIsInNvdXJjZXMiLCJtZXJnZVdpdGhTb3VyY2VzIiwibWVyZ2VEZWVwV2l0aFNvdXJjZXMiLCJpc0FycmF5IiwibWVyZ2VkIiwibWVyZ2VJdGVtIiwiaGFzVmFsIiwibmV4dFZhbCIsIktleWVkQ29sbGVjdGlvbiQkMSIsInNldEF0IiwiSXRlcmF0b3IkJDEiLCJJU19MSVNUX1NZTUJPTCIsIkluZGV4ZWRDb2xsZWN0aW9uJCQxIiwiYXJndW1lbnRzJDEiLCJzZXFzIiwiYXJndW1lbnQiLCJNYXAkJDEiLCJJU19TVEFDS19TWU1CT0wiLCJJU19TRVRfU1lNQk9MIiwicmVzdWx0JDEiLCJTZXRDb2xsZWN0aW9uJCQxIiwic2V0cyIsInJlbW92ZXMiLCJhZGRzIiwibWFwcGVkIiwidG9SZW1vdmUiLCJ1c2VUdXBsZXMiLCJhbW91bnQiLCJoYXNoQ29sbGVjdGlvbiIsIkNvbGxlY3Rpb25Qcm90b3R5cGUiLCJLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUiLCJJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSIsIlNldCQkMSIsImluZGljZXMiLCJwcm9wTmFtZSIsImNvbnNvbGUiLCJsIiwic3RyIiwicmVjb3JkU2VxIiwibmV3VmFsdWVzIiwiY29udmVydGVkIiwidmVyc2lvbiIsIm1lcmdlRGVlcCIsIm1lcmdlV2l0aCIsIm1lcmdlRGVlcFdpdGgiLCJPd25lcklEIiwicmV0dXJuVHJ1ZSIsImNhY2hlUmVzdWx0VGhyb3VnaCIsImRlZmF1bHRDb21wYXJhdG9yIiwic2V0SW4kMSIsImRlbGV0ZUluIiwidXBkYXRlJDEiLCJ1cGRhdGVJbiQxIiwibWVyZ2UkMSIsIm1lcmdlV2l0aCQxIiwibWVyZ2VEZWVwJDEiLCJtZXJnZURlZXBXaXRoJDEiLCJtZXJnZUluIiwibWVyZ2VEZWVwSW4iLCJ3aXRoTXV0YXRpb25zIiwiYXNNdXRhYmxlIiwiYXNJbW11dGFibGUiLCJ3YXNBbHRlcmVkIiwiZ2V0SW4kMSIsImhhc0luJDEiLCJrZXlNYXBwZXIiLCJlbnRyeU1hcHBlciIsImRlZmF1bHRaaXBwZXIiLCJkZWZhdWx0TmVnQ29tcGFyYXRvciIsImRlZmF1bHRDb252ZXJ0ZXIiLCJnZXREZWZhdWx0U3RhdGUiLCJyZWR1Y2VyS2V5cyIsImlucHV0U3RhdGUiLCJhY3Rpb24iLCJwcm9jZXNzIiwid2FybmluZ01lc3NhZ2UiLCJyZWR1Y2VycyIsImN1cnJlbnREb21haW5TdGF0ZSIsInRlbXBvcmFyeVN0YXRlIiwibmV4dERvbWFpblN0YXRlIiwiY29tYmluZVJlZHVjZXJzIiwicmVkdWNlck5hbWVzIiwic3RhdGVOYW1lIiwidW5leHBlY3RlZFN0YXRlUHJvcGVydHlOYW1lcyIsImdldFN0YXRlTmFtZSIsImdldFVuZXhwZWN0ZWRJbnZvY2F0aW9uUGFyYW1ldGVyTWVzc2FnZSIsInZhbGlkYXRlTmV4dFN0YXRlIiwibmV4dFN0YXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQUEsTUFBTSxDQUFOQSxVQUFpQkMsbUJBQU8sQ0FBeEJELCtFQUF3QixDQUF4QkEsQzs7Ozs7Ozs7Ozs7O0FDQUEsc0RBQWE7Ozs7Ozs7O0FBRWJFLE1BQU0sQ0FBTkEsc0NBQTZDO0FBQzNDQyxPQUFLLEVBQUU7QUFEb0MsQ0FBN0NEO0FBR0FFLE9BQU8sQ0FBUEEsZ0JBQXdCQSxPQUFPLENBQVBBLHNCQUE4QkEsT0FBTyxDQUFQQSxVQUFrQkEsT0FBTyxDQUFQQSxhQUFxQkEsT0FBTyxDQUFQQSxvQkFBNEJBLE9BQU8sQ0FBUEEsVUFBa0JBLE9BQU8sQ0FBUEEsc0JBQThCQSxPQUFPLENBQVBBLFlBQW9CQSxPQUFPLENBQVBBLGNBQXNCQSxPQUFPLENBQVBBLG1CQUEyQkEsT0FBTyxDQUFQQSxnQkFBd0JBLE9BQU8sQ0FBUEEsa0JBQTBCQSxPQUFPLENBQVBBLGdCQUF3QkEsT0FBTyxDQUFQQSxZQUFvQkEsT0FBTyxDQUFQQSxTQUFpQkEs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MEJBanJMSXJnQixNOzBCQUdBQyxLOzBCQUNBQyxJOzBCQUNBQyxJOzBCQUlBQyxPOzBCQUdLdU0sTzswQkFJQXhDLE07MEJBU0FxYyxPOzBCQUVBdmxCLFU7MEJBT0E0QixTOzBCQWtCQTRqQixVOzBCQUlBN2dCLFU7MEJBUUFFLFk7MEJBSUFELFU7MEJBSUF4RSxZOzBCQWNBaWYsSzswQkFNTEMsb0I7MEJBRUtLLFk7MEJBSUxGLGU7MEJBRUt6aEIsTzswQkFJTDBoQixpQjswQkFFS3hoQixTOzBCQUlBRSxhOzBCQUlMc0gsVTswQkFJQWthLGU7MEJBWUF4SSxpQjswQkFZQXlJLGE7MEJBZ0JBQyxhOzBCQUVLdk0sSzswQkFJTHdNLGdCOzBCQUVLRSxROzBCQUlBSSxXOzBCQUlMSCxpQjswQkFFS2xjLFM7MEJBSUwzRCxZOzBCQUNBQyxjOzBCQUNBQyxlOzBCQUVBQyxvQjswQkFDQUMsb0I7MEJBRUFDLGU7MEJBRUFDLFE7MEJBbUJLc0IsYTswQkFXQUQsWTswQkFJQWtCLFc7MEJBSUFSLFU7MEJBSUFGLFc7MEJBS0F6QixhOzBCQVVMb2YsYzswQkFFSy9jLFc7MEJBbUJMdEYsRzswQkFvRUFHLFE7MEJBd0JBRSxVOzBCQWdDQUUsTTswQkFnQ0FzRCxROzBCQTJDQVEsUzswQkF1REFvZSxhOzBCQWlEQXZkLFM7MEJBRUs3QixhOzBCQUlBSSxpQjswQkFrQkFDLG1COzBCQVVBSixZOzBCQWFBK0Isd0I7MEJBUUxxZCxhOzBCQUVLcFosSzswQkFJQTRKLFk7MEJBSUEwUCxhOzBCQThEQXZjLEU7MEJBMkJMd0IsSTswQkFnQktNLEc7MEJBSUwwYSxjOzBCQUVLdGEsSTswQkFxQ0F1YSxVOzBCQWVBMWEsZ0I7MEJBZUFDLFU7MEJBY0FDLFM7MEJBdUVMUSxZOzBCQUdBQyxpQjswQkFXS0gsYTswQkFZTEssWTswQkFDQU4sTzswQkFLQUUsVTswQkFFQUssWTswQkFLQUMsNEI7MEJBQ0FDLDBCOzBCQUNBWCxzQjswQkFDQUQsZTswQkFFQW1MLGU7MEJBeURBTSxpQjswQkErQ0FDLGE7MEJBaUNBQyxtQjsw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QUF3QyxnQkFBVTtBQUNyRixXQUFPLENBQUNQLHdCQUFSLElBQVFBLENBQVI7QUFERixHQUFxQyxDQUFyQzs7QUFJQSxNQUFJTyxzQ0FBSixHQUE2QztBQUMzQyxXQUFPLGlCQUFpQkEseURBQWpCLHVCQUFpR0Esa0NBQWpHLE1BQWlHQSxDQUFqRyx5R0FBbVBGLGtCQUFuUCxNQUFtUEEsQ0FBblAsR0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQ3hCS0csWTtRQUNBQyx1QztRQUNBQyxpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JDRlEsMENBQTBEO0FBQ3ZFO0FBQ0EsTUFBSUMsY0FBSixXQUE2QjtBQUMzQixVQUFNLFVBQVUscUVBQXFFZCxPQUFyRSxPQUFoQiwrRUFBTSxDQUFOO0FBQ0QiLCJmaWxlIjoidmVuZG9yLjNiZWQxMDk1NTk5ZmFiYWViZGEwLmhvdC11cGRhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2ltbXV0YWJsZScpXG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9fUmV3aXJlQVBJX18gPSBleHBvcnRzLl9fUmVzZXREZXBlbmRlbmN5X18gPSBleHBvcnRzLl9fc2V0X18gPSBleHBvcnRzLl9fUmV3aXJlX18gPSBleHBvcnRzLl9fR2V0RGVwZW5kZW5jeV9fID0gZXhwb3J0cy5fX2dldF9fID0gZXhwb3J0cy5jcmVhdGVNYXRjaFNlbGVjdG9yID0gZXhwb3J0cy5nZXRBY3Rpb24gPSBleHBvcnRzLmdldExvY2F0aW9uID0gZXhwb3J0cy5yb3V0ZXJNaWRkbGV3YXJlID0gZXhwb3J0cy5jb25uZWN0Um91dGVyID0gZXhwb3J0cy5Db25uZWN0ZWRSb3V0ZXIgPSBleHBvcnRzLnJvdXRlckFjdGlvbnMgPSBleHBvcnRzLmdvRm9yd2FyZCA9IGV4cG9ydHMuZ29CYWNrID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZSA9IGV4cG9ydHMucHVzaCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMuTE9DQVRJT05fQ0hBTkdFID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQWxsID0gcmVxdWlyZSgnLi9jcmVhdGVBbGwnKTtcblxudmFyIF9jcmVhdGVBbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQWxsKTtcblxudmFyIF9pbW11dGFibGUgPSByZXF1aXJlKCcuL3N0cnVjdHVyZS9pbW11dGFibGUnKTtcblxudmFyIF9pbW11dGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW1tdXRhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9nZXRfXzIgPSBfZ2V0X18oJ2NyZWF0ZUFsbCcpKF9nZXRfXygnaW1tdXRhYmxlU3RydWN0dXJlJykpO1xuXG52YXIgTE9DQVRJT05fQ0hBTkdFID0gX2dldF9fMi5MT0NBVElPTl9DSEFOR0UsXG4gICAgQ0FMTF9ISVNUT1JZX01FVEhPRCA9IF9nZXRfXzIuQ0FMTF9ISVNUT1JZX01FVEhPRCxcbiAgICBwdXNoID0gX2dldF9fMi5wdXNoLFxuICAgIHJlcGxhY2UgPSBfZ2V0X18yLnJlcGxhY2UsXG4gICAgZ28gPSBfZ2V0X18yLmdvLFxuICAgIGdvQmFjayA9IF9nZXRfXzIuZ29CYWNrLFxuICAgIGdvRm9yd2FyZCA9IF9nZXRfXzIuZ29Gb3J3YXJkLFxuICAgIHJvdXRlckFjdGlvbnMgPSBfZ2V0X18yLnJvdXRlckFjdGlvbnMsXG4gICAgQ29ubmVjdGVkUm91dGVyID0gX2dldF9fMi5Db25uZWN0ZWRSb3V0ZXIsXG4gICAgY29ubmVjdFJvdXRlciA9IF9nZXRfXzIuY29ubmVjdFJvdXRlcixcbiAgICByb3V0ZXJNaWRkbGV3YXJlID0gX2dldF9fMi5yb3V0ZXJNaWRkbGV3YXJlLFxuICAgIGdldExvY2F0aW9uID0gX2dldF9fMi5nZXRMb2NhdGlvbixcbiAgICBnZXRBY3Rpb24gPSBfZ2V0X18yLmdldEFjdGlvbixcbiAgICBjcmVhdGVNYXRjaFNlbGVjdG9yID0gX2dldF9fMi5jcmVhdGVNYXRjaFNlbGVjdG9yO1xuZXhwb3J0cy5MT0NBVElPTl9DSEFOR0UgPSBMT0NBVElPTl9DSEFOR0U7XG5leHBvcnRzLkNBTExfSElTVE9SWV9NRVRIT0QgPSBDQUxMX0hJU1RPUllfTUVUSE9EO1xuZXhwb3J0cy5wdXNoID0gcHVzaDtcbmV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG5leHBvcnRzLmdvID0gZ287XG5leHBvcnRzLmdvQmFjayA9IGdvQmFjaztcbmV4cG9ydHMuZ29Gb3J3YXJkID0gZ29Gb3J3YXJkO1xuZXhwb3J0cy5yb3V0ZXJBY3Rpb25zID0gcm91dGVyQWN0aW9ucztcbmV4cG9ydHMuQ29ubmVjdGVkUm91dGVyID0gQ29ubmVjdGVkUm91dGVyO1xuZXhwb3J0cy5jb25uZWN0Um91dGVyID0gY29ubmVjdFJvdXRlcjtcbmV4cG9ydHMucm91dGVyTWlkZGxld2FyZSA9IHJvdXRlck1pZGRsZXdhcmU7XG5leHBvcnRzLmdldExvY2F0aW9uID0gZ2V0TG9jYXRpb247XG5leHBvcnRzLmdldEFjdGlvbiA9IGdldEFjdGlvbjtcbmV4cG9ydHMuY3JlYXRlTWF0Y2hTZWxlY3RvciA9IGNyZWF0ZU1hdGNoU2VsZWN0b3I7XG5cbmZ1bmN0aW9uIF9nZXRHbG9iYWxPYmplY3QoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCEhZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoISF3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbn1cblxuO1xudmFyIF9SZXdpcmVNb2R1bGVJZF9fID0gbnVsbDtcblxuZnVuY3Rpb24gX2dldFJld2lyZU1vZHVsZUlkX18oKSB7XG4gIGlmIChfUmV3aXJlTW9kdWxlSWRfXyA9PT0gbnVsbCkge1xuICAgIHZhciBnbG9iYWxWYXJpYWJsZSA9IF9nZXRHbG9iYWxPYmplY3QoKTtcblxuICAgIGlmICghZ2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfTkVYVF9NT0RVTEVfSURfXykge1xuICAgICAgZ2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfTkVYVF9NT0RVTEVfSURfXyA9IDA7XG4gICAgfVxuXG4gICAgX1Jld2lyZU1vZHVsZUlkX18gPSBfXyQkR0xPQkFMX1JFV0lSRV9ORVhUX01PRFVMRV9JRF9fKys7XG4gIH1cblxuICByZXR1cm4gX1Jld2lyZU1vZHVsZUlkX187XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXdpcmVSZWdpc3RyeV9fKCkge1xuICB2YXIgdGhlR2xvYmFsVmFyaWFibGUgPSBfZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbiAgaWYgKCF0aGVHbG9iYWxWYXJpYWJsZS5fXyQkR0xPQkFMX1JFV0lSRV9SRUdJU1RSWV9fKSB7XG4gICAgdGhlR2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICByZXR1cm4gX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXztcbn1cblxuZnVuY3Rpb24gX2dldFJld2lyZWREYXRhX18oKSB7XG4gIHZhciBtb2R1bGVJZCA9IF9nZXRSZXdpcmVNb2R1bGVJZF9fKCk7XG5cbiAgdmFyIHJlZ2lzdHJ5ID0gX2dldFJld2lyZVJlZ2lzdHJ5X18oKTtcblxuICB2YXIgcmV3aXJlRGF0YSA9IHJlZ2lzdHJ5W21vZHVsZUlkXTtcblxuICBpZiAoIXJld2lyZURhdGEpIHtcbiAgICByZWdpc3RyeVttb2R1bGVJZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJld2lyZURhdGEgPSByZWdpc3RyeVttb2R1bGVJZF07XG4gIH1cblxuICByZXR1cm4gcmV3aXJlRGF0YTtcbn1cblxuKGZ1bmN0aW9uIHJlZ2lzdGVyUmVzZXRBbGwoKSB7XG4gIHZhciB0aGVHbG9iYWxWYXJpYWJsZSA9IF9nZXRHbG9iYWxPYmplY3QoKTtcblxuICBpZiAoIXRoZUdsb2JhbFZhcmlhYmxlWydfX3Jld2lyZV9yZXNldF9hbGxfXyddKSB7XG4gICAgdGhlR2xvYmFsVmFyaWFibGVbJ19fcmV3aXJlX3Jlc2V0X2FsbF9fJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGVHbG9iYWxWYXJpYWJsZS5fXyQkR0xPQkFMX1JFV0lSRV9SRUdJU1RSWV9fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuICB9XG59KSgpO1xuXG52YXIgSU5URU5USU9OQUxfVU5ERUZJTkVEID0gJ19fSU5URU5USU9OQUxfVU5ERUZJTkVEX18nO1xudmFyIF9SZXdpcmVBUElfXyA9IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9SZXdpcmVBUElfXywgbmFtZSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFByb3BlcnR5VG9BUElPYmplY3QoJ19fZ2V0X18nLCBfZ2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX0dldERlcGVuZGVuY3lfXycsIF9nZXRfXyk7XG4gIGFkZFByb3BlcnR5VG9BUElPYmplY3QoJ19fUmV3aXJlX18nLCBfc2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX3NldF9fJywgX3NldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19yZXNldF9fJywgX3Jlc2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX1Jlc2V0RGVwZW5kZW5jeV9fJywgX3Jlc2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX3dpdGhfXycsIF93aXRoX18pO1xufSkoKTtcblxuZnVuY3Rpb24gX2dldF9fKHZhcmlhYmxlTmFtZSkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgaWYgKHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIF9nZXRfb3JpZ2luYWxfXyh2YXJpYWJsZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB2YWx1ZSA9IHJld2lyZURhdGFbdmFyaWFibGVOYW1lXTtcblxuICAgIGlmICh2YWx1ZSA9PT0gSU5URU5USU9OQUxfVU5ERUZJTkVEKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRfb3JpZ2luYWxfXyh2YXJpYWJsZU5hbWUpIHtcbiAgc3dpdGNoICh2YXJpYWJsZU5hbWUpIHtcbiAgICBjYXNlICdjcmVhdGVBbGwnOlxuICAgICAgcmV0dXJuIF9jcmVhdGVBbGwyLmRlZmF1bHQ7XG5cbiAgICBjYXNlICdpbW11dGFibGVTdHJ1Y3R1cmUnOlxuICAgICAgcmV0dXJuIF9pbW11dGFibGUyLmRlZmF1bHQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfYXNzaWduX18odmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgaWYgKHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIF9zZXRfb3JpZ2luYWxfXyh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3NldF9vcmlnaW5hbF9fKHZhcmlhYmxlTmFtZSwgX3ZhbHVlKSB7XG4gIHN3aXRjaCAodmFyaWFibGVOYW1lKSB7fVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF91cGRhdGVfb3BlcmF0aW9uX18ob3BlcmF0aW9uLCB2YXJpYWJsZU5hbWUsIHByZWZpeCkge1xuICB2YXIgb2xkVmFsdWUgPSBfZ2V0X18odmFyaWFibGVOYW1lKTtcblxuICB2YXIgbmV3VmFsdWUgPSBvcGVyYXRpb24gPT09ICcrKycgPyBvbGRWYWx1ZSArIDEgOiBvbGRWYWx1ZSAtIDE7XG5cbiAgX2Fzc2lnbl9fKHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpO1xuXG4gIHJldHVybiBwcmVmaXggPyBuZXdWYWx1ZSA6IG9sZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBfc2V0X18odmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgaWYgKCh0eXBlb2YgdmFyaWFibGVOYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YXJpYWJsZU5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyh2YXJpYWJsZU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJld2lyZURhdGFbbmFtZV0gPSB2YXJpYWJsZU5hbWVbbmFtZV07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IElOVEVOVElPTkFMX1VOREVGSU5FRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9yZXNldF9fKHZhcmlhYmxlTmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzZXRfXyh2YXJpYWJsZU5hbWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGRlbGV0ZSByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV07XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJld2lyZURhdGEpLmxlbmd0aCA9PSAwKSB7XG4gICAgZGVsZXRlIF9nZXRSZXdpcmVSZWdpc3RyeV9fKClbX2dldFJld2lyZU1vZHVsZUlkX19dO1xuICB9XG5cbiAgO1xufVxuXG5mdW5jdGlvbiBfd2l0aF9fKG9iamVjdCkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgdmFyIHJld2lyZWRWYXJpYWJsZU5hbWVzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgdmFyIHByZXZpb3VzVmFsdWVzID0ge307XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgcmV3aXJlZFZhcmlhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPSBwcmV2aW91c1ZhbHVlc1t2YXJpYWJsZU5hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJld2lyZWRWYXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgcHJldmlvdXNWYWx1ZXNbdmFyaWFibGVOYW1lXSA9IHJld2lyZURhdGFbdmFyaWFibGVOYW1lXTtcbiAgICAgIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IG9iamVjdFt2YXJpYWJsZU5hbWVdO1xuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuXG4gICAgaWYgKCEhcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQudGhlbihyZXNldCkuY2F0Y2gocmVzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmV4cG9ydHMuX19nZXRfXyA9IF9nZXRfXztcbmV4cG9ydHMuX19HZXREZXBlbmRlbmN5X18gPSBfZ2V0X187XG5leHBvcnRzLl9fUmV3aXJlX18gPSBfc2V0X187XG5leHBvcnRzLl9fc2V0X18gPSBfc2V0X187XG5leHBvcnRzLl9fUmVzZXREZXBlbmRlbmN5X18gPSBfcmVzZXRfXztcbmV4cG9ydHMuX19SZXdpcmVBUElfXyA9IF9SZXdpcmVBUElfXztcbmV4cG9ydHMuZGVmYXVsdCA9IF9SZXdpcmVBUElfXzsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9fUmV3aXJlQVBJX18gPSBleHBvcnRzLl9fUmVzZXREZXBlbmRlbmN5X18gPSBleHBvcnRzLl9fc2V0X18gPSBleHBvcnRzLl9fUmV3aXJlX18gPSBleHBvcnRzLl9fR2V0RGVwZW5kZW5jeV9fID0gZXhwb3J0cy5fX2dldF9fID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qIENvZGUgZnJvbSBnaXRodWIuY29tL2VyaWtyYXMvcmVkdXgtZm9ybSBieSBFcmlrIFJhc211c3NlbiAqL1xuXG5cbnZhciBfaW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBfZ2V0SW4gPSByZXF1aXJlKCcuLi9wbGFpbi9nZXRJbicpO1xuXG52YXIgX2dldEluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGdldEluID0gZnVuY3Rpb24gZ2V0SW4oc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIF9nZXRfXygnSXRlcmFibGUnKS5pc0l0ZXJhYmxlKHN0YXRlKSA/IHN0YXRlLmdldEluKHBhdGgpIDogX2dldF9fKCdwbGFpbkdldEluJykoc3RhdGUsIHBhdGgpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2dldF9fKCdnZXRJbicpO1xuXG5mdW5jdGlvbiBfZ2V0R2xvYmFsT2JqZWN0KCkge1xuICB0cnkge1xuICAgIGlmICghIWdsb2JhbCkge1xuICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCEhd2luZG93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59XG5cbjtcbnZhciBfUmV3aXJlTW9kdWxlSWRfXyA9IG51bGw7XG5cbmZ1bmN0aW9uIF9nZXRSZXdpcmVNb2R1bGVJZF9fKCkge1xuICBpZiAoX1Jld2lyZU1vZHVsZUlkX18gPT09IG51bGwpIHtcbiAgICB2YXIgZ2xvYmFsVmFyaWFibGUgPSBfZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbiAgICBpZiAoIWdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18pIHtcbiAgICAgIGdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18gPSAwO1xuICAgIH1cblxuICAgIF9SZXdpcmVNb2R1bGVJZF9fID0gX18kJEdMT0JBTF9SRVdJUkVfTkVYVF9NT0RVTEVfSURfXysrO1xuICB9XG5cbiAgcmV0dXJuIF9SZXdpcmVNb2R1bGVJZF9fO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV3aXJlUmVnaXN0cnlfXygpIHtcbiAgdmFyIHRoZUdsb2JhbFZhcmlhYmxlID0gX2dldEdsb2JhbE9iamVjdCgpO1xuXG4gIGlmICghdGhlR2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXykge1xuICAgIHRoZUdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX1JFR0lTVFJZX18gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIF9fJCRHTE9CQUxfUkVXSVJFX1JFR0lTVFJZX187XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXdpcmVkRGF0YV9fKCkge1xuICB2YXIgbW9kdWxlSWQgPSBfZ2V0UmV3aXJlTW9kdWxlSWRfXygpO1xuXG4gIHZhciByZWdpc3RyeSA9IF9nZXRSZXdpcmVSZWdpc3RyeV9fKCk7XG5cbiAgdmFyIHJld2lyZURhdGEgPSByZWdpc3RyeVttb2R1bGVJZF07XG5cbiAgaWYgKCFyZXdpcmVEYXRhKSB7XG4gICAgcmVnaXN0cnlbbW9kdWxlSWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXdpcmVEYXRhID0gcmVnaXN0cnlbbW9kdWxlSWRdO1xuICB9XG5cbiAgcmV0dXJuIHJld2lyZURhdGE7XG59XG5cbihmdW5jdGlvbiByZWdpc3RlclJlc2V0QWxsKCkge1xuICB2YXIgdGhlR2xvYmFsVmFyaWFibGUgPSBfZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbiAgaWYgKCF0aGVHbG9iYWxWYXJpYWJsZVsnX19yZXdpcmVfcmVzZXRfYWxsX18nXSkge1xuICAgIHRoZUdsb2JhbFZhcmlhYmxlWydfX3Jld2lyZV9yZXNldF9hbGxfXyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlR2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxudmFyIElOVEVOVElPTkFMX1VOREVGSU5FRCA9ICdfX0lOVEVOVElPTkFMX1VOREVGSU5FRF9fJztcbnZhciBfUmV3aXJlQVBJX18gPSB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkUHJvcGVydHlUb0FQSU9iamVjdChuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUmV3aXJlQVBJX18sIG5hbWUsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX2dldF9fJywgX2dldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19HZXREZXBlbmRlbmN5X18nLCBfZ2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX1Jld2lyZV9fJywgX3NldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19zZXRfXycsIF9zZXRfXyk7XG4gIGFkZFByb3BlcnR5VG9BUElPYmplY3QoJ19fcmVzZXRfXycsIF9yZXNldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19SZXNldERlcGVuZGVuY3lfXycsIF9yZXNldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX193aXRoX18nLCBfd2l0aF9fKTtcbn0pKCk7XG5cbmZ1bmN0aW9uIF9nZXRfXyh2YXJpYWJsZU5hbWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGlmIChyZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfZ2V0X29yaWdpbmFsX18odmFyaWFibGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsdWUgPSByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV07XG5cbiAgICBpZiAodmFsdWUgPT09IElOVEVOVElPTkFMX1VOREVGSU5FRCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0X29yaWdpbmFsX18odmFyaWFibGVOYW1lKSB7XG4gIHN3aXRjaCAodmFyaWFibGVOYW1lKSB7XG4gICAgY2FzZSAnSXRlcmFibGUnOlxuICAgICAgcmV0dXJuIF9pbW11dGFibGUuSXRlcmFibGU7XG5cbiAgICBjYXNlICdwbGFpbkdldEluJzpcbiAgICAgIHJldHVybiBfZ2V0SW4yLmRlZmF1bHQ7XG5cbiAgICBjYXNlICdnZXRJbic6XG4gICAgICByZXR1cm4gZ2V0SW47XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfYXNzaWduX18odmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgaWYgKHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIF9zZXRfb3JpZ2luYWxfXyh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3NldF9vcmlnaW5hbF9fKHZhcmlhYmxlTmFtZSwgX3ZhbHVlKSB7XG4gIHN3aXRjaCAodmFyaWFibGVOYW1lKSB7fVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF91cGRhdGVfb3BlcmF0aW9uX18ob3BlcmF0aW9uLCB2YXJpYWJsZU5hbWUsIHByZWZpeCkge1xuICB2YXIgb2xkVmFsdWUgPSBfZ2V0X18odmFyaWFibGVOYW1lKTtcblxuICB2YXIgbmV3VmFsdWUgPSBvcGVyYXRpb24gPT09ICcrKycgPyBvbGRWYWx1ZSArIDEgOiBvbGRWYWx1ZSAtIDE7XG5cbiAgX2Fzc2lnbl9fKHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpO1xuXG4gIHJldHVybiBwcmVmaXggPyBuZXdWYWx1ZSA6IG9sZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBfc2V0X18odmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgaWYgKCh0eXBlb2YgdmFyaWFibGVOYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YXJpYWJsZU5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyh2YXJpYWJsZU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJld2lyZURhdGFbbmFtZV0gPSB2YXJpYWJsZU5hbWVbbmFtZV07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IElOVEVOVElPTkFMX1VOREVGSU5FRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9yZXNldF9fKHZhcmlhYmxlTmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzZXRfXyh2YXJpYWJsZU5hbWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGRlbGV0ZSByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV07XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJld2lyZURhdGEpLmxlbmd0aCA9PSAwKSB7XG4gICAgZGVsZXRlIF9nZXRSZXdpcmVSZWdpc3RyeV9fKClbX2dldFJld2lyZU1vZHVsZUlkX19dO1xuICB9XG5cbiAgO1xufVxuXG5mdW5jdGlvbiBfd2l0aF9fKG9iamVjdCkge1xuICB2YXIgcmV3aXJlRGF0YSA9IF9nZXRSZXdpcmVkRGF0YV9fKCk7XG5cbiAgdmFyIHJld2lyZWRWYXJpYWJsZU5hbWVzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgdmFyIHByZXZpb3VzVmFsdWVzID0ge307XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgcmV3aXJlZFZhcmlhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPSBwcmV2aW91c1ZhbHVlc1t2YXJpYWJsZU5hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJld2lyZWRWYXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgcHJldmlvdXNWYWx1ZXNbdmFyaWFibGVOYW1lXSA9IHJld2lyZURhdGFbdmFyaWFibGVOYW1lXTtcbiAgICAgIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IG9iamVjdFt2YXJpYWJsZU5hbWVdO1xuICAgIH0pO1xuICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuXG4gICAgaWYgKCEhcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQudGhlbihyZXNldCkuY2F0Y2gocmVzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbnZhciBfdHlwZU9mT3JpZ2luYWxFeHBvcnQgPSB0eXBlb2YgZ2V0SW4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGdldEluKTtcblxuZnVuY3Rpb24gYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRJbiwgbmFtZSwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmlmICgoX3R5cGVPZk9yaWdpbmFsRXhwb3J0ID09PSAnb2JqZWN0JyB8fCBfdHlwZU9mT3JpZ2luYWxFeHBvcnQgPT09ICdmdW5jdGlvbicpICYmIE9iamVjdC5pc0V4dGVuc2libGUoZ2V0SW4pKSB7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19nZXRfXycsIF9nZXRfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19HZXREZXBlbmRlbmN5X18nLCBfZ2V0X18pO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoJ19fUmV3aXJlX18nLCBfc2V0X18pO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoJ19fc2V0X18nLCBfc2V0X18pO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoJ19fcmVzZXRfXycsIF9yZXNldF9fKTtcbiAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KCdfX1Jlc2V0RGVwZW5kZW5jeV9fJywgX3Jlc2V0X18pO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoJ19fd2l0aF9fJywgX3dpdGhfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19SZXdpcmVBUElfXycsIF9SZXdpcmVBUElfXyk7XG59XG5cbmV4cG9ydHMuX19nZXRfXyA9IF9nZXRfXztcbmV4cG9ydHMuX19HZXREZXBlbmRlbmN5X18gPSBfZ2V0X187XG5leHBvcnRzLl9fUmV3aXJlX18gPSBfc2V0X187XG5leHBvcnRzLl9fc2V0X18gPSBfc2V0X187XG5leHBvcnRzLl9fUmVzZXREZXBlbmRlbmN5X18gPSBfcmVzZXRfXztcbmV4cG9ydHMuX19SZXdpcmVBUElfXyA9IF9SZXdpcmVBUElfXzsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9fUmV3aXJlQVBJX18gPSBleHBvcnRzLl9fUmVzZXREZXBlbmRlbmN5X18gPSBleHBvcnRzLl9fc2V0X18gPSBleHBvcnRzLl9fUmV3aXJlX18gPSBleHBvcnRzLl9fR2V0RGVwZW5kZW5jeV9fID0gZXhwb3J0cy5fX2dldF9fID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfaW1tdXRhYmxlID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG5cbnZhciBfZ2V0SW4gPSByZXF1aXJlKCcuL2dldEluJyk7XG5cbnZhciBfZ2V0SW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SW4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3RydWN0dXJlID0ge1xuICBmcm9tSlM6IGZ1bmN0aW9uIGZyb21KUyhqc1ZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRfXygnZnJvbUpTJykoanNWYWx1ZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfZ2V0X18oJ0l0ZXJhYmxlJykuaXNJbmRleGVkKHZhbHVlKSA/IHZhbHVlLnRvTGlzdCgpIDogdmFsdWUudG9NYXAoKTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0SW46IF9nZXRfXygnZ2V0SW4nKSxcbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHN0YXRlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1lcmdlKHBheWxvYWQpO1xuICB9LFxuICB0b0pTOiBmdW5jdGlvbiB0b0pTKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9nZXRfXygnSXRlcmFibGUnKS5pc0l0ZXJhYmxlKHZhbHVlKSA/IHZhbHVlLnRvSlMoKSA6IHZhbHVlO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZ2V0X18oJ3N0cnVjdHVyZScpO1xuXG5mdW5jdGlvbiBfZ2V0R2xvYmFsT2JqZWN0KCkge1xuICB0cnkge1xuICAgIGlmICghIWdsb2JhbCkge1xuICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCEhd2luZG93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59XG5cbjtcbnZhciBfUmV3aXJlTW9kdWxlSWRfXyA9IG51bGw7XG5cbmZ1bmN0aW9uIF9nZXRSZXdpcmVNb2R1bGVJZF9fKCkge1xuICBpZiAoX1Jld2lyZU1vZHVsZUlkX18gPT09IG51bGwpIHtcbiAgICB2YXIgZ2xvYmFsVmFyaWFibGUgPSBfZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbiAgICBpZiAoIWdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18pIHtcbiAgICAgIGdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX05FWFRfTU9EVUxFX0lEX18gPSAwO1xuICAgIH1cblxuICAgIF9SZXdpcmVNb2R1bGVJZF9fID0gX18kJEdMT0JBTF9SRVdJUkVfTkVYVF9NT0RVTEVfSURfXysrO1xuICB9XG5cbiAgcmV0dXJuIF9SZXdpcmVNb2R1bGVJZF9fO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmV3aXJlUmVnaXN0cnlfXygpIHtcbiAgdmFyIHRoZUdsb2JhbFZhcmlhYmxlID0gX2dldEdsb2JhbE9iamVjdCgpO1xuXG4gIGlmICghdGhlR2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXykge1xuICAgIHRoZUdsb2JhbFZhcmlhYmxlLl9fJCRHTE9CQUxfUkVXSVJFX1JFR0lTVFJZX18gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIF9fJCRHTE9CQUxfUkVXSVJFX1JFR0lTVFJZX187XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXdpcmVkRGF0YV9fKCkge1xuICB2YXIgbW9kdWxlSWQgPSBfZ2V0UmV3aXJlTW9kdWxlSWRfXygpO1xuXG4gIHZhciByZWdpc3RyeSA9IF9nZXRSZXdpcmVSZWdpc3RyeV9fKCk7XG5cbiAgdmFyIHJld2lyZURhdGEgPSByZWdpc3RyeVttb2R1bGVJZF07XG5cbiAgaWYgKCFyZXdpcmVEYXRhKSB7XG4gICAgcmVnaXN0cnlbbW9kdWxlSWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXdpcmVEYXRhID0gcmVnaXN0cnlbbW9kdWxlSWRdO1xuICB9XG5cbiAgcmV0dXJuIHJld2lyZURhdGE7XG59XG5cbihmdW5jdGlvbiByZWdpc3RlclJlc2V0QWxsKCkge1xuICB2YXIgdGhlR2xvYmFsVmFyaWFibGUgPSBfZ2V0R2xvYmFsT2JqZWN0KCk7XG5cbiAgaWYgKCF0aGVHbG9iYWxWYXJpYWJsZVsnX19yZXdpcmVfcmVzZXRfYWxsX18nXSkge1xuICAgIHRoZUdsb2JhbFZhcmlhYmxlWydfX3Jld2lyZV9yZXNldF9hbGxfXyddID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlR2xvYmFsVmFyaWFibGUuX18kJEdMT0JBTF9SRVdJUkVfUkVHSVNUUllfXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxudmFyIElOVEVOVElPTkFMX1VOREVGSU5FRCA9ICdfX0lOVEVOVElPTkFMX1VOREVGSU5FRF9fJztcbnZhciBfUmV3aXJlQVBJX18gPSB7fTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkUHJvcGVydHlUb0FQSU9iamVjdChuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUmV3aXJlQVBJX18sIG5hbWUsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX2dldF9fJywgX2dldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19HZXREZXBlbmRlbmN5X18nLCBfZ2V0X18pO1xuICBhZGRQcm9wZXJ0eVRvQVBJT2JqZWN0KCdfX1Jld2lyZV9fJywgX3NldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19zZXRfXycsIF9zZXRfXyk7XG4gIGFkZFByb3BlcnR5VG9BUElPYmplY3QoJ19fcmVzZXRfXycsIF9yZXNldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX19SZXNldERlcGVuZGVuY3lfXycsIF9yZXNldF9fKTtcbiAgYWRkUHJvcGVydHlUb0FQSU9iamVjdCgnX193aXRoX18nLCBfd2l0aF9fKTtcbn0pKCk7XG5cbmZ1bmN0aW9uIF9nZXRfXyh2YXJpYWJsZU5hbWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGlmIChyZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfZ2V0X29yaWdpbmFsX18odmFyaWFibGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsdWUgPSByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV07XG5cbiAgICBpZiAodmFsdWUgPT09IElOVEVOVElPTkFMX1VOREVGSU5FRCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0X29yaWdpbmFsX18odmFyaWFibGVOYW1lKSB7XG4gIHN3aXRjaCAodmFyaWFibGVOYW1lKSB7XG4gICAgY2FzZSAnZnJvbUpTJzpcbiAgICAgIHJldHVybiBfaW1tdXRhYmxlLmZyb21KUztcblxuICAgIGNhc2UgJ0l0ZXJhYmxlJzpcbiAgICAgIHJldHVybiBfaW1tdXRhYmxlLkl0ZXJhYmxlO1xuXG4gICAgY2FzZSAnZ2V0SW4nOlxuICAgICAgcmV0dXJuIF9nZXRJbjIuZGVmYXVsdDtcblxuICAgIGNhc2UgJ3N0cnVjdHVyZSc6XG4gICAgICByZXR1cm4gc3RydWN0dXJlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2Fzc2lnbl9fKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGlmIChyZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfc2V0X29yaWdpbmFsX18odmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9zZXRfb3JpZ2luYWxfXyh2YXJpYWJsZU5hbWUsIF92YWx1ZSkge1xuICBzd2l0Y2ggKHZhcmlhYmxlTmFtZSkge31cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfdXBkYXRlX29wZXJhdGlvbl9fKG9wZXJhdGlvbiwgdmFyaWFibGVOYW1lLCBwcmVmaXgpIHtcbiAgdmFyIG9sZFZhbHVlID0gX2dldF9fKHZhcmlhYmxlTmFtZSk7XG5cbiAgdmFyIG5ld1ZhbHVlID0gb3BlcmF0aW9uID09PSAnKysnID8gb2xkVmFsdWUgKyAxIDogb2xkVmFsdWUgLSAxO1xuXG4gIF9hc3NpZ25fXyh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlKTtcblxuICByZXR1cm4gcHJlZml4ID8gbmV3VmFsdWUgOiBvbGRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gX3NldF9fKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIGlmICgodHlwZW9mIHZhcmlhYmxlTmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFyaWFibGVOYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXModmFyaWFibGVOYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXdpcmVEYXRhW25hbWVdID0gdmFyaWFibGVOYW1lW25hbWVdO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPSBJTlRFTlRJT05BTF9VTkRFRklORUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJld2lyZURhdGFbdmFyaWFibGVOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfcmVzZXRfXyh2YXJpYWJsZU5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc2V0X18odmFyaWFibGVOYW1lKSB7XG4gIHZhciByZXdpcmVEYXRhID0gX2dldFJld2lyZWREYXRhX18oKTtcblxuICBkZWxldGUgcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdO1xuXG4gIGlmIChPYmplY3Qua2V5cyhyZXdpcmVEYXRhKS5sZW5ndGggPT0gMCkge1xuICAgIGRlbGV0ZSBfZ2V0UmV3aXJlUmVnaXN0cnlfXygpW19nZXRSZXdpcmVNb2R1bGVJZF9fXTtcbiAgfVxuXG4gIDtcbn1cblxuZnVuY3Rpb24gX3dpdGhfXyhvYmplY3QpIHtcbiAgdmFyIHJld2lyZURhdGEgPSBfZ2V0UmV3aXJlZERhdGFfXygpO1xuXG4gIHZhciByZXdpcmVkVmFyaWFibGVOYW1lcyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciBwcmV2aW91c1ZhbHVlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHJld2lyZWRWYXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgcmV3aXJlRGF0YVt2YXJpYWJsZU5hbWVdID0gcHJldmlvdXNWYWx1ZXNbdmFyaWFibGVOYW1lXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXdpcmVkVmFyaWFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgIHByZXZpb3VzVmFsdWVzW3ZhcmlhYmxlTmFtZV0gPSByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV07XG4gICAgICByZXdpcmVEYXRhW3ZhcmlhYmxlTmFtZV0gPSBvYmplY3RbdmFyaWFibGVOYW1lXTtcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soKTtcblxuICAgIGlmICghIXJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0LnRoZW4ocmVzZXQpLmNhdGNoKHJlc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG52YXIgX3R5cGVPZk9yaWdpbmFsRXhwb3J0ID0gdHlwZW9mIHN0cnVjdHVyZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3RydWN0dXJlKTtcblxuZnVuY3Rpb24gYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHJ1Y3R1cmUsIG5hbWUsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5pZiAoKF90eXBlT2ZPcmlnaW5hbEV4cG9ydCA9PT0gJ29iamVjdCcgfHwgX3R5cGVPZk9yaWdpbmFsRXhwb3J0ID09PSAnZnVuY3Rpb24nKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHN0cnVjdHVyZSkpIHtcbiAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KCdfX2dldF9fJywgX2dldF9fKTtcbiAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KCdfX0dldERlcGVuZGVuY3lfXycsIF9nZXRfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19SZXdpcmVfXycsIF9zZXRfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19zZXRfXycsIF9zZXRfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX19yZXNldF9fJywgX3Jlc2V0X18pO1xuICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoJ19fUmVzZXREZXBlbmRlbmN5X18nLCBfcmVzZXRfXyk7XG4gIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSgnX193aXRoX18nLCBfd2l0aF9fKTtcbiAgYWRkTm9uRW51bWVyYWJsZVByb3BlcnR5KCdfX1Jld2lyZUFQSV9fJywgX1Jld2lyZUFQSV9fKTtcbn1cblxuZXhwb3J0cy5fX2dldF9fID0gX2dldF9fO1xuZXhwb3J0cy5fX0dldERlcGVuZGVuY3lfXyA9IF9nZXRfXztcbmV4cG9ydHMuX19SZXdpcmVfXyA9IF9zZXRfXztcbmV4cG9ydHMuX19zZXRfXyA9IF9zZXRfXztcbmV4cG9ydHMuX19SZXNldERlcGVuZGVuY3lfXyA9IF9yZXNldF9fO1xuZXhwb3J0cy5fX1Jld2lyZUFQSV9fID0gX1Jld2lyZUFQSV9fOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLkltbXV0YWJsZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO3ZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKGN0b3IsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0l0ZXJhYmxlKHZhbHVlKSA/IHZhbHVlIDogU2VxKHZhbHVlKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhLZXllZEl0ZXJhYmxlLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gS2V5ZWRJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUgOiBLZXllZFNlcSh2YWx1ZSk7XG4gICAgfVxuXG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZEl0ZXJhYmxlLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHZhbHVlKSA/IHZhbHVlIDogSW5kZXhlZFNlcSh2YWx1ZSk7XG4gICAgfVxuXG5cbiAgY3JlYXRlQ2xhc3MoU2V0SXRlcmFibGUsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBTZXRJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSXRlcmFibGUodmFsdWUpICYmICFpc0Fzc29jaWF0aXZlKHZhbHVlKSA/IHZhbHVlIDogU2V0U2VxKHZhbHVlKTtcbiAgICB9XG5cblxuXG4gIGZ1bmN0aW9uIGlzSXRlcmFibGUobWF5YmVJdGVyYWJsZSkge1xuICAgIHJldHVybiAhIShtYXliZUl0ZXJhYmxlICYmIG1heWJlSXRlcmFibGVbSVNfSVRFUkFCTEVfU0VOVElORUxdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5ZWQobWF5YmVLZXllZCkge1xuICAgIHJldHVybiAhIShtYXliZUtleWVkICYmIG1heWJlS2V5ZWRbSVNfS0VZRURfU0VOVElORUxdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5kZXhlZChtYXliZUluZGV4ZWQpIHtcbiAgICByZXR1cm4gISEobWF5YmVJbmRleGVkICYmIG1heWJlSW5kZXhlZFtJU19JTkRFWEVEX1NFTlRJTkVMXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Fzc29jaWF0aXZlKG1heWJlQXNzb2NpYXRpdmUpIHtcbiAgICByZXR1cm4gaXNLZXllZChtYXliZUFzc29jaWF0aXZlKSB8fCBpc0luZGV4ZWQobWF5YmVBc3NvY2lhdGl2ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09yZGVyZWQobWF5YmVPcmRlcmVkKSB7XG4gICAgcmV0dXJuICEhKG1heWJlT3JkZXJlZCAmJiBtYXliZU9yZGVyZWRbSVNfT1JERVJFRF9TRU5USU5FTF0pO1xuICB9XG5cbiAgSXRlcmFibGUuaXNJdGVyYWJsZSA9IGlzSXRlcmFibGU7XG4gIEl0ZXJhYmxlLmlzS2V5ZWQgPSBpc0tleWVkO1xuICBJdGVyYWJsZS5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG4gIEl0ZXJhYmxlLmlzQXNzb2NpYXRpdmUgPSBpc0Fzc29jaWF0aXZlO1xuICBJdGVyYWJsZS5pc09yZGVyZWQgPSBpc09yZGVyZWQ7XG5cbiAgSXRlcmFibGUuS2V5ZWQgPSBLZXllZEl0ZXJhYmxlO1xuICBJdGVyYWJsZS5JbmRleGVkID0gSW5kZXhlZEl0ZXJhYmxlO1xuICBJdGVyYWJsZS5TZXQgPSBTZXRJdGVyYWJsZTtcblxuXG4gIHZhciBJU19JVEVSQUJMRV9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG4gIHZhciBJU19LRVlFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG4gIHZhciBJU19JTkRFWEVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnO1xuICB2YXIgSVNfT1JERVJFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuICAvLyBVc2VkIGZvciBzZXR0aW5nIHByb3RvdHlwZSBtZXRob2RzIHRoYXQgSUU4IGNob2tlcyBvbi5cbiAgdmFyIERFTEVURSA9ICdkZWxldGUnO1xuXG4gIC8vIENvbnN0YW50cyBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRyaWUgbm9kZXMuXG4gIHZhciBTSElGVCA9IDU7IC8vIFJlc3VsdGVkIGluIGJlc3QgcGVyZm9ybWFuY2UgYWZ0ZXIgX19fX19fP1xuICB2YXIgU0laRSA9IDEgPDwgU0hJRlQ7XG4gIHZhciBNQVNLID0gU0laRSAtIDE7XG5cbiAgLy8gQSBjb25zaXN0ZW50IHNoYXJlZCB2YWx1ZSByZXByZXNlbnRpbmcgXCJub3Qgc2V0XCIgd2hpY2ggZXF1YWxzIG5vdGhpbmcgb3RoZXJcbiAgLy8gdGhhbiBpdHNlbGYsIGFuZCBub3RoaW5nIHRoYXQgY291bGQgYmUgcHJvdmlkZWQgZXh0ZXJuYWxseS5cbiAgdmFyIE5PVF9TRVQgPSB7fTtcblxuICAvLyBCb29sZWFuIHJlZmVyZW5jZXMsIFJvdWdoIGVxdWl2YWxlbnQgb2YgYGJvb2wgJmAuXG4gIHZhciBDSEFOR0VfTEVOR1RIID0geyB2YWx1ZTogZmFsc2UgfTtcbiAgdmFyIERJRF9BTFRFUiA9IHsgdmFsdWU6IGZhbHNlIH07XG5cbiAgZnVuY3Rpb24gTWFrZVJlZihyZWYpIHtcbiAgICByZWYudmFsdWUgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICAgIHJlZiAmJiAocmVmLnZhbHVlID0gdHJ1ZSk7XG4gIH1cblxuICAvLyBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSByZXByZXNlbnRpbmcgYW4gXCJvd25lclwiIGZvciB0cmFuc2llbnQgd3JpdGVzXG4gIC8vIHRvIHRyaWVzLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgb25seSBldmVyIGVxdWFsIGl0c2VsZiwgYW5kIHdpbGwgbm90IGVxdWFsXG4gIC8vIHRoZSByZXR1cm4gb2YgYW55IHN1YnNlcXVlbnQgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBPd25lcklEKCkge31cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9jb3B5LWFycmF5LWlubGluZVxuICBmdW5jdGlvbiBhcnJDb3B5KGFyciwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIGFyci5sZW5ndGggLSBvZmZzZXQpO1xuICAgIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBuZXdBcnJbaWldID0gYXJyW2lpICsgb2Zmc2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVNpemUoaXRlcikge1xuICAgIGlmIChpdGVyLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlci5zaXplID0gaXRlci5fX2l0ZXJhdGUocmV0dXJuVHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLnNpemU7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwSW5kZXgoaXRlciwgaW5kZXgpIHtcbiAgICAvLyBUaGlzIGltcGxlbWVudHMgXCJpcyBhcnJheSBpbmRleFwiIHdoaWNoIHRoZSBFQ01BU3RyaW5nIHNwZWMgZGVmaW5lcyBhczpcbiAgICAvL1xuICAgIC8vICAgICBBIFN0cmluZyBwcm9wZXJ0eSBuYW1lIFAgaXMgYW4gYXJyYXkgaW5kZXggaWYgYW5kIG9ubHkgaWZcbiAgICAvLyAgICAgVG9TdHJpbmcoVG9VaW50MzIoUCkpIGlzIGVxdWFsIHRvIFAgYW5kIFRvVWludDMyKFApIGlzIG5vdCBlcXVhbFxuICAgIC8vICAgICB0byAyXjMy4oiSMS5cbiAgICAvL1xuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheS1leG90aWMtb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdWludDMySW5kZXggPSBpbmRleCA+Pj4gMDsgLy8gTiA+Pj4gMCBpcyBzaG9ydGhhbmQgZm9yIFRvVWludDMyXG4gICAgICBpZiAoJycgKyB1aW50MzJJbmRleCAhPT0gaW5kZXggfHwgdWludDMySW5kZXggPT09IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gdWludDMySW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBpbmRleCA8IDAgPyBlbnN1cmVTaXplKGl0ZXIpICsgaW5kZXggOiBpbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpIHtcbiAgICByZXR1cm4gKGJlZ2luID09PSAwIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgYmVnaW4gPD0gLXNpemUpKSAmJlxuICAgICAgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgZW5kID49IHNpemUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoYmVnaW4sIHNpemUsIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIHNpemUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGVuZCwgc2l6ZSwgc2l6ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlSW5kZXgoaW5kZXgsIHNpemUsIGRlZmF1bHRJbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIGRlZmF1bHRJbmRleCA6XG4gICAgICBpbmRleCA8IDAgP1xuICAgICAgICBNYXRoLm1heCgwLCBzaXplICsgaW5kZXgpIDpcbiAgICAgICAgc2l6ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBpbmRleCA6XG4gICAgICAgICAgTWF0aC5taW4oc2l6ZSwgaW5kZXgpO1xuICB9XG5cbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG4gIHZhciBJVEVSQVRFX0tFWVMgPSAwO1xuICB2YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xuICB2YXIgSVRFUkFURV9FTlRSSUVTID0gMjtcblxuICB2YXIgUkVBTF9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSBSRUFMX0lURVJBVE9SX1NZTUJPTCB8fCBGQVVYX0lURVJBVE9SX1NZTUJPTDtcblxuXG4gIGZ1bmN0aW9uIEl0ZXJhdG9yKG5leHQpIHtcbiAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xuICAgIH07XG5cblxuICBJdGVyYXRvci5LRVlTID0gSVRFUkFURV9LRVlTO1xuICBJdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcbiAgSXRlcmF0b3IuRU5UUklFUyA9IElURVJBVEVfRU5UUklFUztcblxuICBJdGVyYXRvci5wcm90b3R5cGUuaW5zcGVjdCA9XG4gIEl0ZXJhdG9yLnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxuICBJdGVyYXRvci5wcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgaXRlcmF0b3JSZXN1bHQpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlID09PSAwID8gayA6IHR5cGUgPT09IDEgPyB2IDogW2ssIHZdO1xuICAgIGl0ZXJhdG9yUmVzdWx0ID8gKGl0ZXJhdG9yUmVzdWx0LnZhbHVlID0gdmFsdWUpIDogKGl0ZXJhdG9yUmVzdWx0ID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLCBkb25lOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvclJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRG9uZSgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJdGVyYXRvcihtYXliZUl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSXRlcmF0b3IobWF5YmVJdGVyYXRvcikge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yICYmIHR5cGVvZiBtYXliZUl0ZXJhdG9yLm5leHQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm4gJiYgaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGl0ZXJhYmxlICYmIChcbiAgICAgIChSRUFMX0lURVJBVE9SX1NZTUJPTCAmJiBpdGVyYWJsZVtSRUFMX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF1cbiAgICApO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcic7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTZXEsIEl0ZXJhYmxlKTtcbiAgICBmdW5jdGlvbiBTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcbiAgICAgICAgaXNJdGVyYWJsZSh2YWx1ZSkgPyB2YWx1ZS50b1NlcSgpIDogc2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBTZXEub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHRoaXMuZW50cnlTZXEoKS50b0FycmF5KCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2NhY2hlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRlKHRoaXMsIGZuLCByZXZlcnNlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpXG5cbiAgICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSwgdHJ1ZSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoS2V5ZWRTZXEsIFNlcSk7XG4gICAgZnVuY3Rpb24gS2V5ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgZW1wdHlTZXF1ZW5jZSgpLnRvS2V5ZWRTZXEoKSA6XG4gICAgICAgIGlzSXRlcmFibGUodmFsdWUpID9cbiAgICAgICAgICAoaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS50b1NlcSgpIDogdmFsdWUuZnJvbUVudHJ5U2VxKCkpIDpcbiAgICAgICAgICBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEluZGV4ZWRTZXEsIFNlcSk7XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuICAgICAgICAhaXNJdGVyYWJsZSh2YWx1ZSkgPyBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSA6XG4gICAgICAgIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUuZW50cnlTZXEoKSA6IHZhbHVlLnRvSW5kZXhlZFNlcSgpO1xuICAgIH1cblxuICAgIEluZGV4ZWRTZXEub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gSW5kZXhlZFNlcShhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS50b0luZGV4ZWRTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdGUodGhpcywgZm4sIHJldmVyc2UsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlLCBmYWxzZSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoU2V0U2VxLCBTZXEpO1xuICAgIGZ1bmN0aW9uIFNldFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG4gICAgICAgICFpc0l0ZXJhYmxlKHZhbHVlKSA/IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIDpcbiAgICAgICAgaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS5lbnRyeVNlcSgpIDogdmFsdWVcbiAgICAgICkudG9TZXRTZXEoKTtcbiAgICB9XG5cbiAgICBTZXRTZXEub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gU2V0U2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuXG4gIFNlcS5pc1NlcSA9IGlzU2VxO1xuICBTZXEuS2V5ZWQgPSBLZXllZFNlcTtcbiAgU2VxLlNldCA9IFNldFNlcTtcbiAgU2VxLkluZGV4ZWQgPSBJbmRleGVkU2VxO1xuXG4gIHZhciBJU19TRVFfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9TRVFfX0BAJztcblxuICBTZXEucHJvdG90eXBlW0lTX1NFUV9TRU5USU5FTF0gPSB0cnVlO1xuXG5cblxuICBjcmVhdGVDbGFzcyhBcnJheVNlcSwgSW5kZXhlZFNlcSk7XG4gICAgZnVuY3Rpb24gQXJyYXlTZXEoYXJyYXkpIHtcbiAgICAgIHRoaXMuX2FycmF5ID0gYXJyYXk7XG4gICAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX2FycmF5W3dyYXBJbmRleCh0aGlzLCBpbmRleCldIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICB2YXIgbWF4SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICBpZiAoZm4oYXJyYXlbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0sIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfTtcblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICB2YXIgbWF4SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSBcbiAgICAgICAge3JldHVybiBpaSA+IG1heEluZGV4ID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpaSwgYXJyYXlbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkrKyA6IGlpKytdKX1cbiAgICAgICk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoT2JqZWN0U2VxLCBLZXllZFNlcSk7XG4gICAgZnVuY3Rpb24gT2JqZWN0U2VxKG9iamVjdCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgICB0aGlzLnNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChub3RTZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3Rba2V5XTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBtYXhJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIGlmIChmbihvYmplY3Rba2V5XSwga2V5LCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgbWF4SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICByZXR1cm4gaWkrKyA+IG1heEluZGV4ID9cbiAgICAgICAgICBpdGVyYXRvckRvbmUoKSA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrZXksIG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuICBjcmVhdGVDbGFzcyhJdGVyYWJsZVNlcSwgSW5kZXhlZFNlcSk7XG4gICAgZnVuY3Rpb24gSXRlcmFibGVTZXEoaXRlcmFibGUpIHtcbiAgICAgIHRoaXMuX2l0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyYWJsZS5sZW5ndGggfHwgaXRlcmFibGUuc2l6ZTtcbiAgICB9XG5cbiAgICBJdGVyYWJsZVNlcS5wcm90b3R5cGUuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGU7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpZiAoaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIEl0ZXJhYmxlU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLl9pdGVyYWJsZTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgICAgIGlmICghaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEl0ZXJhdG9yU2VxLCBJbmRleGVkU2VxKTtcbiAgICBmdW5jdGlvbiBJdGVyYXRvclNlcShpdGVyYXRvcikge1xuICAgICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgIHRoaXMuX2l0ZXJhdG9yQ2FjaGUgPSBbXTtcbiAgICB9XG5cbiAgICBJdGVyYXRvclNlcS5wcm90b3R5cGUuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9pdGVyYXRvckNhY2hlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPCBjYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZuKGNhY2hlW2l0ZXJhdGlvbnNdLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgdmFyIHZhbCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIGNhY2hlW2l0ZXJhdGlvbnNdID0gdmFsO1xuICAgICAgICBpZiAoZm4odmFsLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgSXRlcmF0b3JTZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXJhdG9yO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5faXRlcmF0b3JDYWNoZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoaXRlcmF0aW9ucyA+PSBjYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FjaGVbaXRlcmF0aW9uc10gPSBzdGVwLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMsIGNhY2hlW2l0ZXJhdGlvbnMrK10pO1xuICAgICAgfSk7XG4gICAgfTtcblxuXG5cblxuICAvLyAjIHByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gaXNTZXEobWF5YmVTZXEpIHtcbiAgICByZXR1cm4gISEobWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NFTlRJTkVMXSk7XG4gIH1cblxuICB2YXIgRU1QVFlfU0VRO1xuXG4gIGZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFUSB8fCAoRU1QVFlfU0VRID0gbmV3IEFycmF5U2VxKFtdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPVxuICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBuZXcgQXJyYXlTZXEodmFsdWUpLmZyb21FbnRyeVNlcSgpIDpcbiAgICAgIGlzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhdG9yU2VxKHZhbHVlKS5mcm9tRW50cnlTZXEoKSA6XG4gICAgICBoYXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmFibGVTZXEodmFsdWUpLmZyb21FbnRyeVNlcSgpIDpcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBuZXcgT2JqZWN0U2VxKHZhbHVlKSA6XG4gICAgICB1bmRlZmluZWQ7XG4gICAgaWYgKCFzZXEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBBcnJheSBvciBpdGVyYWJsZSBvYmplY3Qgb2YgW2ssIHZdIGVudHJpZXMsICcrXG4gICAgICAgICdvciBrZXllZCBvYmplY3Q6ICcgKyB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICBpZiAoIXNlcSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGl0ZXJhYmxlIG9iamVjdCBvZiB2YWx1ZXM6ICcgKyB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHx8XG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBuZXcgT2JqZWN0U2VxKHZhbHVlKSk7XG4gICAgaWYgKCFzZXEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBBcnJheSBvciBpdGVyYWJsZSBvYmplY3Qgb2YgdmFsdWVzLCBvciBrZXllZCBvYmplY3Q6ICcgKyB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgPyBuZXcgQXJyYXlTZXEodmFsdWUpIDpcbiAgICAgIGlzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhdG9yU2VxKHZhbHVlKSA6XG4gICAgICBoYXNJdGVyYXRvcih2YWx1ZSkgPyBuZXcgSXRlcmFibGVTZXEodmFsdWUpIDpcbiAgICAgIHVuZGVmaW5lZFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXFJdGVyYXRlKHNlcSwgZm4sIHJldmVyc2UsIHVzZUtleXMpIHtcbiAgICB2YXIgY2FjaGUgPSBzZXEuX2NhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgdmFyIG1heEluZGV4ID0gY2FjaGUubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIGlmIChmbihlbnRyeVsxXSwgdXNlS2V5cyA/IGVudHJ5WzBdIDogaWksIHNlcSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH1cbiAgICByZXR1cm4gc2VxLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUl0ZXJhdG9yKHNlcSwgdHlwZSwgcmV2ZXJzZSwgdXNlS2V5cykge1xuICAgIHZhciBjYWNoZSA9IHNlcS5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSBjYWNoZS5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgcmV0dXJuIGlpKysgPiBtYXhJbmRleCA/XG4gICAgICAgICAgaXRlcmF0b3JEb25lKCkgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgdXNlS2V5cyA/IGVudHJ5WzBdIDogaWkgLSAxLCBlbnRyeVsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlMoanNvbiwgY29udmVydGVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRlciA/XG4gICAgICBmcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwgJycsIHsnJzoganNvbn0pIDpcbiAgICAgIGZyb21KU0RlZmF1bHQoanNvbik7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwga2V5LCBwYXJlbnRKU09OKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0ZXIuY2FsbChwYXJlbnRKU09OLCBrZXksIEluZGV4ZWRTZXEoanNvbikubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZyb21KU1dpdGgoY29udmVydGVyLCB2LCBrLCBqc29uKX0pKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmooanNvbikpIHtcbiAgICAgIHJldHVybiBjb252ZXJ0ZXIuY2FsbChwYXJlbnRKU09OLCBrZXksIEtleWVkU2VxKGpzb24pLm1hcChmdW5jdGlvbih2LCBrKSAge3JldHVybiBmcm9tSlNXaXRoKGNvbnZlcnRlciwgdiwgaywganNvbil9KSk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUpTRGVmYXVsdChqc29uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGpzb24pLm1hcChmcm9tSlNEZWZhdWx0KS50b0xpc3QoKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmooanNvbikpIHtcbiAgICAgIHJldHVybiBLZXllZFNlcShqc29uKS5tYXAoZnJvbUpTRGVmYXVsdCkudG9NYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgXCJzYW1lLXZhbHVlXCIgYWxnb3JpdGhtIGFzIFtkZXNjcmliZWQgZm9yIHVzZSBieSBFUzYgTWFwXG4gICAqIGFuZCBTZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNLZXlfZXF1YWxpdHkpXG4gICAqXG4gICAqIE5hTiBpcyBjb25zaWRlcmVkIHRoZSBzYW1lIGFzIE5hTiwgaG93ZXZlciAtMCBhbmQgMCBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICAgKiB2YWx1ZSwgd2hpY2ggaXMgZGlmZmVyZW50IGZyb20gdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgYnlcbiAgICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dGVuZGVkIGZ1cnRoZXIgdG8gYWxsb3cgT2JqZWN0cyB0byBkZXNjcmliZSB0aGUgdmFsdWVzIHRoZXlcbiAgICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG4gICAqXG4gICAqIE5vdGU6IGJlY2F1c2Ugb2YgdGhpcyBleHRlbnNpb24sIHRoZSBrZXkgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLk1hcCBhbmQgdGhlXG4gICAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG4gICAqXG4gICAqICMjIyBEZWZpbmluZyBjdXN0b20gdmFsdWVzXG4gICAqXG4gICAqIFRoZSBlYXNpZXN0IHdheSB0byBkZXNjcmliZSB0aGUgdmFsdWUgYW4gb2JqZWN0IHJlcHJlc2VudHMgaXMgYnkgaW1wbGVtZW50aW5nXG4gICAqIGB2YWx1ZU9mYC4gRm9yIGV4YW1wbGUsIGBEYXRlYCByZXByZXNlbnRzIGEgdmFsdWUgYnkgcmV0dXJuaW5nIGEgdW5peFxuICAgKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcbiAgICpcbiAgICogICAgIHZhciBkYXRlMSA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApOyAvLyBGcmkgRmViIDEzIDIwMDkgLi4uXG4gICAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcbiAgICogICAgIGRhdGUxLnZhbHVlT2YoKTsgLy8gMTIzNDU2Nzg5MDAwMFxuICAgKiAgICAgYXNzZXJ0KCBkYXRlMSAhPT0gZGF0ZTIgKTtcbiAgICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuICAgKlxuICAgKiBOb3RlOiBvdmVycmlkaW5nIGB2YWx1ZU9mYCBtYXkgaGF2ZSBvdGhlciBpbXBsaWNhdGlvbnMgaWYgeW91IHVzZSB0aGlzIG9iamVjdFxuICAgKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuICAgKlxuICAgKiBGb3IgbW9yZSBjb21wbGV4IHR5cGVzLCBlc3BlY2lhbGx5IGNvbGxlY3Rpb25zLCBpbXBsZW1lbnRpbmcgYHZhbHVlT2ZgIG1heVxuICAgKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICAgKlxuICAgKiBgZXF1YWxzYCB0YWtlcyBhbm90aGVyIG9iamVjdCwgcHJlc3VtYWJseSBvZiBzaW1pbGFyIHR5cGUsIGFuZCByZXR1cm5zIHRydWVcbiAgICogaWYgdGhlIGl0IGlzIGVxdWFsLiBFcXVhbGl0eSBpcyBzeW1tZXRyaWNhbCwgc28gdGhlIHNhbWUgcmVzdWx0IHNob3VsZCBiZVxuICAgKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQoIGEuZXF1YWxzKGIpID09PSBiLmVxdWFscyhhKSApO1xuICAgKlxuICAgKiBgaGFzaENvZGVgIHJldHVybnMgYSAzMmJpdCBpbnRlZ2VyIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG9iamVjdCB3aGljaCB3aWxsXG4gICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aGUgdmFsdWUgb2JqZWN0IGluIGEgTWFwIG9yIFNldC4gWW91IG11c3RcbiAgICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICAgKlxuICAgKiBBbHNvLCBhbiBpbXBvcnRhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlc2UgbWV0aG9kcyBtdXN0IGJlIHVwaGVsZDogaWYgdHdvXG4gICAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gICAqIGVxdWFsLCB0aGV5IG1pZ2h0IGhhdmUgdGhlIHNhbWUgaGFzaENvZGU7IHRoaXMgaXMgY2FsbGVkIGEgaGFzaCBjb2xsaXNpb24sXG4gICAqIGFuZCB3aGlsZSB1bmRlc2lyYWJsZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgYWNjZXB0YWJsZS5cbiAgICpcbiAgICogICAgIGlmIChhLmVxdWFscyhiKSkge1xuICAgKiAgICAgICBhc3NlcnQoIGEuaGFzaENvZGUoKSA9PT0gYi5oYXNoQ29kZSgpICk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEFsbCBJbW11dGFibGUgY29sbGVjdGlvbnMgaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcbiAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZUEudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWVCLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlQSA9IHZhbHVlQS52YWx1ZU9mKCk7XG4gICAgICB2YWx1ZUIgPSB2YWx1ZUIudmFsdWVPZigpO1xuICAgICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZUEuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZUIuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHZhbHVlQS5lcXVhbHModmFsdWVCKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFpc0l0ZXJhYmxlKGIpIHx8XG4gICAgICBhLnNpemUgIT09IHVuZGVmaW5lZCAmJiBiLnNpemUgIT09IHVuZGVmaW5lZCAmJiBhLnNpemUgIT09IGIuc2l6ZSB8fFxuICAgICAgYS5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJiBiLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmIGEuX19oYXNoICE9PSBiLl9faGFzaCB8fFxuICAgICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuICAgICAgaXNJbmRleGVkKGEpICE9PSBpc0luZGV4ZWQoYikgfHxcbiAgICAgIGlzT3JkZXJlZChhKSAhPT0gaXNPcmRlcmVkKGIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG4gICAgaWYgKGlzT3JkZXJlZChhKSkge1xuICAgICAgdmFyIGVudHJpZXMgPSBhLmVudHJpZXMoKTtcbiAgICAgIHJldHVybiBiLmV2ZXJ5KGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMV0sIHYpICYmIChub3RBc3NvY2lhdGl2ZSB8fCBpcyhlbnRyeVswXSwgaykpO1xuICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZTtcbiAgICB9XG5cbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGEuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYi5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhLmNhY2hlUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYS5jYWNoZVJlc3VsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIF8gPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IF87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFsbEVxdWFsID0gdHJ1ZTtcbiAgICB2YXIgYlNpemUgPSBiLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgaWYgKG5vdEFzc29jaWF0aXZlID8gIWEuaGFzKHYpIDpcbiAgICAgICAgICBmbGlwcGVkID8gIWlzKHYsIGEuZ2V0KGssIE5PVF9TRVQpKSA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdikpIHtcbiAgICAgICAgYWxsRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFsbEVxdWFsICYmIGEuc2l6ZSA9PT0gYlNpemU7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhSZXBlYXQsIEluZGV4ZWRTZXEpO1xuXG4gICAgZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcGVhdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBlYXQodmFsdWUsIHRpbWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnNpemUgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBNYXRoLm1heCgwLCB0aW1lcyk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SRVBFQVQpIHtcbiAgICAgICAgICByZXR1cm4gRU1QVFlfUkVQRUFUO1xuICAgICAgICB9XG4gICAgICAgIEVNUFRZX1JFUEVBVCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmVwZWF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1JlcGVhdCBbXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1JlcGVhdCBbICcgKyB0aGlzLl92YWx1ZSArICcgJyArIHRoaXMuc2l6ZSArICcgdGltZXMgXSc7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkgPyB0aGlzIDpcbiAgICAgICAgbmV3IFJlcGVhdCh0aGlzLl92YWx1ZSwgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGhpcy5zaXplOyBpaSsrKSB7XG4gICAgICAgIGlmIChmbih0aGlzLl92YWx1ZSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSBcbiAgICAgICAge3JldHVybiBpaSA8IHRoaXMkMC5zaXplID8gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpaSsrLCB0aGlzJDAuX3ZhbHVlKSA6IGl0ZXJhdG9yRG9uZSgpfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVwZWF0ID9cbiAgICAgICAgaXModGhpcy5fdmFsdWUsIG90aGVyLl92YWx1ZSkgOlxuICAgICAgICBkZWVwRXF1YWwob3RoZXIpO1xuICAgIH07XG5cblxuICB2YXIgRU1QVFlfUkVQRUFUO1xuXG4gIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGVycm9yKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhSYW5nZSwgSW5kZXhlZFNlcSk7XG5cbiAgICBmdW5jdGlvbiBSYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgICB9XG4gICAgICBpbnZhcmlhbnQoc3RlcCAhPT0gMCwgJ0Nhbm5vdCBzdGVwIGEgUmFuZ2UgYnkgMCcpO1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLmFicyhzdGVwKTtcbiAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICBzdGVwID0gLXN0ZXA7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5fZW5kID0gZW5kO1xuICAgICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXAgLSAxKSArIDEpO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAoRU1QVFlfUkFOR0UpIHtcbiAgICAgICAgICByZXR1cm4gRU1QVFlfUkFOR0U7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkFOR0UgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmFuZ2UgWyAnICtcbiAgICAgICAgdGhpcy5fc3RhcnQgKyAnLi4uJyArIHRoaXMuX2VuZCArXG4gICAgICAgICh0aGlzLl9zdGVwICE9PSAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAnIF0nO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID9cbiAgICAgICAgdGhpcy5fc3RhcnQgKyB3cmFwSW5kZXgodGhpcywgaW5kZXgpICogdGhpcy5fc3RlcCA6XG4gICAgICAgIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgICAgcmV0dXJuIHBvc3NpYmxlSW5kZXggPj0gMCAmJlxuICAgICAgICBwb3NzaWJsZUluZGV4IDwgdGhpcy5zaXplICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleCk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSwgdGhpcy5nZXQoZW5kLCB0aGlzLl9lbmQpLCB0aGlzLl9zdGVwKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIG9mZnNldFZhbHVlID0gc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnNpemUgLSAxO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgbWF4SW5kZXggKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnNpemUgLSAxO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgbWF4SW5kZXggKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciB2ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICAgIHJldHVybiBpaSA+IG1heEluZGV4ID8gaXRlcmF0b3JEb25lKCkgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpKyssIHYpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmFuZ2UgP1xuICAgICAgICB0aGlzLl9zdGFydCA9PT0gb3RoZXIuX3N0YXJ0ICYmXG4gICAgICAgIHRoaXMuX2VuZCA9PT0gb3RoZXIuX2VuZCAmJlxuICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcCA6XG4gICAgICAgIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfTtcblxuXG4gIHZhciBFTVBUWV9SQU5HRTtcblxuICBjcmVhdGVDbGFzcyhDb2xsZWN0aW9uLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignQWJzdHJhY3QnKTtcbiAgICB9XG5cblxuICBjcmVhdGVDbGFzcyhLZXllZENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIEtleWVkQ29sbGVjdGlvbigpIHt9XG5cbiAgY3JlYXRlQ2xhc3MoSW5kZXhlZENvbGxlY3Rpb24sIENvbGxlY3Rpb24pO2Z1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKCkge31cblxuICBjcmVhdGVDbGFzcyhTZXRDb2xsZWN0aW9uLCBDb2xsZWN0aW9uKTtmdW5jdGlvbiBTZXRDb2xsZWN0aW9uKCkge31cblxuXG4gIENvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uSW5kZXhlZCA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLlNldCA9IFNldENvbGxlY3Rpb247XG5cbiAgdmFyIGltdWwgPVxuICAgIHR5cGVvZiBNYXRoLmltdWwgPT09ICdmdW5jdGlvbicgJiYgTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDIpID09PSAtMiA/XG4gICAgTWF0aC5pbXVsIDpcbiAgICBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgICAgIGEgPSBhIHwgMDsgLy8gaW50XG4gICAgICBiID0gYiB8IDA7IC8vIGludFxuICAgICAgdmFyIGMgPSBhICYgMHhmZmZmO1xuICAgICAgdmFyIGQgPSBiICYgMHhmZmZmO1xuICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgcmV0dXJuIChjICogZCkgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApIHwgMDsgLy8gaW50XG4gICAgfTtcblxuICAvLyB2OCBoYXMgYW4gb3B0aW1pemF0aW9uIGZvciBzdG9yaW5nIDMxLWJpdCBzaWduZWQgbnVtYmVycy5cbiAgLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBkcm9wcyB0aGUgaGlnaGVzdCBvcmRlciBiaXQgaW4gYSBzaWduZWQgbnVtYmVyLCBtYWludGFpbmluZ1xuICAvLyB0aGUgc2lnbiBiaXQuXG4gIGZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgICByZXR1cm4gKChpMzIgPj4+IDEpICYgMHg0MDAwMDAwMCkgfCAoaTMyICYgMHhCRkZGRkZGRik7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoKG8pIHtcbiAgICBpZiAobyA9PT0gZmFsc2UgfHwgbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbyA9IG8udmFsdWVPZigpO1xuICAgICAgaWYgKG8gPT09IGZhbHNlIHx8IG8gPT09IG51bGwgfHwgbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIG87XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAobyAhPT0gbyB8fCBvID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHZhciBoID0gbyB8IDA7XG4gICAgICBpZiAoaCAhPT0gbykge1xuICAgICAgICBoIF49IG8gKiAweEZGRkZGRkZGO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG8gPiAweEZGRkZGRkZGKSB7XG4gICAgICAgIG8gLz0gMHhGRkZGRkZGRjtcbiAgICAgICAgaCBePSBvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNtaShoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gby5sZW5ndGggPiBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID8gY2FjaGVkSGFzaFN0cmluZyhvKSA6IGhhc2hTdHJpbmcobyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby5oYXNoQ29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG8uaGFzaENvZGUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaGFzaEpTT2JqKG8pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYXNoU3RyaW5nKG8udG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdHlwZSAnICsgdHlwZSArICcgY2Fubm90IGJlIGhhc2hlZC4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlZEhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgdmFyIGhhc2ggPSBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXTtcbiAgICBpZiAoaGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICAgICAgICBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUrKztcbiAgICAgIHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddID0gaGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9oYXNoaW5nLXN0cmluZ3NcbiAgZnVuY3Rpb24gaGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG4gICAgLy8gVGhlIGhhc2ggY29kZSBmb3IgYSBzdHJpbmcgaXMgY29tcHV0ZWQgYXNcbiAgICAvLyBzWzBdICogMzEgXiAobiAtIDEpICsgc1sxXSAqIDMxIF4gKG4gLSAyKSArIC4uLiArIHNbbiAtIDFdLFxuICAgIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG4gICAgLy8gdGhlIHN0cmluZy4gV2UgXCJtb2RcIiB0aGUgcmVzdWx0IHRvIG1ha2UgaXQgYmV0d2VlbiAwIChpbmNsdXNpdmUpIGFuZCAyXjMxXG4gICAgLy8gKGV4Y2x1c2l2ZSkgYnkgZHJvcHBpbmcgaGlnaCBiaXRzLlxuICAgIHZhciBoYXNoID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgICAgaGFzaCA9IDMxICogaGFzaCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSB8IDA7XG4gICAgfVxuICAgIHJldHVybiBzbWkoaGFzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gICAgdmFyIGhhc2g7XG4gICAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgICAgaGFzaCA9IHdlYWtNYXAuZ2V0KG9iaik7XG4gICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSBvYmpbVUlEX0hBU0hfS0VZXTtcbiAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgICBpZiAoIWNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBoYXNoID0gb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldO1xuICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaGFzaCA9IGdldElFTm9kZUhhc2gob2JqKTtcbiAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaCA9ICsrb2JqSGFzaFVJRDtcbiAgICBpZiAob2JqSGFzaFVJRCAmIDB4NDAwMDAwMDApIHtcbiAgICAgIG9iakhhc2hVSUQgPSAwO1xuICAgIH1cblxuICAgIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICAgIHdlYWtNYXAuc2V0KG9iaiwgaGFzaCk7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuc2libGUgIT09IHVuZGVmaW5lZCAmJiBpc0V4dGVuc2libGUob2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBVSURfSEFTSF9LRVksIHtcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuICAgICAgICAnd3JpdGFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogaGFzaFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID09PSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKSB7XG4gICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgICAgLy8gc2F2ZSBvdXIgaGFzaCBvbiBpdC4gU2luY2UgdGhpcyBpcyBhIGZ1bmN0aW9uIGl0IHdpbGwgbm90IHNob3cgdXAgaW5cbiAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldID0gaGFzaDtcbiAgICB9IGVsc2UgaWYgKG9iai5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNvdWxkbid0IGdldCB0aGUgSUUgYHVuaXF1ZUlEYCB0byB1c2UgYXMgYSBoYXNoXG4gICAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAgIC8vIGRvbnRFbnVtIGJ1ZyBzbyB3ZSBzaW1wbHkgYWRkIHRoZSBgVUlEX0hBU0hfS0VZYCBvbiB0aGUgbm9kZVxuICAgICAgLy8gaXRzZWxmLlxuICAgICAgb2JqW1VJRF9IQVNIX0tFWV0gPSBoYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICAvLyBHZXQgcmVmZXJlbmNlcyB0byBFUzUgb2JqZWN0IG1ldGhvZHMuXG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4gIC8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxuICB2YXIgY2FuRGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KCkpO1xuXG4gIC8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcbiAgLy8gYW5kIGF2b2lkIG1lbW9yeSBsZWFrcyBmcm9tIHRoZSBJRSBjbG9uZU5vZGUgYnVnLlxuICBmdW5jdGlvbiBnZXRJRU5vZGVIYXNoKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuICAgICAgICBjYXNlIDk6IC8vIERvY3VtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnRFbGVtZW50ICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50LnVuaXF1ZUlEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxuICB2YXIgdXNpbmdXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbic7XG4gIHZhciB3ZWFrTWFwO1xuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgb2JqSGFzaFVJRCA9IDA7XG5cbiAgdmFyIFVJRF9IQVNIX0tFWSA9ICdfX2ltbXV0YWJsZWhhc2hfXyc7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG4gIH1cblxuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA9IDE2O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgdmFyIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFzc2VydE5vdEluZmluaXRlKHNpemUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBzaXplICE9PSBJbmZpbml0eSxcbiAgICAgICdDYW5ub3QgcGVyZm9ybSB0aGlzIGFjdGlvbiB3aXRoIGFuIGluZmluaXRlIHNpemUuJ1xuICAgICk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhNYXAsIEtleWVkQ29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5TWFwKCkgOlxuICAgICAgICBpc01hcCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihtYXAgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge3JldHVybiBtYXAuc2V0KGssIHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE1hcC5vZiA9IGZ1bmN0aW9uKCkge3ZhciBrZXlWYWx1ZXMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHJldHVybiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGlmIChpICsgMSA+PSBrZXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmFsdWUgZm9yIGtleTogJyArIGtleVZhbHVlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC5zZXQoa2V5VmFsdWVzW2ldLCBrZXlWYWx1ZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ01hcCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290ID9cbiAgICAgICAgdGhpcy5fcm9vdC5nZXQoMCwgdW5kZWZpbmVkLCBrLCBub3RTZXRWYWx1ZSkgOlxuICAgICAgICBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zZXRJbiA9IGZ1bmN0aW9uKGtleVBhdGgsIHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uKCkgIHtyZXR1cm4gdn0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlSW4gPSBmdW5jdGlvbihrZXlQYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihrZXlQYXRoLCBmdW5jdGlvbigpICB7cmV0dXJuIE5PVF9TRVR9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuICAgICAgICBrKHRoaXMpIDpcbiAgICAgICAgdGhpcy51cGRhdGVJbihba10sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS51cGRhdGVJbiA9IGZ1bmN0aW9uKGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgICBpZiAoIXVwZGF0ZXIpIHtcbiAgICAgICAgdXBkYXRlciA9IG5vdFNldFZhbHVlO1xuICAgICAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVkVmFsdWUgPSB1cGRhdGVJbkRlZXBNYXAoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZvcmNlSXRlcmF0b3Ioa2V5UGF0aCksXG4gICAgICAgIG5vdFNldFZhbHVlLFxuICAgICAgICB1cGRhdGVyXG4gICAgICApO1xuICAgICAgcmV0dXJuIHVwZGF0ZWRWYWx1ZSA9PT0gTk9UX1NFVCA/IHVuZGVmaW5lZCA6IHVwZGF0ZWRWYWx1ZTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgdW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgbWVyZ2VyLCBpdGVycyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKFxuICAgICAgICBrZXlQYXRoLFxuICAgICAgICBlbXB0eU1hcCgpLFxuICAgICAgICBmdW5jdGlvbihtICkge3JldHVybiB0eXBlb2YgbS5tZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgbS5tZXJnZS5hcHBseShtLCBpdGVycykgOlxuICAgICAgICAgIGl0ZXJzW2l0ZXJzLmxlbmd0aCAtIDFdfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXAgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIGRlZXBNZXJnZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b01hcFdpdGgodGhpcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcEluID0gZnVuY3Rpb24oa2V5UGF0aCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgIGVtcHR5TWFwKCksXG4gICAgICAgIGZ1bmN0aW9uKG0gKSB7cmV0dXJuIHR5cGVvZiBtLm1lcmdlRGVlcCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgbS5tZXJnZURlZXAuYXBwbHkobSwgaXRlcnMpIDpcbiAgICAgICAgICBpdGVyc1tpdGVycy5sZW5ndGggLSAxXX1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBNYXAucHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBmdW5jdGlvbihmbikge1xuICAgICAgdmFyIG11dGFibGUgPSB0aGlzLmFzTXV0YWJsZSgpO1xuICAgICAgZm4obXV0YWJsZSk7XG4gICAgICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5hc011dGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiB0aGlzLl9fZW5zdXJlT3duZXIobmV3IE93bmVySUQoKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuYXNJbW11dGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5pdGVyYXRlKGZ1bmN0aW9uKGVudHJ5ICkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMCk7XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlTWFwKHRoaXMuc2l6ZSwgdGhpcy5fcm9vdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc01hcChtYXliZU1hcCkge1xuICAgIHJldHVybiAhIShtYXliZU1hcCAmJiBtYXliZU1hcFtJU19NQVBfU0VOVElORUxdKTtcbiAgfVxuXG4gIE1hcC5pc01hcCA9IGlzTWFwO1xuXG4gIHZhciBJU19NQVBfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9NQVBfX0BAJztcblxuICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbiAgTWFwUHJvdG90eXBlW0lTX01BUF9TRU5USU5FTF0gPSB0cnVlO1xuICBNYXBQcm90b3R5cGVbREVMRVRFXSA9IE1hcFByb3RvdHlwZS5yZW1vdmU7XG4gIE1hcFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5kZWxldGVJbjtcblxuXG4gIC8vICNwcmFnbWEgVHJpZSBOb2Rlc1xuXG5cblxuICAgIGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB9XG5cbiAgICBBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBBcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgICBpZiAocmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4aXN0cyAmJiAhcmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA+PSBNQVhfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICBpZHggPT09IGxlbiAtIDEgPyBuZXdFbnRyaWVzLnBvcCgpIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEFycmF5TWFwTm9kZShvd25lcklELCBuZXdFbnRyaWVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBub2Rlcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGJpdCA9ICgxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSykpO1xuICAgICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgICAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwID8gbm90U2V0VmFsdWUgOlxuICAgICAgICB0aGlzLm5vZGVzW3BvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSldLmdldChzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKTtcbiAgICB9O1xuXG4gICAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgICB2YXIgYml0ID0gMSA8PCBrZXlIYXNoRnJhZztcbiAgICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICAgIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICAgICAgaWYgKCFleGlzdHMgJiYgdmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSBwb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG5cbiAgICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA+PSBNQVhfQklUTUFQX0lOREVYRURfU0laRSkge1xuICAgICAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhpc3RzICYmICFuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMiAmJiBpc0xlYWZOb2RlKG5vZGVzW2lkeCBeIDFdKSkge1xuICAgICAgICByZXR1cm4gbm9kZXNbaWR4IF4gMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDEgJiYgaXNMZWFmTm9kZShuZXdOb2RlKSkge1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdCaXRtYXAgPSBleGlzdHMgPyBuZXdOb2RlID8gYml0bWFwIDogYml0bWFwIF4gYml0IDogYml0bWFwIHwgYml0O1xuICAgICAgdmFyIG5ld05vZGVzID0gZXhpc3RzID8gbmV3Tm9kZSA/XG4gICAgICAgIHNldEluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpIDpcbiAgICAgICAgc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpIDpcbiAgICAgICAgc3BsaWNlSW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIG5ld0JpdG1hcCwgbmV3Tm9kZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50LCBub2Rlcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2lkeF07XG4gICAgICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgICAgfVxuICAgICAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cbiAgICAgIGlmIChyZW1vdmVkICYmICFub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuICAgICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbmV3Q291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAoIW5ld05vZGUpIHtcbiAgICAgICAgbmV3Q291bnQtLTtcbiAgICAgICAgaWYgKG5ld0NvdW50IDwgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgICAgICByZXR1cm4gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBuZXdDb3VudCwgaWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld05vZGVzID0gc2V0SW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSBuZXdDb3VudDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJpZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB9XG5cbiAgICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICAgICAgaWYgKGtleUhhc2ggIT09IHRoaXMua2V5SGFzaCkge1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICBmb3IgKHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICAgICAgaWYgKHJlbW92ZWQgJiYgbGVuID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgIGlkeCA9PT0gbGVuIC0gMSA/IG5ld0VudHJpZXMucG9wKCkgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBuZXdFbnRyaWVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBWYWx1ZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgVmFsdWVOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gICAgICB2YXIga2V5TWF0Y2ggPSBpcyhrZXksIHRoaXMuZW50cnlbMF0pO1xuICAgICAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgICAgICB0aGlzLmVudHJ5WzFdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xuICAgIH07XG5cblxuXG4gIC8vICNwcmFnbWEgSXRlcmF0b3JzXG5cbiAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID1cbiAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gbm9kZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICBpZiAobm9kZSAmJiBub2RlLml0ZXJhdGUoZm4sIHJldmVyc2UpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIGZuKHRoaXMuZW50cnkpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTWFwSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKG1hcCwgdHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICAgIHRoaXMuX3N0YWNrID0gbWFwLl9yb290ICYmIG1hcEl0ZXJhdG9yRnJhbWUobWFwLl9yb290KTtcbiAgICB9XG5cbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuICAgICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgICB3aGlsZSAoc3RhY2spIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5ub2RlO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgICB2YXIgbWF4SW5kZXg7XG4gICAgICAgIGlmIChub2RlLmVudHJ5KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIG5vZGUuZW50cmllc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heEluZGV4ID0gbm9kZS5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgdmFyIHN1Yk5vZGUgPSBub2RlLm5vZGVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBzdWJOb2RlLmVudHJ5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IHRoaXMuX3N0YWNrLl9fcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeSkge1xuICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBJdGVyYXRvckZyYW1lKG5vZGUsIHByZXYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgX19wcmV2OiBwcmV2XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VNYXAoc2l6ZSwgcm9vdCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKE1hcFByb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5fcm9vdCA9IHJvb3Q7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfTUFQO1xuICBmdW5jdGlvbiBlbXB0eU1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hcChtYXAsIGssIHYpIHtcbiAgICB2YXIgbmV3Um9vdDtcbiAgICB2YXIgbmV3U2l6ZTtcbiAgICBpZiAoIW1hcC5fcm9vdCkge1xuICAgICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSAxO1xuICAgICAgbmV3Um9vdCA9IG5ldyBBcnJheU1hcE5vZGUobWFwLl9fb3duZXJJRCwgW1trLCB2XV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoQ0hBTkdFX0xFTkdUSCk7XG4gICAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKERJRF9BTFRFUik7XG4gICAgICBuZXdSb290ID0gdXBkYXRlTm9kZShtYXAuX3Jvb3QsIG1hcC5fX293bmVySUQsIDAsIHVuZGVmaW5lZCwgaywgdiwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuICAgICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IG1hcC5zaXplICsgKGRpZENoYW5nZVNpemUudmFsdWUgPyB2ID09PSBOT1RfU0VUID8gLTEgOiAxIDogMCk7XG4gICAgfVxuICAgIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgICBtYXAuc2l6ZSA9IG5ld1NpemU7XG4gICAgICBtYXAuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld1NpemUsIG5ld1Jvb3QpIDogZW1wdHlNYXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudXBkYXRlKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jb25zdHJ1Y3RvciA9PT0gVmFsdWVOb2RlIHx8IG5vZGUuY29uc3RydWN0b3IgPT09IEhhc2hDb2xsaXNpb25Ob2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICBpZiAobm9kZS5rZXlIYXNoID09PSBrZXlIYXNoKSB7XG4gICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuICAgIH1cblxuICAgIHZhciBpZHgxID0gKHNoaWZ0ID09PSAwID8gbm9kZS5rZXlIYXNoIDogbm9kZS5rZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBpZHgyID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cbiAgICB2YXIgbmV3Tm9kZTtcbiAgICB2YXIgbm9kZXMgPSBpZHgxID09PSBpZHgyID9cbiAgICAgIFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV0gOlxuICAgICAgKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkpLCBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG5cbiAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsICgxIDw8IGlkeDEpIHwgKDEgPDwgaWR4MiksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIG93bmVySUQgPSBuZXcgT3duZXJJRCgpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlbnRyaWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpaV07XG4gICAgICBub2RlID0gbm9kZS51cGRhdGUob3duZXJJRCwgMCwgdW5kZWZpbmVkLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgY291bnQsIGV4Y2x1ZGluZykge1xuICAgIHZhciBiaXRtYXAgPSAwO1xuICAgIHZhciBwYWNrZWRJSSA9IDA7XG4gICAgdmFyIHBhY2tlZE5vZGVzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGJpdCA9IDEsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyssIGJpdCA8PD0gMSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpaV07XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIGlpICE9PSBleGNsdWRpbmcpIHtcbiAgICAgICAgYml0bWFwIHw9IGJpdDtcbiAgICAgICAgcGFja2VkTm9kZXNbcGFja2VkSUkrK10gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgcGFja2VkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZXhwYW5kZWROb2RlcyA9IG5ldyBBcnJheShTSVpFKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgICAgZXhwYW5kZWROb2Rlc1tpaV0gPSBiaXRtYXAgJiAxID8gbm9kZXNbY291bnQrK10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGV4cGFuZGVkTm9kZXNbaW5jbHVkaW5nXSA9IG5vZGU7XG4gICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50ICsgMSwgZXhwYW5kZWROb2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9NYXBXaXRoKG1hcCwgbWVyZ2VyLCBpdGVyYWJsZXMpIHtcbiAgICB2YXIgaXRlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcmFibGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVzW2lpXTtcbiAgICAgIHZhciBpdGVyID0gS2V5ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICBpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgIGl0ZXIgPSBpdGVyLm1hcChmdW5jdGlvbih2ICkge3JldHVybiBmcm9tSlModil9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJzLnB1c2goaXRlcik7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChtYXAsIG1lcmdlciwgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcE1lcmdlcihleGlzdGluZywgdmFsdWUsIGtleSkge1xuICAgIHJldHVybiBleGlzdGluZyAmJiBleGlzdGluZy5tZXJnZURlZXAgJiYgaXNJdGVyYWJsZSh2YWx1ZSkgP1xuICAgICAgZXhpc3RpbmcubWVyZ2VEZWVwKHZhbHVlKSA6XG4gICAgICBpcyhleGlzdGluZywgdmFsdWUpID8gZXhpc3RpbmcgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihleGlzdGluZywgdmFsdWUsIGtleSkgIHtcbiAgICAgIGlmIChleGlzdGluZyAmJiBleGlzdGluZy5tZXJnZURlZXBXaXRoICYmIGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZy5tZXJnZURlZXBXaXRoKG1lcmdlciwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRWYWx1ZSA9IG1lcmdlcihleGlzdGluZywgdmFsdWUsIGtleSk7XG4gICAgICByZXR1cm4gaXMoZXhpc3RpbmcsIG5leHRWYWx1ZSkgPyBleGlzdGluZyA6IG5leHRWYWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgoY29sbGVjdGlvbiwgbWVyZ2VyLCBpdGVycykge1xuICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uKHggKSB7cmV0dXJuIHguc2l6ZSAhPT0gMH0pO1xuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSAwICYmICFjb2xsZWN0aW9uLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ud2l0aE11dGF0aW9ucyhmdW5jdGlvbihjb2xsZWN0aW9uICkge1xuICAgICAgdmFyIG1lcmdlSW50b01hcCA9IG1lcmdlciA/XG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlLCBrZXkpICB7XG4gICAgICAgICAgY29sbGVjdGlvbi51cGRhdGUoa2V5LCBOT1RfU0VULCBmdW5jdGlvbihleGlzdGluZyApXG4gICAgICAgICAgICB7cmV0dXJuIGV4aXN0aW5nID09PSBOT1RfU0VUID8gdmFsdWUgOiBtZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpfVxuICAgICAgICAgICk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbih2YWx1ZSwga2V5KSAge1xuICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGl0ZXJzW2lpXS5mb3JFYWNoKG1lcmdlSW50b01hcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbkRlZXBNYXAoZXhpc3RpbmcsIGtleVBhdGhJdGVyLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHZhciBpc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuICAgIHZhciBzdGVwID0ga2V5UGF0aEl0ZXIubmV4dCgpO1xuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gaXNOb3RTZXQgPyBub3RTZXRWYWx1ZSA6IGV4aXN0aW5nO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdXBkYXRlcihleGlzdGluZ1ZhbHVlKTtcbiAgICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmdWYWx1ZSA/IGV4aXN0aW5nIDogbmV3VmFsdWU7XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGlzTm90U2V0IHx8IChleGlzdGluZyAmJiBleGlzdGluZy5zZXQpLFxuICAgICAgJ2ludmFsaWQga2V5UGF0aCdcbiAgICApO1xuICAgIHZhciBrZXkgPSBzdGVwLnZhbHVlO1xuICAgIHZhciBuZXh0RXhpc3RpbmcgPSBpc05vdFNldCA/IE5PVF9TRVQgOiBleGlzdGluZy5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICB2YXIgbmV4dFVwZGF0ZWQgPSB1cGRhdGVJbkRlZXBNYXAoXG4gICAgICBuZXh0RXhpc3RpbmcsXG4gICAgICBrZXlQYXRoSXRlcixcbiAgICAgIG5vdFNldFZhbHVlLFxuICAgICAgdXBkYXRlclxuICAgICk7XG4gICAgcmV0dXJuIG5leHRVcGRhdGVkID09PSBuZXh0RXhpc3RpbmcgPyBleGlzdGluZyA6XG4gICAgICBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVCA/IGV4aXN0aW5nLnJlbW92ZShrZXkpIDpcbiAgICAgIChpc05vdFNldCA/IGVtcHR5TWFwKCkgOiBleGlzdGluZykuc2V0KGtleSwgbmV4dFVwZGF0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ291bnQoeCkge1xuICAgIHggPSB4IC0gKCh4ID4+IDEpICYgMHg1NTU1NTU1NSk7XG4gICAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoKHggPj4gMikgJiAweDMzMzMzMzMzKTtcbiAgICB4ID0gKHggKyAoeCA+PiA0KSkgJiAweDBmMGYwZjBmO1xuICAgIHggPSB4ICsgKHggPj4gOCk7XG4gICAgeCA9IHggKyAoeCA+PiAxNik7XG4gICAgcmV0dXJuIHggJiAweDdmO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0FycmF5ID0gY2FuRWRpdCA/IGFycmF5IDogYXJyQ29weShhcnJheSk7XG4gICAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoICsgMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggKyAxID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gdmFsO1xuICAgICAgICBhZnRlciA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIGFmdGVyID0gMTtcbiAgICAgIH1cbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICB2YXIgTUFYX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG4gIHZhciBNQVhfQklUTUFQX0lOREVYRURfU0laRSA9IFNJWkUgLyAyO1xuICB2YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxuICBjcmVhdGVDbGFzcyhMaXN0LCBJbmRleGVkQ29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gTGlzdCh2YWx1ZSkge1xuICAgICAgdmFyIGVtcHR5ID0gZW1wdHlMaXN0KCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXRlciA9IEluZGV4ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHNpemUpO1xuICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICAgIHJldHVybiBtYWtlTGlzdCgwLCBzaXplLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGl0ZXIudG9BcnJheSgpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuICAgICAgICBsaXN0LnNldFNpemUoc2l6ZSk7XG4gICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2LCBpKSAge3JldHVybiBsaXN0LnNldChpLCB2KX0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgTGlzdC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdMaXN0IFsnLCAnXScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICBpbmRleCArPSB0aGlzLl9vcmlnaW47XG4gICAgICAgIHZhciBub2RlID0gbGlzdE5vZGVGb3IodGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFycmF5W2luZGV4ICYgTUFTS107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVMaXN0KHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKGluZGV4KSA/IHRoaXMgOlxuICAgICAgICBpbmRleCA9PT0gMCA/IHRoaXMuc2hpZnQoKSA6XG4gICAgICAgIGluZGV4ID09PSB0aGlzLnNpemUgLSAxID8gdGhpcy5wb3AoKSA6XG4gICAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fb3JpZ2luID0gdGhpcy5fY2FwYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5TGlzdCgpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIG9sZFNpemUgKyB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChvbGRTaXplICsgaWksIHZhbHVlc1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCAtMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIC12YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgdW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZVdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBtZXJnZXIsIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2VEZWVwID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgZGVlcE1lcmdlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlciksIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIHNpemUpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG4gICAgICAgIHJlc29sdmVFbmQoZW5kLCBzaXplKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gRE9ORSA/XG4gICAgICAgICAgaXRlcmF0b3JEb25lKCkgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaW5kZXgrKywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGluZGV4KyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlTGlzdCh0aGlzLl9vcmlnaW4sIHRoaXMuX2NhcGFjaXR5LCB0aGlzLl9sZXZlbCwgdGhpcy5fcm9vdCwgdGhpcy5fdGFpbCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc0xpc3QobWF5YmVMaXN0KSB7XG4gICAgcmV0dXJuICEhKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TRU5USU5FTF0pO1xuICB9XG5cbiAgTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbiAgdmFyIElTX0xJU1RfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9MSVNUX19AQCc7XG5cbiAgdmFyIExpc3RQcm90b3R5cGUgPSBMaXN0LnByb3RvdHlwZTtcbiAgTGlzdFByb3RvdHlwZVtJU19MSVNUX1NFTlRJTkVMXSA9IHRydWU7XG4gIExpc3RQcm90b3R5cGVbREVMRVRFXSA9IExpc3RQcm90b3R5cGUucmVtb3ZlO1xuICBMaXN0UHJvdG90eXBlLnNldEluID0gTWFwUHJvdG90eXBlLnNldEluO1xuICBMaXN0UHJvdG90eXBlLmRlbGV0ZUluID1cbiAgTGlzdFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5yZW1vdmVJbjtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGUgPSBNYXBQcm90b3R5cGUudXBkYXRlO1xuICBMaXN0UHJvdG90eXBlLnVwZGF0ZUluID0gTWFwUHJvdG90eXBlLnVwZGF0ZUluO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VJbjtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXBJbjtcbiAgTGlzdFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIExpc3RQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgTGlzdFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcbiAgTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gTWFwUHJvdG90eXBlLndhc0FsdGVyZWQ7XG5cblxuXG4gICAgZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcbiAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogc2VlbXMgbGlrZSB0aGVzZSBtZXRob2RzIGFyZSB2ZXJ5IHNpbWlsYXJcblxuICAgIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVCZWZvcmUgPSBmdW5jdGlvbihvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gbGV2ZWwgPyAxIDw8IGxldmVsIDogMCB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBvcmlnaW5JbmRleCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICAgIGlmIChvcmlnaW5JbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKFtdLCBvd25lcklEKTtcbiAgICAgIH1cbiAgICAgIHZhciByZW1vdmluZ0ZpcnN0ID0gb3JpZ2luSW5kZXggPT09IDA7XG4gICAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbb3JpZ2luSW5kZXhdO1xuICAgICAgICBuZXdDaGlsZCA9IG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUJlZm9yZShvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZpbmdGaXJzdCAmJiAhbmV3Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICAgICAgaWYgKCFyZW1vdmluZ0ZpcnN0KSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuICAgICAgICAgIGVkaXRhYmxlLmFycmF5W2lpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIGVkaXRhYmxlLmFycmF5W29yaWdpbkluZGV4XSA9IG5ld0NoaWxkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkaXRhYmxlO1xuICAgIH07XG5cbiAgICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQWZ0ZXIgPSBmdW5jdGlvbihvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gKGxldmVsID8gMSA8PCBsZXZlbCA6IDApIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHNpemVJbmRleCA9ICgoaW5kZXggLSAxKSA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICAgIGlmIChzaXplSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdDaGlsZDtcbiAgICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtzaXplSW5kZXhdO1xuICAgICAgICBuZXdDaGlsZCA9IG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUFmdGVyKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiBzaXplSW5kZXggPT09IHRoaXMuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgICBlZGl0YWJsZS5hcnJheS5zcGxpY2Uoc2l6ZUluZGV4ICsgMSk7XG4gICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgZWRpdGFibGUuYXJyYXlbc2l6ZUluZGV4XSA9IG5ld0NoaWxkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVkaXRhYmxlO1xuICAgIH07XG5cblxuXG4gIHZhciBET05FID0ge307XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUxpc3QobGlzdCwgcmV2ZXJzZSkge1xuICAgIHZhciBsZWZ0ID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciByaWdodCA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciB0YWlsUG9zID0gZ2V0VGFpbE9mZnNldChyaWdodCk7XG4gICAgdmFyIHRhaWwgPSBsaXN0Ll90YWlsO1xuXG4gICAgcmV0dXJuIGl0ZXJhdGVOb2RlT3JMZWFmKGxpc3QuX3Jvb3QsIGxpc3QuX2xldmVsLCAwKTtcblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlT3JMZWFmKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgICAgIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkgOlxuICAgICAgICBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IG9mZnNldCA9PT0gdGFpbFBvcyA/IHRhaWwgJiYgdGFpbC5hcnJheSA6IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiBsZWZ0IC0gb2Zmc2V0O1xuICAgICAgdmFyIHRvID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICAgIHRvID0gU0laRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5W2lkeF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICAgIHZhciB2YWx1ZXM7XG4gICAgICB2YXIgYXJyYXkgPSBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogKGxlZnQgLSBvZmZzZXQpID4+IGxldmVsO1xuICAgICAgdmFyIHRvID0gKChyaWdodCAtIG9mZnNldCkgPj4gbGV2ZWwpICsgMTtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBET05FKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgICB2YWx1ZXMgPSBpdGVyYXRlTm9kZU9yTGVhZihcbiAgICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sIGxldmVsIC0gU0hJRlQsIG9mZnNldCArIChpZHggPDwgbGV2ZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIGxpc3QgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUpO1xuICAgIGxpc3Quc2l6ZSA9IGNhcGFjaXR5IC0gb3JpZ2luO1xuICAgIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcbiAgICBsaXN0Ll9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIGxpc3QuX2xldmVsID0gbGV2ZWw7XG4gICAgbGlzdC5fcm9vdCA9IHJvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IHRhaWw7XG4gICAgbGlzdC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIGxpc3QuX19oYXNoID0gaGFzaDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgdmFyIEVNUFRZX0xJU1Q7XG4gIGZ1bmN0aW9uIGVtcHR5TGlzdCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXN0KGxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuICAgIGlmIChpbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBsaXN0LnNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbGlzdC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKGxpc3QgKSB7XG4gICAgICAgIGluZGV4IDwgMCA/XG4gICAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCBpbmRleCkuc2V0KDAsIHZhbHVlKSA6XG4gICAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBpbmRleCArIDEpLnNldChpbmRleCwgdmFsdWUpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmRleCArPSBsaXN0Ll9vcmlnaW47XG5cbiAgICB2YXIgbmV3VGFpbCA9IGxpc3QuX3RhaWw7XG4gICAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoRElEX0FMVEVSKTtcbiAgICBpZiAoaW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICAgIG5ld1RhaWwgPSB1cGRhdGVWTm9kZShuZXdUYWlsLCBsaXN0Ll9fb3duZXJJRCwgMCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Jvb3QgPSB1cGRhdGVWTm9kZShuZXdSb290LCBsaXN0Ll9fb3duZXJJRCwgbGlzdC5fbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgIH1cblxuICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChsaXN0Ll9vcmlnaW4sIGxpc3QuX2NhcGFjaXR5LCBsaXN0Ll9sZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVWTm9kZShub2RlLCBvd25lcklELCBsZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcikge1xuICAgIHZhciBpZHggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgdmFyIG5vZGVIYXMgPSBub2RlICYmIGlkeCA8IG5vZGUuYXJyYXkubGVuZ3RoO1xuICAgIGlmICghbm9kZUhhcyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZTtcblxuICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgIHZhciBsb3dlck5vZGUgPSBub2RlICYmIG5vZGUuYXJyYXlbaWR4XTtcbiAgICAgIHZhciBuZXdMb3dlck5vZGUgPSB1cGRhdGVWTm9kZShsb3dlck5vZGUsIG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSBuZXdMb3dlck5vZGU7XG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZUhhcyAmJiBub2RlLmFycmF5W2lkeF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWR4ID09PSBuZXdOb2RlLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIG5ld05vZGUuYXJyYXkucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCkge1xuICAgIGlmIChvd25lcklEICYmIG5vZGUgJiYgb3duZXJJRCA9PT0gbm9kZS5vd25lcklEKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlID8gbm9kZS5hcnJheS5zbGljZSgpIDogW10sIG93bmVySUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdE5vZGVGb3IobGlzdCwgcmF3SW5kZXgpIHtcbiAgICBpZiAocmF3SW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICAgIHJldHVybiBsaXN0Ll90YWlsO1xuICAgIH1cbiAgICBpZiAocmF3SW5kZXggPCAxIDw8IChsaXN0Ll9sZXZlbCArIFNISUZUKSkge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0Ll9yb290O1xuICAgICAgdmFyIGxldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgICB3aGlsZSAobm9kZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbKHJhd0luZGV4ID4+PiBsZXZlbCkgJiBNQVNLXTtcbiAgICAgICAgbGV2ZWwgLT0gU0hJRlQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMaXN0Qm91bmRzKGxpc3QsIGJlZ2luLCBlbmQpIHtcbiAgICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiZWdpbiA9IGJlZ2luIHwgMDtcbiAgICB9XG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBlbmQgfCAwO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBsaXN0Ll9fb3duZXJJRCB8fCBuZXcgT3duZXJJRCgpO1xuICAgIHZhciBvbGRPcmlnaW4gPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIG9sZENhcGFjaXR5ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIG5ld09yaWdpbiA9IG9sZE9yaWdpbiArIGJlZ2luO1xuICAgIHZhciBuZXdDYXBhY2l0eSA9IGVuZCA9PT0gdW5kZWZpbmVkID8gb2xkQ2FwYWNpdHkgOiBlbmQgPCAwID8gb2xkQ2FwYWNpdHkgKyBlbmQgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gICAgaWYgKG5ld09yaWdpbiA9PT0gb2xkT3JpZ2luICYmIG5ld0NhcGFjaXR5ID09PSBvbGRDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBnb2luZyB0byBlbmQgYWZ0ZXIgaXQgc3RhcnRzLCBpdCdzIGVtcHR5LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3Q2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0xldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gICAgLy8gTmV3IG9yaWdpbiBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgdmFyIG9mZnNldFNoaWZ0ID0gMDtcbiAgICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLCBvd25lcik7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkT3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICB9XG5cbiAgICB2YXIgb2xkVGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQob2xkQ2FwYWNpdHkpO1xuICAgIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgICAvLyBOZXcgc2l6ZSBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgd2hpbGUgKG5ld1RhaWxPZmZzZXQgPj0gMSA8PCAobmV3TGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUobmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFtuZXdSb290XSA6IFtdLCBvd25lcik7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICB9XG5cbiAgICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgICB2YXIgb2xkVGFpbCA9IGxpc3QuX3RhaWw7XG4gICAgdmFyIG5ld1RhaWwgPSBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCA/XG4gICAgICBsaXN0Tm9kZUZvcihsaXN0LCBuZXdDYXBhY2l0eSAtIDEpIDpcbiAgICAgIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ID8gbmV3IFZOb2RlKFtdLCBvd25lcikgOiBvbGRUYWlsO1xuXG4gICAgLy8gTWVyZ2UgVGFpbCBpbnRvIHRyZWUuXG4gICAgaWYgKG9sZFRhaWwgJiYgbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXQgJiYgbmV3T3JpZ2luIDwgb2xkQ2FwYWNpdHkgJiYgb2xkVGFpbC5hcnJheS5sZW5ndGgpIHtcbiAgICAgIG5ld1Jvb3QgPSBlZGl0YWJsZVZOb2RlKG5ld1Jvb3QsIG93bmVyKTtcbiAgICAgIHZhciBub2RlID0gbmV3Um9vdDtcbiAgICAgIGZvciAodmFyIGxldmVsID0gbmV3TGV2ZWw7IGxldmVsID4gU0hJRlQ7IGxldmVsIC09IFNISUZUKSB7XG4gICAgICAgIHZhciBpZHggPSAob2xkVGFpbE9mZnNldCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG4gICAgICB9XG4gICAgICBub2RlLmFycmF5WyhvbGRUYWlsT2Zmc2V0ID4+PiBTSElGVCkgJiBNQVNLXSA9IG9sZFRhaWw7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNpemUgaGFzIGJlZW4gcmVkdWNlZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgdGFpbCBuZWVkcyB0byBiZSB0cmltbWVkLlxuICAgIGlmIChuZXdDYXBhY2l0eSA8IG9sZENhcGFjaXR5KSB7XG4gICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdDYXBhY2l0eSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5ldyBvcmlnaW4gaXMgd2l0aGluIHRoZSB0YWlsLCB0aGVuIHdlIGRvIG5vdCBuZWVkIGEgcm9vdC5cbiAgICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcbiAgICAgIG5ld09yaWdpbiAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3Q2FwYWNpdHkgLT0gbmV3VGFpbE9mZnNldDtcbiAgICAgIG5ld0xldmVsID0gU0hJRlQ7XG4gICAgICBuZXdSb290ID0gbnVsbDtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQmVmb3JlKG93bmVyLCAwLCBuZXdPcmlnaW4pO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgcm9vdCBoYXMgYmVlbiB0cmltbWVkLCBnYXJiYWdlIGNvbGxlY3QuXG4gICAgfSBlbHNlIGlmIChuZXdPcmlnaW4gPiBvbGRPcmlnaW4gfHwgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgIG9mZnNldFNoaWZ0ID0gMDtcblxuICAgICAgLy8gSWRlbnRpZnkgdGhlIG5ldyB0b3Agcm9vdCBub2RlIG9mIHRoZSBzdWJ0cmVlIG9mIHRoZSBvbGQgcm9vdC5cbiAgICAgIHdoaWxlIChuZXdSb290KSB7XG4gICAgICAgIHZhciBiZWdpbkluZGV4ID0gKG5ld09yaWdpbiA+Pj4gbmV3TGV2ZWwpICYgTUFTSztcbiAgICAgICAgaWYgKGJlZ2luSW5kZXggIT09IChuZXdUYWlsT2Zmc2V0ID4+PiBuZXdMZXZlbCkgJiBNQVNLKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luSW5kZXgpIHtcbiAgICAgICAgICBvZmZzZXRTaGlmdCArPSAoMSA8PCBuZXdMZXZlbCkgKiBiZWdpbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIG5ld0xldmVsIC09IFNISUZUO1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5hcnJheVtiZWdpbkluZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpbSB0aGUgbmV3IHNpZGVzIG9mIHRoZSBuZXcgcm9vdC5cbiAgICAgIGlmIChuZXdSb290ICYmIG5ld09yaWdpbiA+IG9sZE9yaWdpbikge1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVCZWZvcmUob3duZXIsIG5ld0xldmVsLCBuZXdPcmlnaW4gLSBvZmZzZXRTaGlmdCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVBZnRlcihvd25lciwgbmV3TGV2ZWwsIG5ld1RhaWxPZmZzZXQgLSBvZmZzZXRTaGlmdCk7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgICBuZXdDYXBhY2l0eSAtPSBvZmZzZXRTaGlmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3Quc2l6ZSA9IG5ld0NhcGFjaXR5IC0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fY2FwYWNpdHkgPSBuZXdDYXBhY2l0eTtcbiAgICAgIGxpc3QuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b0xpc3RXaXRoKGxpc3QsIG1lcmdlciwgaXRlcmFibGVzKSB7XG4gICAgdmFyIGl0ZXJzID0gW107XG4gICAgdmFyIG1heFNpemUgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVyYWJsZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVyYWJsZXNbaWldO1xuICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgaWYgKGl0ZXIuc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgbWF4U2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgaXRlciA9IGl0ZXIubWFwKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZyb21KUyh2KX0pO1xuICAgICAgfVxuICAgICAgaXRlcnMucHVzaChpdGVyKTtcbiAgICB9XG4gICAgaWYgKG1heFNpemUgPiBsaXN0LnNpemUpIHtcbiAgICAgIGxpc3QgPSBsaXN0LnNldFNpemUobWF4U2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChsaXN0LCBtZXJnZXIsIGl0ZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICAgIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKChzaXplIC0gMSkgPj4+IFNISUZUKSA8PCBTSElGVCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhPcmRlcmVkTWFwLCBNYXApO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIE9yZGVyZWRNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlPcmRlcmVkTWFwKCkgOlxuICAgICAgICBpc09yZGVyZWRNYXAodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eU9yZGVyZWRNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKG1hcCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIG1hcC5zZXQoaywgdil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgT3JkZXJlZE1hcC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX21hcC5nZXQoayk7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2xpc3QuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlPcmRlcmVkTWFwKCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIHYpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrKSB7XG4gICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCkgfHwgdGhpcy5fbGlzdC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdC5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uKGVudHJ5ICkge3JldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMCl9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuZnJvbUVudHJ5U2VxKCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIHZhciBuZXdMaXN0ID0gdGhpcy5fbGlzdC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZE1hcChtYXliZU9yZGVyZWRNYXApIHtcbiAgICByZXR1cm4gaXNNYXAobWF5YmVPcmRlcmVkTWFwKSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkTWFwKTtcbiAgfVxuXG4gIE9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcbiAgT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcblxuXG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG9tYXAgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRNYXAucHJvdG90eXBlKTtcbiAgICBvbWFwLnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgb21hcC5fbWFwID0gbWFwO1xuICAgIG9tYXAuX2xpc3QgPSBsaXN0O1xuICAgIG9tYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZE1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfT1JERVJFRF9NQVAgfHwgKEVNUFRZX09SREVSRURfTUFQID0gbWFrZU9yZGVyZWRNYXAoZW1wdHlNYXAoKSwgZW1wdHlMaXN0KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU9yZGVyZWRNYXAob21hcCwgaywgdikge1xuICAgIHZhciBtYXAgPSBvbWFwLl9tYXA7XG4gICAgdmFyIGxpc3QgPSBvbWFwLl9saXN0O1xuICAgIHZhciBpID0gbWFwLmdldChrKTtcbiAgICB2YXIgaGFzID0gaSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBuZXdNYXA7XG4gICAgdmFyIG5ld0xpc3Q7XG4gICAgaWYgKHYgPT09IE5PVF9TRVQpIHsgLy8gcmVtb3ZlZFxuICAgICAgaWYgKCFoYXMpIHtcbiAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5zaXplID49IFNJWkUgJiYgbGlzdC5zaXplID49IG1hcC5zaXplICogMikge1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24oZW50cnksIGlkeCkgIHtyZXR1cm4gZW50cnkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBpZHh9KTtcbiAgICAgICAgbmV3TWFwID0gbmV3TGlzdC50b0tleWVkU2VxKCkubWFwKGZ1bmN0aW9uKGVudHJ5ICkge3JldHVybiBlbnRyeVswXX0pLmZsaXAoKS50b01hcCgpO1xuICAgICAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgICAgbmV3TGlzdCA9IGkgPT09IGxpc3Quc2l6ZSAtIDEgPyBsaXN0LnBvcCgpIDogbGlzdC5zZXQoaSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcykge1xuICAgICAgICBpZiAodiA9PT0gbGlzdC5nZXQoaSlbMV0pIHtcbiAgICAgICAgICByZXR1cm4gb21hcDtcbiAgICAgICAgfVxuICAgICAgICBuZXdNYXAgPSBtYXA7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChpLCBbaywgdl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TWFwID0gbWFwLnNldChrLCBsaXN0LnNpemUpO1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5zZXQobGlzdC5zaXplLCBbaywgdl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgIG9tYXAuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgICAgb21hcC5fbWFwID0gbmV3TWFwO1xuICAgICAgb21hcC5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICBvbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFRvS2V5ZWRTZXF1ZW5jZSwgS2V5ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIFRvS2V5ZWRTZXF1ZW5jZShpbmRleGVkLCB1c2VLZXlzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaW5kZXhlZDtcbiAgICAgIHRoaXMuX3VzZUtleXMgPSB1c2VLZXlzO1xuICAgICAgdGhpcy5zaXplID0gaW5kZXhlZC5zaXplO1xuICAgIH1cblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuZ2V0KGtleSwgbm90U2V0VmFsdWUpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaGFzKGtleSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUudmFsdWVTZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLnZhbHVlU2VxKCk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICByZXZlcnNlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSAge3JldHVybiB0aGlzJDAuX2l0ZXIudG9TZXEoKS5yZXZlcnNlKCl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgbWFwcGVkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbigpICB7cmV0dXJuIHRoaXMkMC5faXRlci50b1NlcSgpLm1hcChtYXBwZXIsIGNvbnRleHQpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGlpO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKFxuICAgICAgICB0aGlzLl91c2VLZXlzID9cbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBmbih2LCBrLCB0aGlzJDApfSA6XG4gICAgICAgICAgKChpaSA9IHJldmVyc2UgPyByZXNvbHZlU2l6ZSh0aGlzKSA6IDApLFxuICAgICAgICAgICAgZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgcmV2ZXJzZSA/IC0taWkgOiBpaSsrLCB0aGlzJDApfSksXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmICh0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHJlc29sdmVTaXplKHRoaXMpIDogMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IC0taWkgOiBpaSsrLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cblxuICBjcmVhdGVDbGFzcyhUb0luZGV4ZWRTZXF1ZW5jZSwgSW5kZXhlZFNlcSk7XG4gICAgZnVuY3Rpb24gVG9JbmRleGVkU2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDApfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlLCBzdGVwKVxuICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoVG9TZXRTZXF1ZW5jZSwgU2V0U2VxKTtcbiAgICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXMoa2V5KTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbih2ICkge3JldHVybiBmbih2LCB2LCB0aGlzJDApfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBzdGVwLnZhbHVlLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEZyb21FbnRyaWVzU2VxdWVuY2UsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBGcm9tRW50cmllc1NlcXVlbmNlKGVudHJpZXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBlbnRyaWVzO1xuICAgICAgdGhpcy5zaXplID0gZW50cmllcy5zaXplO1xuICAgIH1cblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmVudHJ5U2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci50b1NlcSgpO1xuICAgIH07XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKGVudHJ5ICkge1xuICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB2YXIgaW5kZXhlZEl0ZXJhYmxlID0gaXNJdGVyYWJsZShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgIHRoaXMkMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgICAgdmFyIGluZGV4ZWRJdGVyYWJsZSA9IGlzSXRlcmFibGUoZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gICAgY2FjaGVSZXN1bHRUaHJvdWdoO1xuXG5cbiAgZnVuY3Rpb24gZmxpcEZhY3RvcnkoaXRlcmFibGUpIHtcbiAgICB2YXIgZmxpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBmbGlwU2VxdWVuY2UuX2l0ZXIgPSBpdGVyYWJsZTtcbiAgICBmbGlwU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG4gICAgZmxpcFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlfTtcbiAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gaXRlcmFibGUucmV2ZXJzZS5hcHBseSh0aGlzKTsgLy8gc3VwZXIucmV2ZXJzZSgpXG4gICAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLnJldmVyc2UoKX07XG4gICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgICB9O1xuICAgIGZsaXBTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKSB7cmV0dXJuIGl0ZXJhYmxlLmluY2x1ZGVzKGtleSl9O1xuICAgIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKGtleSApIHtyZXR1cm4gaXRlcmFibGUuaGFzKGtleSl9O1xuICAgIGZsaXBTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZm4oaywgdiwgdGhpcyQwKSAhPT0gZmFsc2V9LCByZXZlcnNlKTtcbiAgICB9XG4gICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBrID0gc3RlcC52YWx1ZVswXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuICAgICAgICAgICAgc3RlcC52YWx1ZVsxXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdG9yKFxuICAgICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBtYXBGYWN0b3J5KGl0ZXJhYmxlLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIG1hcHBlZFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuICAgIG1hcHBlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApIHtyZXR1cm4gaXRlcmFibGUuaGFzKGtleSl9O1xuICAgIG1hcHBlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpICB7XG4gICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgPT09IE5PVF9TRVQgP1xuICAgICAgICBub3RTZXRWYWx1ZSA6XG4gICAgICAgIG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGtleSwgaXRlcmFibGUpO1xuICAgIH07XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uKHYsIGssIGMpICB7cmV0dXJuIGZuKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGMpLCBrLCB0aGlzJDApICE9PSBmYWxzZX0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1hcHBlci5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBrZXksIGl0ZXJhYmxlKSxcbiAgICAgICAgICBzdGVwXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiByZXZlcnNlRmFjdG9yeShpdGVyYWJsZSwgdXNlS2V5cykge1xuICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9pdGVyID0gaXRlcmFibGU7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlfTtcbiAgICBpZiAoaXRlcmFibGUuZmxpcCkge1xuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmxpcFNlcXVlbmNlID0gZmxpcEZhY3RvcnkoaXRlcmFibGUpO1xuICAgICAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGUuZmxpcCgpfTtcbiAgICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgXG4gICAgICB7cmV0dXJuIGl0ZXJhYmxlLmdldCh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXksIG5vdFNldFZhbHVlKX07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKVxuICAgICAge3JldHVybiBpdGVyYWJsZS5oYXModXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5KX07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpdGVyYWJsZS5pbmNsdWRlcyh2YWx1ZSl9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZm4odiwgaywgdGhpcyQwKX0sICFyZXZlcnNlKTtcbiAgICB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9XG4gICAgICBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSAge3JldHVybiBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsICFyZXZlcnNlKX07XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZpbHRlckZhY3RvcnkoaXRlcmFibGUsIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICAgIHZhciBmaWx0ZXJTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgaWYgKHVzZUtleXMpIHtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uKGtleSApIHtcbiAgICAgICAgdmFyIHYgPSBpdGVyYWJsZS5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGl0ZXJhYmxlKTtcbiAgICAgIH07XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSAge1xuICAgICAgICB2YXIgdiA9IGl0ZXJhYmxlLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGl0ZXJhYmxlKSA/XG4gICAgICAgICAgdiA6IG5vdFNldFZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBpdGVyYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBrZXkgOiBpdGVyYXRpb25zKyssIHZhbHVlLCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNvdW50QnlGYWN0b3J5KGl0ZXJhYmxlLCBncm91cGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGdyb3VwcyA9IE1hcCgpLmFzTXV0YWJsZSgpO1xuICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgZ3JvdXBzLnVwZGF0ZShcbiAgICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSxcbiAgICAgICAgMCxcbiAgICAgICAgZnVuY3Rpb24oYSApIHtyZXR1cm4gYSArIDF9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZ3JvdXBCeUZhY3RvcnkoaXRlcmFibGUsIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChpdGVyYWJsZSkgPyBPcmRlcmVkTWFwKCkgOiBNYXAoKSkuYXNNdXRhYmxlKCk7XG4gICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICBncm91cHMudXBkYXRlKFxuICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpLFxuICAgICAgICBmdW5jdGlvbihhICkge3JldHVybiAoYSA9IGEgfHwgW10sIGEucHVzaChpc0tleWVkSXRlciA/IFtrLCB2XSA6IHYpLCBhKX1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgdmFyIGNvZXJjZSA9IGl0ZXJhYmxlQ2xhc3MoaXRlcmFibGUpO1xuICAgIHJldHVybiBncm91cHMubWFwKGZ1bmN0aW9uKGFyciApIHtyZXR1cm4gcmVpZnkoaXRlcmFibGUsIGNvZXJjZShhcnIpKX0pO1xuICB9XG5cblxuICBmdW5jdGlvbiBzbGljZUZhY3RvcnkoaXRlcmFibGUsIGJlZ2luLCBlbmQsIHVzZUtleXMpIHtcbiAgICB2YXIgb3JpZ2luYWxTaXplID0gaXRlcmFibGUuc2l6ZTtcblxuICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJlZ2luID0gYmVnaW4gfCAwO1xuICAgIH1cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGVuZCA9IG9yaWdpbmFsU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IGVuZCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgb3JpZ2luYWxTaXplKSkge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCBvcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gYmVnaW4gb3IgZW5kIHdpbGwgYmUgTmFOIGlmIHRoZXkgd2VyZSBwcm92aWRlZCBhcyBuZWdhdGl2ZSBudW1iZXJzIGFuZFxuICAgIC8vIHRoaXMgaXRlcmFibGUncyBzaXplIGlzIHVua25vd24uIEluIHRoYXQgY2FzZSwgY2FjaGUgZmlyc3Qgc28gdGhlcmUgaXNcbiAgICAvLyBhIGtub3duIHNpemUgYW5kIHRoZXNlIGRvIG5vdCByZXNvbHZlIHRvIE5hTi5cbiAgICBpZiAocmVzb2x2ZWRCZWdpbiAhPT0gcmVzb2x2ZWRCZWdpbiB8fCByZXNvbHZlZEVuZCAhPT0gcmVzb2x2ZWRFbmQpIHtcbiAgICAgIHJldHVybiBzbGljZUZhY3RvcnkoaXRlcmFibGUudG9TZXEoKS5jYWNoZVJlc3VsdCgpLCBiZWdpbiwgZW5kLCB1c2VLZXlzKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgICAvLyB1bmtub3duIGFuZCB0aGlzIHNsaWNlIGRpZCBub3Qgc3VwcGx5IGFuIGVuZCBhbmQgc2hvdWxkIGNvbnRhaW4gYWxsXG4gICAgLy8gZWxlbWVudHMgYWZ0ZXIgcmVzb2x2ZWRCZWdpbi5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgICB2YXIgcmVzb2x2ZWRTaXplID0gcmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBzbGljZVNpemU7XG4gICAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgICBzbGljZVNpemUgPSByZXNvbHZlZFNpemUgPCAwID8gMCA6IHJlc29sdmVkU2l6ZTtcbiAgICB9XG5cbiAgICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuXG4gICAgLy8gSWYgaXRlcmFibGUuc2l6ZSBpcyB1bmRlZmluZWQsIHRoZSBzaXplIG9mIHRoZSByZWFsaXplZCBzbGljZVNlcSBpc1xuICAgIC8vIHVua25vd24gYXQgdGhpcyBwb2ludCB1bmxlc3MgdGhlIG51bWJlciBvZiBpdGVtcyB0byBzbGljZSBpcyAwXG4gICAgc2xpY2VTZXEuc2l6ZSA9IHNsaWNlU2l6ZSA9PT0gMCA/IHNsaWNlU2l6ZSA6IGl0ZXJhYmxlLnNpemUgJiYgc2xpY2VTaXplIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmICghdXNlS2V5cyAmJiBpc1NlcShpdGVyYWJsZSkgJiYgc2xpY2VTaXplID49IDApIHtcbiAgICAgIHNsaWNlU2VxLmdldCA9IGZ1bmN0aW9uIChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHNsaWNlU2l6ZSA/XG4gICAgICAgICAgaXRlcmFibGUuZ2V0KGluZGV4ICsgcmVzb2x2ZWRCZWdpbiwgbm90U2V0VmFsdWUpIDpcbiAgICAgICAgICBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzbGljZVNlcS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMCkgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMgIT09IHNsaWNlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHNsaWNlU2l6ZSAhPT0gMCAmJiByZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGJvdGhlciBpbnN0YW50aWF0aW5nIHBhcmVudCBpdGVyYXRvciBpZiB0YWtpbmcgMC5cbiAgICAgIHZhciBpdGVyYXRvciA9IHNsaWNlU2l6ZSAhPT0gMCAmJiBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHdoaWxlIChza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSB7XG4gICAgICAgICAgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPiBzbGljZVNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpY2VTZXE7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHRha2VXaGlsZUZhY3RvcnkoaXRlcmFibGUsIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciB0YWtlU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgXG4gICAgICAgIHtyZXR1cm4gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykgJiYgKytpdGVyYXRpb25zICYmIGZuKHYsIGssIHRoaXMkMCl9XG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKCFpdGVyYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIgayA9IGVudHJ5WzBdO1xuICAgICAgICB2YXIgdiA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMCkpIHtcbiAgICAgICAgICBpdGVyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB0YWtlU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoaXRlcmFibGUsIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICAgIHZhciBza2lwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAsIGssIHY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBrID0gZW50cnlbMF07XG4gICAgICAgICAgdiA9IGVudHJ5WzFdO1xuICAgICAgICAgIHNraXBwaW5nICYmIChza2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMCkpO1xuICAgICAgICB9IHdoaWxlIChza2lwcGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2tpcFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBjb25jYXRGYWN0b3J5KGl0ZXJhYmxlLCB2YWx1ZXMpIHtcbiAgICB2YXIgaXNLZXllZEl0ZXJhYmxlID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGl0ZXJzID0gW2l0ZXJhYmxlXS5jb25jYXQodmFsdWVzKS5tYXAoZnVuY3Rpb24odiApIHtcbiAgICAgIGlmICghaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICB2ID0gaXNLZXllZEl0ZXJhYmxlID9cbiAgICAgICAgICBrZXllZFNlcUZyb21WYWx1ZSh2KSA6XG4gICAgICAgICAgaW5kZXhlZFNlcUZyb21WYWx1ZShBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XSk7XG4gICAgICB9IGVsc2UgaWYgKGlzS2V5ZWRJdGVyYWJsZSkge1xuICAgICAgICB2ID0gS2V5ZWRJdGVyYWJsZSh2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbih2ICkge3JldHVybiB2LnNpemUgIT09IDB9KTtcblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICB9XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgICBpZiAoc2luZ2xldG9uID09PSBpdGVyYWJsZSB8fFxuICAgICAgICAgIGlzS2V5ZWRJdGVyYWJsZSAmJiBpc0tleWVkKHNpbmdsZXRvbikgfHxcbiAgICAgICAgICBpc0luZGV4ZWQoaXRlcmFibGUpICYmIGlzSW5kZXhlZChzaW5nbGV0b24pKSB7XG4gICAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gICAgaWYgKGlzS2V5ZWRJdGVyYWJsZSkge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvS2V5ZWRTZXEoKTtcbiAgICB9IGVsc2UgaWYgKCFpc0luZGV4ZWQoaXRlcmFibGUpKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9TZXRTZXEoKTtcbiAgICB9XG4gICAgY29uY2F0U2VxID0gY29uY2F0U2VxLmZsYXR0ZW4odHJ1ZSk7XG4gICAgY29uY2F0U2VxLnNpemUgPSBpdGVycy5yZWR1Y2UoXG4gICAgICBmdW5jdGlvbihzdW0sIHNlcSkgIHtcbiAgICAgICAgaWYgKHN1bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBzZXEuc2l6ZTtcbiAgICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAwXG4gICAgKTtcbiAgICByZXR1cm4gY29uY2F0U2VxO1xuICB9XG5cblxuICBmdW5jdGlvbiBmbGF0dGVuRmFjdG9yeShpdGVyYWJsZSwgZGVwdGgsIHVzZUtleXMpIHtcbiAgICB2YXIgZmxhdFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBmbGF0U2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIGZsYXREZWVwKGl0ZXIsIGN1cnJlbnREZXB0aCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICAgIGlmICgoIWRlcHRoIHx8IGN1cnJlbnREZXB0aCA8IGRlcHRoKSAmJiBpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgICAgICBmbGF0RGVlcCh2LCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucysrLCB0aGlzJDApID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhc3RvcHBlZDtcbiAgICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICBmbGF0RGVlcChpdGVyYWJsZSwgMCk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3IpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdiA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoIWRlcHRoIHx8IHN0YWNrLmxlbmd0aCA8IGRlcHRoKSAmJiBpc0l0ZXJhYmxlKHYpKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gdi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlS2V5cyA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdiwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmxhdFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShpdGVyYWJsZSwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGNvZXJjZSA9IGl0ZXJhYmxlQ2xhc3MoaXRlcmFibGUpO1xuICAgIHJldHVybiBpdGVyYWJsZS50b1NlcSgpLm1hcChcbiAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSkpfVxuICAgICkuZmxhdHRlbih0cnVlKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gaW50ZXJwb3NlRmFjdG9yeShpdGVyYWJsZSwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIGludGVycG9zZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplICYmIGl0ZXJhYmxlLnNpemUgKiAyIC0xO1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgXG4gICAgICAgIHtyZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDApICE9PSBmYWxzZSkgJiZcbiAgICAgICAgZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDApICE9PSBmYWxzZX0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmICghc3RlcCB8fCBpdGVyYXRpb25zICUgMikge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRpb25zICUgMiA/XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcikgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGludGVycG9zZWRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc29ydEZhY3RvcnkoaXRlcmFibGUsIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICB2YXIgaXNLZXllZEl0ZXJhYmxlID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cmllcyA9IGl0ZXJhYmxlLnRvU2VxKCkubWFwKFxuICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gW2ssIHYsIGluZGV4KyssIG1hcHBlciA/IG1hcHBlcih2LCBrLCBpdGVyYWJsZSkgOiB2XX1cbiAgICApLnRvQXJyYXkoKTtcbiAgICBlbnRyaWVzLnNvcnQoZnVuY3Rpb24oYSwgYikgIHtyZXR1cm4gY29tcGFyYXRvcihhWzNdLCBiWzNdKSB8fCBhWzJdIC0gYlsyXX0pLmZvckVhY2goXG4gICAgICBpc0tleWVkSXRlcmFibGUgP1xuICAgICAgZnVuY3Rpb24odiwgaSkgIHsgZW50cmllc1tpXS5sZW5ndGggPSAyOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHYsIGkpICB7IGVudHJpZXNbaV0gPSB2WzFdOyB9XG4gICAgKTtcbiAgICByZXR1cm4gaXNLZXllZEl0ZXJhYmxlID8gS2V5ZWRTZXEoZW50cmllcykgOlxuICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSA/IEluZGV4ZWRTZXEoZW50cmllcykgOlxuICAgICAgU2V0U2VxKGVudHJpZXMpO1xuICB9XG5cblxuICBmdW5jdGlvbiBtYXhGYWN0b3J5KGl0ZXJhYmxlLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKG1hcHBlcikge1xuICAgICAgdmFyIGVudHJ5ID0gaXRlcmFibGUudG9TZXEoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIFt2LCBtYXBwZXIodiwgaywgaXRlcmFibGUpXX0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikgIHtyZXR1cm4gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhWzFdLCBiWzFdKSA/IGIgOiBhfSk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikgIHtyZXR1cm4gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSA/IGIgOiBhfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XG4gICAgdmFyIGNvbXAgPSBjb21wYXJhdG9yKGIsIGEpO1xuICAgIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcbiAgICAvLyB0aGV5IGFyZSBub3QgZXF1YWwgYW5kIGIgaXMgaW4gZmFjdCBhIG51bGxpc2ggdmFsdWUuXG4gICAgcmV0dXJuIChjb21wID09PSAwICYmIGIgIT09IGEgJiYgKGIgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgIT09IGIpKSB8fCBjb21wID4gMDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gemlwV2l0aEZhY3Rvcnkoa2V5SXRlciwgemlwcGVyLCBpdGVycykge1xuICAgIHZhciB6aXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShrZXlJdGVyKTtcbiAgICB6aXBTZXF1ZW5jZS5zaXplID0gbmV3IEFycmF5U2VxKGl0ZXJzKS5tYXAoZnVuY3Rpb24oaSApIHtyZXR1cm4gaS5zaXplfSkubWluKCk7XG4gICAgLy8gTm90ZTogdGhpcyBhIGdlbmVyaWMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBfX2l0ZXJhdGUgaW4gdGVybXMgb2ZcbiAgICAvLyBfX2l0ZXJhdG9yIHdoaWNoIG1heSBiZSBtb3JlIGdlbmVyaWNhbGx5IHVzZWZ1bCBpbiB0aGUgZnV0dXJlLlxuICAgIHppcFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICAvKiBnZW5lcmljOlxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZVsxXSwgc3RlcC52YWx1ZVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgICAgKi9cbiAgICAgIC8vIGluZGV4ZWQ6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHppcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24oaSApXG4gICAgICAgIHtyZXR1cm4gKGkgPSBJdGVyYWJsZShpKSwgZ2V0SXRlcmF0b3IocmV2ZXJzZSA/IGkucmV2ZXJzZSgpIDogaSkpfVxuICAgICAgKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcHM7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgc3RlcHMgPSBpdGVyYXRvcnMubWFwKGZ1bmN0aW9uKGkgKSB7cmV0dXJuIGkubmV4dCgpfSk7XG4gICAgICAgICAgaXNEb25lID0gc3RlcHMuc29tZShmdW5jdGlvbihzICkge3JldHVybiBzLmRvbmV9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaXRlcmF0aW9ucysrLFxuICAgICAgICAgIHppcHBlci5hcHBseShudWxsLCBzdGVwcy5tYXAoZnVuY3Rpb24ocyApIHtyZXR1cm4gcy52YWx1ZX0pKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gemlwU2VxdWVuY2VcbiAgfVxuXG5cbiAgLy8gI3ByYWdtYSBIZWxwZXIgRnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gcmVpZnkoaXRlciwgc2VxKSB7XG4gICAgcmV0dXJuIGlzU2VxKGl0ZXIpID8gc2VxIDogaXRlci5jb25zdHJ1Y3RvcihzZXEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVFbnRyeShlbnRyeSkge1xuICAgIGlmIChlbnRyeSAhPT0gT2JqZWN0KGVudHJ5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTaXplKGl0ZXIpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgIHJldHVybiBlbnN1cmVTaXplKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmFibGVDbGFzcyhpdGVyYWJsZSkge1xuICAgIHJldHVybiBpc0tleWVkKGl0ZXJhYmxlKSA/IEtleWVkSXRlcmFibGUgOlxuICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSA/IEluZGV4ZWRJdGVyYWJsZSA6XG4gICAgICBTZXRJdGVyYWJsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VTZXF1ZW5jZShpdGVyYWJsZSkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgICAgKFxuICAgICAgICBpc0tleWVkKGl0ZXJhYmxlKSA/IEtleWVkU2VxIDpcbiAgICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSA/IEluZGV4ZWRTZXEgOlxuICAgICAgICBTZXRTZXFcbiAgICAgICkucHJvdG90eXBlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlUmVzdWx0VGhyb3VnaCgpIHtcbiAgICBpZiAodGhpcy5faXRlci5jYWNoZVJlc3VsdCkge1xuICAgICAgdGhpcy5faXRlci5jYWNoZVJlc3VsdCgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5faXRlci5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlSXRlcmF0b3Ioa2V5UGF0aCkge1xuICAgIHZhciBpdGVyID0gZ2V0SXRlcmF0b3Ioa2V5UGF0aCk7XG4gICAgaWYgKCFpdGVyKSB7XG4gICAgICAvLyBBcnJheSBtaWdodCBub3QgYmUgaXRlcmFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCwgc28gd2UgbmVlZCBhIGZhbGxiYWNrXG4gICAgICAvLyB0byBvdXIgd3JhcHBlZCB0eXBlLlxuICAgICAgaWYgKCFpc0FycmF5TGlrZShrZXlQYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBpdGVyYWJsZSBvciBhcnJheS1saWtlOiAnICsga2V5UGF0aCk7XG4gICAgICB9XG4gICAgICBpdGVyID0gZ2V0SXRlcmF0b3IoSXRlcmFibGUoa2V5UGF0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlcjtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJlY29yZCwgS2V5ZWRDb2xsZWN0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFJlY29yZChkZWZhdWx0VmFsdWVzLCBuYW1lKSB7XG4gICAgICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgICAgIHZhciBSZWNvcmRUeXBlID0gZnVuY3Rpb24gUmVjb3JkKHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRUeXBlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgICAgIGhhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuICAgICAgICAgIHNldFByb3BzKFJlY29yZFR5cGVQcm90b3R5cGUsIGtleXMpO1xuICAgICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX25hbWUgPSBuYW1lO1xuICAgICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2tleXMgPSBrZXlzO1xuICAgICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcCA9IE1hcCh2YWx1ZXMpO1xuICAgICAgfTtcblxuICAgICAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSBSZWNvcmRUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb3JkUHJvdG90eXBlKTtcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWNvcmRUeXBlO1xuXG4gICAgICByZXR1cm4gUmVjb3JkVHlwZTtcbiAgICB9XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKHJlY29yZE5hbWUodGhpcykgKyAnIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRWYWx1ZXNba107XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID8gdGhpcy5fbWFwLmdldChrLCBkZWZhdWx0VmFsKSA6IGRlZmF1bHRWYWw7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBSZWNvcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBSZWNvcmRUeXBlID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBSZWNvcmRUeXBlLl9lbXB0eSB8fCAoUmVjb3JkVHlwZS5fZW1wdHkgPSBtYWtlUmVjb3JkKHRoaXMsIGVtcHR5TWFwKCkpKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCB1bmtub3duIGtleSBcIicgKyBrICsgJ1wiIG9uICcgKyByZWNvcmROYW1lKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5oYXMoaykpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWwgPSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdO1xuICAgICAgICBpZiAodiA9PT0gZGVmYXVsdFZhbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5zZXQoaywgdik7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQgfHwgbmV3TWFwID09PSB0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXApO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwICYmIHRoaXMuX21hcC5yZW1vdmUoayk7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQgfHwgbmV3TWFwID09PSB0aGlzLl9tYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXApO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gS2V5ZWRJdGVyYWJsZSh0aGlzLl9kZWZhdWx0VmFsdWVzKS5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gdGhpcyQwLmdldChrKX0pLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiBLZXllZEl0ZXJhYmxlKHRoaXMuX2RlZmF1bHRWYWx1ZXMpLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiB0aGlzJDAuZ2V0KGspfSkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdNYXAsIG93bmVySUQpO1xuICAgIH07XG5cblxuICB2YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcbiAgUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuICBSZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPVxuICBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUucmVtb3ZlSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5tZXJnZTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlV2l0aCA9IE1hcFByb3RvdHlwZS5tZXJnZVdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZUluID0gTWFwUHJvdG90eXBlLm1lcmdlSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXAgPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IE1hcFByb3RvdHlwZS5tZXJnZURlZXBXaXRoO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW47XG4gIFJlY29yZFByb3RvdHlwZS5zZXRJbiA9IE1hcFByb3RvdHlwZS5zZXRJbjtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZSA9IE1hcFByb3RvdHlwZS51cGRhdGU7XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGVJbiA9IE1hcFByb3RvdHlwZS51cGRhdGVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIFJlY29yZFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcblxuXG4gIGZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgbWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHJlY29yZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGxpa2VSZWNvcmQpKTtcbiAgICByZWNvcmQuX21hcCA9IG1hcDtcbiAgICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLl9uYW1lIHx8IHJlY29yZC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdSZWNvcmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcHMocHJvdG90eXBlLCBuYW1lcykge1xuICAgIHRyeSB7XG4gICAgICBuYW1lcy5mb3JFYWNoKHNldFByb3AuYmluZCh1bmRlZmluZWQsIHByb3RvdHlwZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZmFpbGVkLiBQcm9iYWJseSBJRTguXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcChwcm90b3R5cGUsIG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFNldCwgU2V0Q29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2V0KCkgOlxuICAgICAgICBpc1NldCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiApIHtyZXR1cm4gc2V0LmFkZCh2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBTZXQub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXQuZnJvbUtleXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRJdGVyYWJsZSh2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5zZXQodmFsdWUsIHRydWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAucmVtb3ZlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLmNsZWFyKCkpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbih4ICkge3JldHVybiB4LnNpemUgIT09IDB9KTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBTZXRJdGVyYWJsZShpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHNldC5hZGQodmFsdWUpfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIFNldEl0ZXJhYmxlKGl0ZXIpfSk7XG4gICAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbihzZXQgKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG4gICAgICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbihpdGVyICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pKSB7XG4gICAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpdGVyICkge3JldHVybiBTZXRJdGVyYWJsZShpdGVyKX0pO1xuICAgICAgdmFyIG9yaWdpbmFsU2V0ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICBvcmlnaW5hbFNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuICAgICAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uKGl0ZXIgKSB7cmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpfSkpIHtcbiAgICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5pb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5tZXJnZVdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uLmFwcGx5KHRoaXMsIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0ZShmdW5jdGlvbihfLCBrKSAge3JldHVybiBmbihrLCBrLCB0aGlzJDApfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAubWFwKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIGt9KS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19tYWtlKG5ld01hcCwgb3duZXJJRCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gICAgcmV0dXJuICEhKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TRU5USU5FTF0pO1xuICB9XG5cbiAgU2V0LmlzU2V0ID0gaXNTZXQ7XG5cbiAgdmFyIElTX1NFVF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX1NFVF9fQEAnO1xuXG4gIHZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuICBTZXRQcm90b3R5cGVbSVNfU0VUX1NFTlRJTkVMXSA9IHRydWU7XG4gIFNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlRGVlcCA9IFNldFByb3RvdHlwZS5tZXJnZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBTZXRQcm90b3R5cGUubWVyZ2VXaXRoO1xuICBTZXRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlO1xuXG4gIFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG4gIFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlU2V0O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNldChzZXQsIG5ld01hcCkge1xuICAgIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgICBzZXQuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgICAgc2V0Ll9tYXAgPSBuZXdNYXA7XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWFwID09PSBzZXQuX21hcCA/IHNldCA6XG4gICAgICBuZXdNYXAuc2l6ZSA9PT0gMCA/IHNldC5fX2VtcHR5KCkgOlxuICAgICAgc2V0Ll9fbWFrZShuZXdNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNldChtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfU0VUO1xuICBmdW5jdGlvbiBlbXB0eVNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VUIHx8IChFTVBUWV9TRVQgPSBtYWtlU2V0KGVtcHR5TWFwKCkpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE9yZGVyZWRTZXQsIFNldCk7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU9yZGVyZWRTZXQoKSA6XG4gICAgICAgIGlzT3JkZXJlZFNldCh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICAgIHZhciBpdGVyID0gU2V0SXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHNldC5hZGQodil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRJdGVyYWJsZSh2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZFNldCB7JywgJ30nKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICAgIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xuICB9XG5cbiAgT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cbiAgdmFyIE9yZGVyZWRTZXRQcm90b3R5cGUgPSBPcmRlcmVkU2V0LnByb3RvdHlwZTtcbiAgT3JkZXJlZFNldFByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG5cbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfT1JERVJFRF9TRVQgfHwgKEVNUFRZX09SREVSRURfU0VUID0gbWFrZU9yZGVyZWRTZXQoZW1wdHlPcmRlcmVkTWFwKCkpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFN0YWNrLCBJbmRleGVkQ29sbGVjdGlvbik7XG5cbiAgICAvLyBAcHJhZ21hIENvbnN0cnVjdGlvblxuXG4gICAgZnVuY3Rpb24gU3RhY2sodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTdGFjaygpIDpcbiAgICAgICAgaXNTdGFjayh2YWx1ZSkgPyB2YWx1ZSA6XG4gICAgICAgIGVtcHR5U3RhY2soKS51bnNoaWZ0QWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICBTdGFjay5vZiA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiBhcmd1bWVudHNbaWldLFxuICAgICAgICAgIG5leHQ6IGhlYWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUoaXRlcik7XG4gICAgICBpZiAoaXRlci5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgaXRlci5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtcbiAgICAgICAgbmV3U2l6ZSsrO1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuZXh0OiBoZWFkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS51bnNoaWZ0QWxsID0gZnVuY3Rpb24oaXRlcikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaEFsbChpdGVyKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAocmVzb2x2ZWRFbmQgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKHJlc29sdmVkQmVnaW4tLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5fX2l0ZXJhdGUoZm4pO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGZuKG5vZGUudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5fX2l0ZXJhdG9yKHR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc1N0YWNrKG1heWJlU3RhY2spIHtcbiAgICByZXR1cm4gISEobWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NFTlRJTkVMXSk7XG4gIH1cblxuICBTdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxuICB2YXIgSVNfU1RBQ0tfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9TVEFDS19fQEAnO1xuXG4gIHZhciBTdGFja1Byb3RvdHlwZSA9IFN0YWNrLnByb3RvdHlwZTtcbiAgU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU0VOVElORUxdID0gdHJ1ZTtcbiAgU3RhY2tQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBTdGFja1Byb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcbiAgU3RhY2tQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xuXG5cbiAgZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShTdGFja1Byb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5faGVhZCA9IGhlYWQ7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfU1RBQ0s7XG4gIGZ1bmN0aW9uIGVtcHR5U3RhY2soKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udHJpYnV0ZXMgYWRkaXRpb25hbCBtZXRob2RzIHRvIGEgY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKGN0b3IsIG1ldGhvZHMpIHtcbiAgICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24oa2V5ICkgeyBjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldOyB9O1xuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICByZXR1cm4gY3RvcjtcbiAgfVxuXG4gIEl0ZXJhYmxlLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbiAgbWl4aW4oSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5zaXplIHx8IDApO1xuICAgICAgdGhpcy52YWx1ZVNlcSgpLl9faXRlcmF0ZShmdW5jdGlvbih2LCBpKSAgeyBhcnJheVtpXSA9IHY7IH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICB0b0luZGV4ZWRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9KUzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChcbiAgICAgICAgZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9KUygpIDogdmFsdWV9XG4gICAgICApLl9fdG9KUygpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9KU09OKCkgOiB2YWx1ZX1cbiAgICAgICkuX190b0pTKCk7XG4gICAgfSxcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHRvTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHsgb2JqZWN0W2tdID0gdjsgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb1NldFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHRoaXMpID8gdGhpcy50b0luZGV4ZWRTZXEoKSA6XG4gICAgICAgIGlzS2V5ZWQodGhpcykgPyB0aGlzLnRvS2V5ZWRTZXEoKSA6XG4gICAgICAgIHRoaXMudG9TZXRTZXEoKTtcbiAgICB9LFxuXG4gICAgdG9TdGFjazogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0xpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIExpc3QoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBDb21tb24gSmF2YVNjcmlwdCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJ1tJdGVyYWJsZV0nO1xuICAgIH0sXG5cbiAgICBfX3RvU3RyaW5nOiBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkICsgJyAnICsgdGhpcy50b1NlcSgpLm1hcCh0aGlzLl9fdG9TdHJpbmdNYXBwZXIpLmpvaW4oJywgJykgKyAnICcgKyB0YWlsO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGNvbmNhdDogZnVuY3Rpb24oKSB7dmFyIHZhbHVlcyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKX0pO1xuICAgIH0sXG5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgICB9LFxuXG4gICAgZXZlcnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihzaWRlRWZmZWN0LCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlKGNvbnRleHQgPyBzaWRlRWZmZWN0LmJpbmQoY29udGV4dCkgOiBzaWRlRWZmZWN0KTtcbiAgICB9LFxuXG4gICAgam9pbjogZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyAnJyArIHNlcGFyYXRvciA6ICcsJztcbiAgICAgIHZhciBqb2luZWQgPSAnJztcbiAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYgKSB7XG4gICAgICAgIGlzRmlyc3QgPyAoaXNGaXJzdCA9IGZhbHNlKSA6IChqb2luZWQgKz0gc2VwYXJhdG9yKTtcbiAgICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfSxcblxuICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0tFWVMpO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHJlZHVjZTogZnVuY3Rpb24ocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciByZWR1Y3Rpb247XG4gICAgICB2YXIgdXNlRmlyc3Q7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdXNlRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWN0aW9uID0gaW5pdGlhbFJlZHVjdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmICh1c2VGaXJzdCkge1xuICAgICAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgcmVkdWN0aW9uID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVkdWN0aW9uO1xuICAgIH0sXG5cbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24ocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHJldmVyc2VkID0gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpO1xuICAgICAgcmV0dXJuIHJldmVyc2VkLnJlZHVjZS5hcHBseShyZXZlcnNlZCwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNvbWU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuICF0aGlzLmV2ZXJ5KG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc29ydDogZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9LFxuXG4gICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgYnV0TGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCAtMSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5zaXplID09PSAwIDogIXRoaXMuc29tZShmdW5jdGlvbigpICB7cmV0dXJuIHRydWV9KTtcbiAgICB9LFxuXG4gICAgY291bnQ6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGVuc3VyZVNpemUoXG4gICAgICAgIHByZWRpY2F0ZSA/IHRoaXMudG9TZXEoKS5maWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSA6IHRoaXNcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNvdW50Qnk6IGZ1bmN0aW9uKGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBjb3VudEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfSxcblxuICAgIGVudHJ5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXM7XG4gICAgICBpZiAoaXRlcmFibGUuX2NhY2hlKSB7XG4gICAgICAgIC8vIFdlIGNhY2hlIGFzIGFuIGVudHJpZXMgYXJyYXksIHNvIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgY2FjaGUhXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEoaXRlcmFibGUuX2NhY2hlKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyaWVzU2VxdWVuY2UgPSBpdGVyYWJsZS50b1NlcSgpLm1hcChlbnRyeU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgICBlbnRyaWVzU2VxdWVuY2UuZnJvbUVudHJ5U2VxID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS50b1NlcSgpfTtcbiAgICAgIHJldHVybiBlbnRyaWVzU2VxdWVuY2U7XG4gICAgfSxcblxuICAgIGZpbHRlck5vdDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaW5kRW50cnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBmb3VuZCA9IG5vdFNldFZhbHVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgZm91bmQgPSBbaywgdl07XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZmluZEtleTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdEVudHJ5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmluZExhc3RLZXk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQocmV0dXJuVHJ1ZSk7XG4gICAgfSxcblxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXRNYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICBmbGF0dGVuOiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZyb21FbnRyeVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEZyb21FbnRyaWVzU2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbihfLCBrZXkpICB7cmV0dXJuIGlzKGtleSwgc2VhcmNoS2V5KX0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRJbjogZnVuY3Rpb24oc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBuZXN0ZWQgPSB0aGlzO1xuICAgICAgLy8gTm90ZTogaW4gYW4gRVM2IGVudmlyb25tZW50LCB3ZSB3b3VsZCBwcmVmZXI6XG4gICAgICAvLyBmb3IgKHZhciBrZXkgb2Ygc2VhcmNoS2V5UGF0aCkge1xuICAgICAgdmFyIGl0ZXIgPSBmb3JjZUl0ZXJhdG9yKHNlYXJjaEtleVBhdGgpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgdmFyIGtleSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZCAmJiBuZXN0ZWQuZ2V0ID8gbmVzdGVkLmdldChrZXksIE5PVF9TRVQpIDogTk9UX1NFVDtcbiAgICAgICAgaWYgKG5lc3RlZCA9PT0gTk9UX1NFVCkge1xuICAgICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5lc3RlZDtcbiAgICB9LFxuXG4gICAgZ3JvdXBCeTogZnVuY3Rpb24oZ3JvdXBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGdyb3VwQnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uKHNlYXJjaEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gICAgfSxcblxuICAgIGhhc0luOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbihzZWFyY2hLZXlQYXRoLCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgICB9LFxuXG4gICAgaXNTdWJzZXQ6IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBJdGVyYWJsZShpdGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pO1xuICAgIH0sXG5cbiAgICBpc1N1cGVyc2V0OiBmdW5jdGlvbihpdGVyKSB7XG4gICAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaXNTdWJzZXQgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogSXRlcmFibGUoaXRlcik7XG4gICAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcbiAgICB9LFxuXG4gICAga2V5T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpfSk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChrZXlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLmZpcnN0KCk7XG4gICAgfSxcblxuICAgIGxhc3RLZXlPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBtYXhCeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG1pbkJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvciwgbWFwcGVyKTtcbiAgICB9LFxuXG4gICAgcmVzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcExhc3Q6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuc2tpcChhbW91bnQpLnJldmVyc2UoKSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2tpcFVudGlsOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnRCeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfSxcblxuICAgIHRha2U6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHRha2VMYXN0OiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLnRha2UoYW1vdW50KS5yZXZlcnNlKCkpO1xuICAgIH0sXG5cbiAgICB0YWtlV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHRha2VVbnRpbDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICB2YWx1ZVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgSGFzaGFibGUgT2JqZWN0XG5cbiAgICBoYXNoQ29kZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2hhc2ggfHwgKHRoaXMuX19oYXNoID0gaGFzaEl0ZXJhYmxlKHRoaXMpKTtcbiAgICB9XG5cblxuICAgIC8vICMjIyBJbnRlcm5hbFxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlKGZuLCByZXZlcnNlKVxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxuICB9KTtcblxuICAvLyB2YXIgSVNfSVRFUkFCTEVfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuICAvLyB2YXIgSVNfS0VZRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuICAvLyB2YXIgSVNfSU5ERVhFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcbiAgLy8gdmFyIElTX09SREVSRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICBJdGVyYWJsZVByb3RvdHlwZVtJU19JVEVSQUJMRV9TRU5USU5FTF0gPSB0cnVlO1xuICBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gSXRlcmFibGVQcm90b3R5cGUudmFsdWVzO1xuICBJdGVyYWJsZVByb3RvdHlwZS5fX3RvSlMgPSBJdGVyYWJsZVByb3RvdHlwZS50b0FycmF5O1xuICBJdGVyYWJsZVByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmluc3BlY3QgPVxuICBJdGVyYWJsZVByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9O1xuICBJdGVyYWJsZVByb3RvdHlwZS5jaGFpbiA9IEl0ZXJhYmxlUHJvdG90eXBlLmZsYXRNYXA7XG4gIEl0ZXJhYmxlUHJvdG90eXBlLmNvbnRhaW5zID0gSXRlcmFibGVQcm90b3R5cGUuaW5jbHVkZXM7XG5cbiAgbWl4aW4oS2V5ZWRJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBmbGlwOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGlwRmFjdG9yeSh0aGlzKSk7XG4gICAgfSxcblxuICAgIG1hcEVudHJpZXM6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKS5tYXAoXG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgW2ssIHZdLCBpdGVyYXRpb25zKyssIHRoaXMkMCl9XG4gICAgICAgICkuZnJvbUVudHJ5U2VxKClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIG1hcEtleXM6IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKS5mbGlwKCkubWFwKFxuICAgICAgICAgIGZ1bmN0aW9uKGssIHYpICB7cmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMCl9XG4gICAgICAgICkuZmxpcCgpXG4gICAgICApO1xuICAgIH1cblxuICB9KTtcblxuICB2YXIgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZSA9IEtleWVkSXRlcmFibGUucHJvdG90eXBlO1xuICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlW0lTX0tFWUVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXM7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGUuX190b0pTID0gSXRlcmFibGVQcm90b3R5cGUudG9PYmplY3Q7XG4gIEtleWVkSXRlcmFibGVQcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpfTtcblxuXG5cbiAgbWl4aW4oSW5kZXhlZEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCBmYWxzZSk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICAgIH0sXG5cbiAgICBpbmRleE9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMubGFzdEtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBzcGxpY2U6IGZ1bmN0aW9uKGluZGV4LCByZW1vdmVOdW0gLyosIC4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfCAwLCAwKTtcbiAgICAgIGlmIChudW1BcmdzID09PSAwIHx8IChudW1BcmdzID09PSAyICYmICFyZW1vdmVOdW0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gSWYgaW5kZXggaXMgbmVnYXRpdmUsIGl0IHNob3VsZCByZXNvbHZlIHJlbGF0aXZlIHRvIHRoZSBzaXplIG9mIHRoZVxuICAgICAgLy8gY29sbGVjdGlvbi4gSG93ZXZlciBzaXplIG1heSBiZSBleHBlbnNpdmUgdG8gY29tcHV0ZSBpZiBub3QgY2FjaGVkLCBzb1xuICAgICAgLy8gb25seSBjYWxsIGNvdW50KCkgaWYgdGhlIG51bWJlciBpcyBpbiBmYWN0IG5lZ2F0aXZlLlxuICAgICAgaW5kZXggPSByZXNvbHZlQmVnaW4oaW5kZXgsIGluZGV4IDwgMCA/IHRoaXMuY291bnQoKSA6IHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgc3BsaWNlZCA9IHRoaXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBudW1BcmdzID09PSAxID9cbiAgICAgICAgICBzcGxpY2VkIDpcbiAgICAgICAgICBzcGxpY2VkLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cywgMiksIHRoaXMuc2xpY2UoaW5kZXggKyByZW1vdmVOdW0pKVxuICAgICAgKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgTW9yZSBjb2xsZWN0aW9uIG1ldGhvZHNcblxuICAgIGZpbmRMYXN0SW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoMCk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gKGluZGV4IDwgMCB8fCAodGhpcy5zaXplID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+IHRoaXMuc2l6ZSkpKSA/XG4gICAgICAgIG5vdFNldFZhbHVlIDpcbiAgICAgICAgdGhpcy5maW5kKGZ1bmN0aW9uKF8sIGtleSkgIHtyZXR1cm4ga2V5ID09PSBpbmRleH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgP1xuICAgICAgICB0aGlzLnNpemUgPT09IEluZmluaXR5IHx8IGluZGV4IDwgdGhpcy5zaXplIDpcbiAgICAgICAgdGhpcy5pbmRleE9mKGluZGV4KSAhPT0gLTFcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGludGVycG9zZTogZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJwb3NlRmFjdG9yeSh0aGlzLCBzZXBhcmF0b3IpKTtcbiAgICB9LFxuXG4gICAgaW50ZXJsZWF2ZTogZnVuY3Rpb24oLyouLi5pdGVyYWJsZXMqLykge1xuICAgICAgdmFyIGl0ZXJhYmxlcyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGl0ZXJhYmxlcyk7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSB6aXBwZWQuZmxhdHRlbih0cnVlKTtcbiAgICAgIGlmICh6aXBwZWQuc2l6ZSkge1xuICAgICAgICBpbnRlcmxlYXZlZC5zaXplID0gemlwcGVkLnNpemUgKiBpdGVyYWJsZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcbiAgICB9LFxuXG4gICAga2V5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBSYW5nZSgwLCB0aGlzLnNpemUpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgtMSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHppcDogZnVuY3Rpb24oLyosIC4uLml0ZXJhYmxlcyAqLykge1xuICAgICAgdmFyIGl0ZXJhYmxlcyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBpdGVyYWJsZXMpKTtcbiAgICB9LFxuXG4gICAgemlwV2l0aDogZnVuY3Rpb24oemlwcGVyLyosIC4uLml0ZXJhYmxlcyAqLykge1xuICAgICAgdmFyIGl0ZXJhYmxlcyA9IGFyckNvcHkoYXJndW1lbnRzKTtcbiAgICAgIGl0ZXJhYmxlc1swXSA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBpdGVyYWJsZXMpKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZVtJU19JTkRFWEVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cblxuICBtaXhpbihTZXRJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZ2V0OiBmdW5jdGlvbih2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSkgPyB2YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgU2V0SXRlcmFibGUucHJvdG90eXBlLmhhcyA9IEl0ZXJhYmxlUHJvdG90eXBlLmluY2x1ZGVzO1xuICBTZXRJdGVyYWJsZS5wcm90b3R5cGUuY29udGFpbnMgPSBTZXRJdGVyYWJsZS5wcm90b3R5cGUuaW5jbHVkZXM7XG5cblxuICAvLyBNaXhpbiBzdWJjbGFzc2VzXG5cbiAgbWl4aW4oS2V5ZWRTZXEsIEtleWVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oSW5kZXhlZFNlcSwgSW5kZXhlZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKFNldFNlcSwgU2V0SXRlcmFibGUucHJvdG90eXBlKTtcblxuICBtaXhpbihLZXllZENvbGxlY3Rpb24sIEtleWVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oSW5kZXhlZENvbGxlY3Rpb24sIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihTZXRDb2xsZWN0aW9uLCBTZXRJdGVyYWJsZS5wcm90b3R5cGUpO1xuXG5cbiAgLy8gI3ByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24ga2V5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJ5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gW2ssIHZdO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmVnKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcXVvdGVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICAgIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEl0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoaXRlcmFibGUpO1xuICAgIHZhciBrZXllZCA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBoID0gb3JkZXJlZCA/IDEgOiAwO1xuICAgIHZhciBzaXplID0gaXRlcmFibGUuX19pdGVyYXRlKFxuICAgICAga2V5ZWQgP1xuICAgICAgICBvcmRlcmVkID9cbiAgICAgICAgICBmdW5jdGlvbih2LCBrKSAgeyBoID0gMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpIHwgMDsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHsgaCA9IGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkgfCAwOyB9IDpcbiAgICAgICAgb3JkZXJlZCA/XG4gICAgICAgICAgZnVuY3Rpb24odiApIHsgaCA9IDMxICogaCArIGhhc2godikgfCAwOyB9IDpcbiAgICAgICAgICBmdW5jdGlvbih2ICkgeyBoID0gaCArIGhhc2godikgfCAwOyB9XG4gICAgKTtcbiAgICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11cm11ckhhc2hPZlNpemUoc2l6ZSwgaCkge1xuICAgIGggPSBpbXVsKGgsIDB4Q0M5RTJENTEpO1xuICAgIGggPSBpbXVsKGggPDwgMTUgfCBoID4+PiAtMTUsIDB4MUI4NzM1OTMpO1xuICAgIGggPSBpbXVsKGggPDwgMTMgfCBoID4+PiAtMTMsIDUpO1xuICAgIGggPSAoaCArIDB4RTY1NDZCNjQgfCAwKSBeIHNpemU7XG4gICAgaCA9IGltdWwoaCBeIGggPj4+IDE2LCAweDg1RUJDQTZCKTtcbiAgICBoID0gaW11bChoIF4gaCA+Pj4gMTMsIDB4QzJCMkFFMzUpO1xuICAgIGggPSBzbWkoaCBeIGggPj4+IDE2KTtcbiAgICByZXR1cm4gaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hNZXJnZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgXiBiICsgMHg5RTM3NzlCOSArIChhIDw8IDYpICsgKGEgPj4gMikgfCAwOyAvLyBpbnRcbiAgfVxuXG4gIHZhciBJbW11dGFibGUgPSB7XG5cbiAgICBJdGVyYWJsZTogSXRlcmFibGUsXG5cbiAgICBTZXE6IFNlcSxcbiAgICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAgIE1hcDogTWFwLFxuICAgIE9yZGVyZWRNYXA6IE9yZGVyZWRNYXAsXG4gICAgTGlzdDogTGlzdCxcbiAgICBTdGFjazogU3RhY2ssXG4gICAgU2V0OiBTZXQsXG4gICAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcblxuICAgIFJlY29yZDogUmVjb3JkLFxuICAgIFJhbmdlOiBSYW5nZSxcbiAgICBSZXBlYXQ6IFJlcGVhdCxcblxuICAgIGlzOiBpcyxcbiAgICBmcm9tSlM6IGZyb21KU1xuXG4gIH07XG5cbiAgcmV0dXJuIEltbXV0YWJsZTtcblxufSkpOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVXNlZCBmb3Igc2V0dGluZyBwcm90b3R5cGUgbWV0aG9kcyB0aGF0IElFOCBjaG9rZXMgb24uXG52YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbi8vIENvbnN0YW50cyBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRyaWUgbm9kZXMuXG52YXIgU0hJRlQgPSA1OyAvLyBSZXN1bHRlZCBpbiBiZXN0IHBlcmZvcm1hbmNlIGFmdGVyIF9fX19fXz9cbnZhciBTSVpFID0gMSA8PCBTSElGVDtcbnZhciBNQVNLID0gU0laRSAtIDE7XG5cbi8vIEEgY29uc2lzdGVudCBzaGFyZWQgdmFsdWUgcmVwcmVzZW50aW5nIFwibm90IHNldFwiIHdoaWNoIGVxdWFscyBub3RoaW5nIG90aGVyXG4vLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxudmFyIE5PVF9TRVQgPSB7fTtcblxuLy8gQm9vbGVhbiByZWZlcmVuY2VzLCBSb3VnaCBlcXVpdmFsZW50IG9mIGBib29sICZgLlxuZnVuY3Rpb24gTWFrZVJlZigpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IGZhbHNlIH07XG59XG5cbmZ1bmN0aW9uIFNldFJlZihyZWYpIHtcbiAgaWYgKHJlZikge1xuICAgIHJlZi52YWx1ZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbi8vIHRoZSByZXR1cm4gb2YgYW55IHN1YnNlcXVlbnQgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cbmZ1bmN0aW9uIGVuc3VyZVNpemUoaXRlcikge1xuICBpZiAoaXRlci5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgfVxuICByZXR1cm4gaXRlci5zaXplO1xufVxuXG5mdW5jdGlvbiB3cmFwSW5kZXgoaXRlciwgaW5kZXgpIHtcbiAgLy8gVGhpcyBpbXBsZW1lbnRzIFwiaXMgYXJyYXkgaW5kZXhcIiB3aGljaCB0aGUgRUNNQVN0cmluZyBzcGVjIGRlZmluZXMgYXM6XG4gIC8vXG4gIC8vICAgICBBIFN0cmluZyBwcm9wZXJ0eSBuYW1lIFAgaXMgYW4gYXJyYXkgaW5kZXggaWYgYW5kIG9ubHkgaWZcbiAgLy8gICAgIFRvU3RyaW5nKFRvVWludDMyKFApKSBpcyBlcXVhbCB0byBQIGFuZCBUb1VpbnQzMihQKSBpcyBub3QgZXF1YWxcbiAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAvL1xuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXktZXhvdGljLW9iamVjdHNcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICB2YXIgdWludDMySW5kZXggPSBpbmRleCA+Pj4gMDsgLy8gTiA+Pj4gMCBpcyBzaG9ydGhhbmQgZm9yIFRvVWludDMyXG4gICAgaWYgKCcnICsgdWludDMySW5kZXggIT09IGluZGV4IHx8IHVpbnQzMkluZGV4ID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpbmRleCA9IHVpbnQzMkluZGV4O1xuICB9XG4gIHJldHVybiBpbmRleCA8IDAgPyBlbnN1cmVTaXplKGl0ZXIpICsgaW5kZXggOiBpbmRleDtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICByZXR1cm4gKFxuICAgICgoYmVnaW4gPT09IDAgJiYgIWlzTmVnKGJlZ2luKSkgfHxcbiAgICAgIChzaXplICE9PSB1bmRlZmluZWQgJiYgYmVnaW4gPD0gLXNpemUpKSAmJlxuICAgIChlbmQgPT09IHVuZGVmaW5lZCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA+PSBzaXplKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gIHJldHVybiByZXNvbHZlSW5kZXgoYmVnaW4sIHNpemUsIDApO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICByZXR1cm4gcmVzb2x2ZUluZGV4KGVuZCwgc2l6ZSwgc2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gIC8vIFNhbml0aXplIGluZGljZXMgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkXG4gICAgPyBkZWZhdWx0SW5kZXhcbiAgICA6IGlzTmVnKGluZGV4KVxuICAgICAgPyBzaXplID09PSBJbmZpbml0eVxuICAgICAgICA/IHNpemVcbiAgICAgICAgOiBNYXRoLm1heCgwLCBzaXplICsgaW5kZXgpIHwgMFxuICAgICAgOiBzaXplID09PSB1bmRlZmluZWQgfHwgc2l6ZSA9PT0gaW5kZXhcbiAgICAgICAgPyBpbmRleFxuICAgICAgICA6IE1hdGgubWluKHNpemUsIGluZGV4KSB8IDA7XG59XG5cbmZ1bmN0aW9uIGlzTmVnKHZhbHVlKSB7XG4gIC8vIEFjY291bnQgZm9yIC0wIHdoaWNoIGlzIG5lZ2F0aXZlLCBidXQgbm90IGxlc3MgdGhhbiAwLlxuICByZXR1cm4gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IC1JbmZpbml0eSk7XG59XG5cbi8vIE5vdGU6IHZhbHVlIGlzIHVuY2hhbmdlZCB0byBub3QgYnJlYWsgaW1tdXRhYmxlLWRldnRvb2xzLlxudmFyIElTX0NPTExFQ1RJT05fU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcblxuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG1heWJlQ29sbGVjdGlvbikge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUNvbGxlY3Rpb24gJiYgbWF5YmVDb2xsZWN0aW9uW0lTX0NPTExFQ1RJT05fU1lNQk9MXSk7XG59XG5cbnZhciBJU19LRVlFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc0tleWVkKG1heWJlS2V5ZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVLZXllZCAmJiBtYXliZUtleWVkW0lTX0tFWUVEX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfSU5ERVhFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZChtYXliZUluZGV4ZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVJbmRleGVkICYmIG1heWJlSW5kZXhlZFtJU19JTkRFWEVEX1NZTUJPTF0pO1xufVxuXG5mdW5jdGlvbiBpc0Fzc29jaWF0aXZlKG1heWJlQXNzb2NpYXRpdmUpIHtcbiAgcmV0dXJuIGlzS2V5ZWQobWF5YmVBc3NvY2lhdGl2ZSkgfHwgaXNJbmRleGVkKG1heWJlQXNzb2NpYXRpdmUpO1xufVxuXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG59O1xuXG52YXIgS2V5ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiApIEtleWVkQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRDb2xsZWN0aW9uO1xuXG4gIHJldHVybiBLZXllZENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxudmFyIEluZGV4ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBJbmRleGVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiApIEluZGV4ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbnZhciBTZXRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBTZXRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgU2V0Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDb2xsZWN0aW9uO1xuXG4gIHJldHVybiBTZXRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbkNvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLkluZGV4ZWQgPSBJbmRleGVkQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxudmFyIElTX1NFUV9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVFfX0BAJztcblxuZnVuY3Rpb24gaXNTZXEobWF5YmVTZXEpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfUkVDT1JEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1JFQ09SRF9fQEAnO1xuXG5mdW5jdGlvbiBpc1JlY29yZChtYXliZVJlY29yZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVJlY29yZCAmJiBtYXliZVJlY29yZFtJU19SRUNPUkRfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG1heWJlSW1tdXRhYmxlKSB7XG4gIHJldHVybiBpc0NvbGxlY3Rpb24obWF5YmVJbW11dGFibGUpIHx8IGlzUmVjb3JkKG1heWJlSW1tdXRhYmxlKTtcbn1cblxudmFyIElTX09SREVSRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc09yZGVyZWQobWF5YmVPcmRlcmVkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlT3JkZXJlZCAmJiBtYXliZU9yZGVyZWRbSVNfT1JERVJFRF9TWU1CT0xdKTtcbn1cblxudmFyIElURVJBVEVfS0VZUyA9IDA7XG52YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xudmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbnZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cbnZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yKG5leHQpIHtcbiAgdGhpcy5uZXh0ID0gbmV4dDtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdbSXRlcmF0b3JdJztcbn07XG5cbkl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG5JdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcbkl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID0gSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuSXRlcmF0b3IucHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIGl0ZXJhdG9yUmVzdWx0KSB7XG4gIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gIGl0ZXJhdG9yUmVzdWx0XG4gICAgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSlcbiAgICA6IChpdGVyYXRvclJlc3VsdCA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgIH0pO1xuICByZXR1cm4gaXRlcmF0b3JSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yRG9uZSgpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xufVxuXG5mdW5jdGlvbiBoYXNJdGVyYXRvcihtYXliZUl0ZXJhYmxlKSB7XG4gIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGlzSXRlcmF0b3IobWF5YmVJdGVyYXRvcikge1xuICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID1cbiAgICBpdGVyYWJsZSAmJlxuICAgICgoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgaXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpICYmXG4gICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAodmFsdWUubGVuZ3RoID09PSAwXG4gICAgICA/IC8vIE9ubHkge2xlbmd0aDogMH0gaXMgY29uc2lkZXJlZCBBcnJheS1saWtlLlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxXG4gICAgICA6IC8vIEFuIG9iamVjdCBpcyBvbmx5IEFycmF5LWxpa2UgaWYgaXQgaGFzIGEgcHJvcGVydHkgd2hlcmUgdGhlIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gaW4gdGhlIGFycmF5LWxpa2UgbWF5IGJlIGZvdW5kICh3aGljaCBjb3VsZCBiZSB1bmRlZmluZWQpLlxuICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZS5sZW5ndGggLSAxKSlcbiAgKTtcbn1cblxudmFyIFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICA6IGlzSW1tdXRhYmxlKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uJCQxICkgU2VxLl9fcHJvdG9fXyA9IENvbGxlY3Rpb24kJDE7XG4gIFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uJCQxICYmIENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXE7XG5cbiAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gY2FjaGVSZXN1bHQgKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICBpZiAoZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIHJldHVybiBTZXE7XG59KENvbGxlY3Rpb24pKTtcblxudmFyIEtleWVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIEtleWVkU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpLnRvS2V5ZWRTZXEoKVxuICAgICAgOiBpc0NvbGxlY3Rpb24odmFsdWUpXG4gICAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICA6IHZhbHVlLmZyb21FbnRyeVNlcSgpXG4gICAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgICAgOiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRTZXE7XG5cbiAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gS2V5ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgSW5kZXhlZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUuZW50cnlTZXEoKVxuICAgICAgICAgIDogdmFsdWUudG9JbmRleGVkU2VxKClcbiAgICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKCkuZW50cnlTZXEoKVxuICAgICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEluZGV4ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICBJbmRleGVkU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZFNlcTtcblxuICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gSW5kZXhlZFNlcShhcmd1bWVudHMpO1xuICB9O1xuXG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICB9O1xuXG4gIHJldHVybiBJbmRleGVkU2VxO1xufShTZXEpKTtcblxudmFyIFNldFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IEluZGV4ZWRTZXEodmFsdWUpXG4gICAgKS50b1NldFNlcSgpO1xuICB9XG5cbiAgaWYgKCBTZXEgKSBTZXRTZXEuX19wcm90b19fID0gU2VxO1xuICBTZXRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgU2V0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFNlcTtcblxuICBTZXRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgfTtcblxuICBTZXRTZXEucHJvdG90eXBlLnRvU2V0U2VxID0gZnVuY3Rpb24gdG9TZXRTZXEgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBTZXRTZXE7XG59KFNlcSkpO1xuXG5TZXEuaXNTZXEgPSBpc1NlcTtcblNlcS5LZXllZCA9IEtleWVkU2VxO1xuU2VxLlNldCA9IFNldFNlcTtcblNlcS5JbmRleGVkID0gSW5kZXhlZFNlcTtcblxuU2VxLnByb3RvdHlwZVtJU19TRVFfU1lNQk9MXSA9IHRydWU7XG5cbi8vICNwcmFnbWEgUm9vdCBTZXF1ZW5jZXNcblxudmFyIEFycmF5U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgIHRoaXMuX2FycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5zaXplID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgQXJyYXlTZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgQXJyYXlTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICBBcnJheVNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheVNlcTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICBpZiAoZm4oYXJyYXlbaWldLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICB2YXIgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtpaV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBcnJheVNlcTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgT2JqZWN0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2VxKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5zaXplID0ga2V5cy5sZW5ndGg7XG4gIH1cblxuICBpZiAoIEtleWVkU2VxICkgT2JqZWN0U2VxLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICBPYmplY3RTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gIE9iamVjdFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RTZXE7XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAobm90U2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0W2tleV07XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX29iamVjdCwga2V5KTtcbiAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdFNlcTtcbn0oS2V5ZWRTZXEpKTtcbk9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIENvbGxlY3Rpb25TZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb25TZXEoY29sbGVjdGlvbikge1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IGNvbGxlY3Rpb24ubGVuZ3RoIHx8IGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSApIENvbGxlY3Rpb25TZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvblNlcTtcblxuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0ZVVuY2FjaGVkIChmbiwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRvclVuY2FjaGVkICh0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29sbGVjdGlvblNlcTtcbn0oSW5kZXhlZFNlcSkpO1xuXG4vLyAjIHByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbnZhciBFTVBUWV9TRVE7XG5cbmZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gIHJldHVybiBFTVBUWV9TRVEgfHwgKEVNUFRZX1NFUSA9IG5ldyBBcnJheVNlcShbXSkpO1xufVxuXG5mdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICA/IG5ldyBBcnJheVNlcSh2YWx1ZSlcbiAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgPyBuZXcgQ29sbGVjdGlvblNlcSh2YWx1ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoc2VxKSB7XG4gICAgcmV0dXJuIHNlcS5mcm9tRW50cnlTZXEoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgb3Iga2V5ZWQgb2JqZWN0OiAnICtcbiAgICAgIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIGlmIChzZXEpIHtcbiAgICByZXR1cm4gc2VxO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgaWYgKHNlcSkge1xuICAgIHJldHVybiBzZXE7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFNlcSh2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzLCBvciBrZXllZCBvYmplY3Q6ICcgKyB2YWx1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlKVxuICAgID8gbmV3IEFycmF5U2VxKHZhbHVlKVxuICAgIDogaGFzSXRlcmF0b3IodmFsdWUpXG4gICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBJU19NQVBfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbmZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICByZXR1cm4gaXNNYXAobWF5YmVPcmRlcmVkTWFwKSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkTWFwKTtcbn1cblxuZnVuY3Rpb24gaXNWYWx1ZU9iamVjdChtYXliZVZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIG1heWJlVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIG1heWJlVmFsdWUuaGFzaENvZGUgPT09ICdmdW5jdGlvbidcbiAgKTtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAqXG4gKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuICpcbiAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG4gKlxuICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG4gKlxuICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAqXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcbiAqXG4gKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcbiAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuICpcbiAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuICpcbiAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICpcbiAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gKlxuICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gKlxuICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICpcbiAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICpcbiAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAqICAgICB9XG4gKlxuICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBhcmUgVmFsdWUgT2JqZWN0czogdGhleSBpbXBsZW1lbnQgYGVxdWFscygpYFxuICogYW5kIGBoYXNoQ29kZSgpYC5cbiAqL1xuZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcbiAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWVBLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWVCLnZhbHVlT2YgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICB2YWx1ZUIgPSB2YWx1ZUIudmFsdWVPZigpO1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gISEoXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUEpICYmXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUIpICYmXG4gICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpXG4gICk7XG59XG5cbnZhciBpbXVsID1cbiAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yXG4gICAgPyBNYXRoLmltdWxcbiAgICA6IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgICBhIHw9IDA7IC8vIGludFxuICAgICAgICBiIHw9IDA7IC8vIGludFxuICAgICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICAgIHZhciBkID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgICByZXR1cm4gKGMgKiBkICsgKCgoKGEgPj4+IDE2KSAqIGQgKyBjICogKGIgPj4+IDE2KSkgPDwgMTYpID4+PiAwKSkgfCAwOyAvLyBpbnRcbiAgICAgIH07XG5cbi8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbi8vIFRoaXMgZnVuY3Rpb24gZHJvcHMgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0IGluIGEgc2lnbmVkIG51bWJlciwgbWFpbnRhaW5pbmdcbi8vIHRoZSBzaWduIGJpdC5cbmZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgcmV0dXJuICgoaTMyID4+PiAxKSAmIDB4NDAwMDAwMDApIHwgKGkzMiAmIDB4YmZmZmZmZmYpO1xufVxuXG52YXIgZGVmYXVsdFZhbHVlT2YgPSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2Y7XG5cbmZ1bmN0aW9uIGhhc2gobykge1xuICBzd2l0Y2ggKHR5cGVvZiBvKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUaGUgaGFzaCB2YWx1ZXMgZm9yIGJ1aWx0LWluIGNvbnN0YW50cyBhcmUgYSAxIHZhbHVlIGZvciBlYWNoIDUtYnl0ZVxuICAgICAgLy8gc2hpZnQgcmVnaW9uIGV4cGVjdCBmb3IgdGhlIGZpcnN0LCB3aGljaCBlbmNvZGVzIHRoZSB2YWx1ZS4gVGhpc1xuICAgICAgLy8gcmVkdWNlcyB0aGUgb2RkcyBvZiBhIGhhc2ggY29sbGlzaW9uIGZvciB0aGVzZSBjb21tb24gdmFsdWVzLlxuICAgICAgcmV0dXJuIG8gPyAweDQyMTA4NDIxIDogMHg0MjEwODQyMDtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGhhc2hOdW1iZXIobyk7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU5cbiAgICAgICAgPyBjYWNoZWRIYXNoU3RyaW5nKG8pXG4gICAgICAgIDogaGFzaFN0cmluZyhvKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmIChvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAweDQyMTA4NDIyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIERyb3AgYW55IGhpZ2ggYml0cyBmcm9tIGFjY2lkZW50YWxseSBsb25nIGhhc2ggY29kZXMuXG4gICAgICAgIHJldHVybiBzbWkoby5oYXNoQ29kZShvKSk7XG4gICAgICB9XG4gICAgICBpZiAoby52YWx1ZU9mICE9PSBkZWZhdWx0VmFsdWVPZiAmJiB0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSBvLnZhbHVlT2Yobyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaEpTT2JqKG8pO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gMHg0MjEwODQyMztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBoYXNoU3RyaW5nKG8udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGVvZiBvICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICB9XG59XG5cbi8vIENvbXByZXNzIGFyYml0cmFyaWx5IGxhcmdlIG51bWJlcnMgaW50byBzbWkgaGFzaGVzLlxuZnVuY3Rpb24gaGFzaE51bWJlcihuKSB7XG4gIGlmIChuICE9PSBuIHx8IG4gPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGhhc2ggPSBuIHwgMDtcbiAgaWYgKGhhc2ggIT09IG4pIHtcbiAgICBoYXNoIF49IG4gKiAweGZmZmZmZmZmO1xuICB9XG4gIHdoaWxlIChuID4gMHhmZmZmZmZmZikge1xuICAgIG4gLz0gMHhmZmZmZmZmZjtcbiAgICBoYXNoIF49IG47XG4gIH1cbiAgcmV0dXJuIHNtaShoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIGhhc2hlZCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICBpZiAoaGFzaGVkID09PSB1bmRlZmluZWQpIHtcbiAgICBoYXNoZWQgPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgIH1cbiAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoZWQ7XG4gIH1cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG4gIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG4gIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gIHZhciBoYXNoZWQgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgIGhhc2hlZCA9ICgzMSAqIGhhc2hlZCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgfCAwO1xuICB9XG4gIHJldHVybiBzbWkoaGFzaGVkKTtcbn1cblxuZnVuY3Rpb24gaGFzaEpTT2JqKG9iaikge1xuICB2YXIgaGFzaGVkO1xuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgaGFzaGVkID0gd2Vha01hcC5nZXQob2JqKTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFzaGVkID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICBpZiAoIWNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgaGFzaGVkID0gb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG5cbiAgICBoYXNoZWQgPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cbiAgfVxuXG4gIGhhc2hlZCA9ICsrb2JqSGFzaFVJRDtcbiAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgb2JqSGFzaFVJRCA9IDA7XG4gIH1cblxuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcC5zZXQob2JqLCBoYXNoZWQpO1xuICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGhhc2hlZCxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICApIHtcbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfTtcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAvLyBpdHNlbGYuXG4gICAgb2JqW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbi8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcbi8vIGFuZCBhdm9pZCBtZW1vcnkgbGVha3MgZnJvbSB0aGUgSUUgY2xvbmVOb2RlIGJ1Zy5cbmZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSAxOiAvLyBFbGVtZW50XG4gICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudW5pcXVlSUQ7XG4gICAgfVxuICB9XG59XG5cbi8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxudmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xudmFyIHdlYWtNYXA7XG5pZiAodXNpbmdXZWFrTWFwKSB7XG4gIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xufVxuXG52YXIgb2JqSGFzaFVJRCA9IDA7XG5cbnZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG59XG5cbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG52YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbnZhciBUb0tleWVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgIHRoaXMuX3VzZUtleXMgPSB1c2VLZXlzO1xuICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgfVxuXG4gIGlmICggS2V5ZWRTZXEkJDEgKSBUb0tleWVkU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXEkJDE7XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSQkMSAmJiBLZXllZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvS2V5ZWRTZXF1ZW5jZTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuaGFzKGtleSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uIHZhbHVlU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKTtcbiAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5yZXZlcnNlKCk7IH07XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLl9pdGVyLnRvU2VxKCkubWFwKG1hcHBlciwgY29udGV4dCk7IH07XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvS2V5ZWRTZXF1ZW5jZTtcbn0oS2V5ZWRTZXEpKTtcblRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIFRvSW5kZXhlZFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxJCQxICkgVG9JbmRleGVkU2VxdWVuY2UuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSQkMSAmJiBJbmRleGVkU2VxJCQxLnByb3RvdHlwZSApO1xuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb0luZGV4ZWRTZXF1ZW5jZTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gIH07XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpID0gMDtcbiAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKHRoaXMpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lXG4gICAgICAgID8gc3RlcFxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb0luZGV4ZWRTZXF1ZW5jZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgVG9TZXRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldFNlcSQkMSkge1xuICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gIH1cblxuICBpZiAoIFNldFNlcSQkMSApIFRvU2V0U2VxdWVuY2UuX19wcm90b19fID0gU2V0U2VxJCQxO1xuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldFNlcSQkMSAmJiBTZXRTZXEkJDEucHJvdG90eXBlICk7XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9TZXRTZXF1ZW5jZTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gIH07XG5cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCB2LCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgPyBzdGVwXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBzdGVwLnZhbHVlLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG9TZXRTZXF1ZW5jZTtcbn0oU2V0U2VxKSk7XG5cbnZhciBGcm9tRW50cmllc1NlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEkJDEpIHtcbiAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgdGhpcy5faXRlciA9IGVudHJpZXM7XG4gICAgdGhpcy5zaXplID0gZW50cmllcy5zaXplO1xuICB9XG5cbiAgaWYgKCBLZXllZFNlcSQkMSApIEZyb21FbnRyaWVzU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXEkJDE7XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEkJDEgJiYgS2V5ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJvbUVudHJpZXNTZXF1ZW5jZTtcblxuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uIGVudHJ5U2VxICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci50b1NlcSgpO1xuICB9O1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgIHRoaXMkMVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEZyb21FbnRyaWVzU2VxdWVuY2U7XG59KEtleWVkU2VxKSk7XG5cblRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuXG5mdW5jdGlvbiBmbGlwRmFjdG9yeShjb2xsZWN0aW9uKSB7XG4gIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGZsaXBTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gIGZsaXBTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24ucmV2ZXJzZSgpOyB9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKGssIHYsIHRoaXMkMSkgIT09IGZhbHNlOyB9LCByZXZlcnNlKTtcbiAgfTtcbiAgZmxpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0b3IoXG4gICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldHVybiBmbGlwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIG1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgcmV0dXJuIHYgPT09IE5PVF9TRVRcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfTtcbiAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIGZuKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGMpLCBrLCB0aGlzJDEpICE9PSBmYWxzZTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleSxcbiAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgY29sbGVjdGlvbiksXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoY29sbGVjdGlvbiwgdXNlS2V5cykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gIHJldmVyc2VkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgaWYgKGNvbGxlY3Rpb24uZmxpcCkge1xuICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pO1xuICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmZsaXAoKTsgfTtcbiAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgfTtcbiAgfVxuICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmdldCh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXksIG5vdFNldFZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKHZhbHVlKTsgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSk7IH0sXG4gICAgICAhcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCAhcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHVzZUtleXMgPyBlbnRyeVswXSA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgZW50cnlbMV0sXG4gICAgICAgIHN0ZXBcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGlmICh1c2VLZXlzKSB7XG4gICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbilcbiAgICAgICAgPyB2XG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcbiAgfVxuICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSwgMCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgKyAxOyB9KTtcbiAgfSk7XG4gIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeUZhY3RvcnkoY29sbGVjdGlvbiwgZ3JvdXBlciwgY29udGV4dCkge1xuICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChjb2xsZWN0aW9uKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHMudXBkYXRlKFxuICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLFxuICAgICAgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoYSA9IGEgfHwgW10pLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSk7IH1cbiAgICApO1xuICB9KTtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gcmVpZnkoY29sbGVjdGlvbiwgY29lcmNlKGFycikpOyB9KS5hc0ltbXV0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbiwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gIC8vIHRoaXMgY29sbGVjdGlvbidzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAvLyBhIGtub3duIHNpemUgYW5kIHRoZXNlIGRvIG5vdCByZXNvbHZlIHRvIE5hTi5cbiAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgcmV0dXJuIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gIH1cblxuICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgdmFyIHNsaWNlU2l6ZTtcbiAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gIH1cblxuICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG5cbiAgLy8gSWYgY29sbGVjdGlvbi5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gIC8vIHVua25vd24gYXQgdGhpcyBwb2ludCB1bmxlc3MgdGhlIG51bWJlciBvZiBpdGVtcyB0byBzbGljZSBpcyAwXG4gIHNsaWNlU2VxLnNpemUgPVxuICAgIHNsaWNlU2l6ZSA9PT0gMCA/IHNsaWNlU2l6ZSA6IChjb2xsZWN0aW9uLnNpemUgJiYgc2xpY2VTaXplKSB8fCB1bmRlZmluZWQ7XG5cbiAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGNvbGxlY3Rpb24pICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHNsaWNlU2l6ZVxuICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGluZGV4ICsgcmVzb2x2ZWRCZWdpbiwgbm90U2V0VmFsdWUpXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHNsaWNlU2VxLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQxKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHNsaWNlU2l6ZSAhPT0gMCAmJiByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBpbnN0YW50aWF0aW5nIHBhcmVudCBpdGVyYXRvciBpZiB0YWtpbmcgMC5cbiAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pIHtcbiAgICAgICAgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKCsraXRlcmF0aW9ucyA+IHNsaWNlU2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTIHx8IHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHNsaWNlU2VxO1xufVxuXG5mdW5jdGlvbiB0YWtlV2hpbGVGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDEpOyB9XG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpdGVyYXRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICB2YXIgdiA9IGVudHJ5WzFdO1xuICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKSB7XG4gICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB0YWtlU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gIHZhciBza2lwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIHNraXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBrO1xuICAgICAgdmFyIHY7XG4gICAgICBkbyB7XG4gICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICBrID0gZW50cnlbMF07XG4gICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgc2tpcHBpbmcgJiYgKHNraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQxKSk7XG4gICAgICB9IHdoaWxlIChza2lwcGluZyk7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBza2lwU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoY29sbGVjdGlvbiwgdmFsdWVzKSB7XG4gIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBpdGVycyA9IFtjb2xsZWN0aW9uXVxuICAgIC5jb25jYXQodmFsdWVzKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmICghaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgIHYgPSBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICAgID8ga2V5ZWRTZXFGcm9tVmFsdWUodilcbiAgICAgICAgICA6IGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgfSBlbHNlIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgICAgICB2ID0gS2V5ZWRDb2xsZWN0aW9uKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnNpemUgIT09IDA7IH0pO1xuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgaWYgKFxuICAgICAgc2luZ2xldG9uID09PSBjb2xsZWN0aW9uIHx8XG4gICAgICAoaXNLZXllZENvbGxlY3Rpb24gJiYgaXNLZXllZChzaW5nbGV0b24pKSB8fFxuICAgICAgKGlzSW5kZXhlZChjb2xsZWN0aW9uKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChjb2xsZWN0aW9uKSkge1xuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICB9XG4gIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzZXEpIHtcbiAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMCk7XG4gIHJldHVybiBjb25jYXRTZXE7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGNvbGxlY3Rpb24sIGRlcHRoLCB1c2VLZXlzKSB7XG4gIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZmxhdERlZXAoaXRlciwgY3VycmVudERlcHRoKSB7XG4gICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIGlmIChmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCBmbGF0U2VxdWVuY2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhc3RvcHBlZDtcbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIH1cbiAgICBmbGF0RGVlcChjb2xsZWN0aW9uLCAwKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgZmxhdFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgIGl0ZXJhdG9yID0gdi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZmxhdFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICAudG9TZXEoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSk7IH0pXG4gICAgLmZsYXR0ZW4odHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoY29sbGVjdGlvbiwgc2VwYXJhdG9yKSB7XG4gIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplICYmIGNvbGxlY3Rpb24uc2l6ZSAqIDIgLSAxO1xuICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2UpICYmXG4gICAgICAgIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgc3RlcDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3RlcCB8fCBpdGVyYXRpb25zICUgMikge1xuICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zICUgMlxuICAgICAgICA/IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzZXBhcmF0b3IpXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBzb3J0RmFjdG9yeShjb2xsZWN0aW9uLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICB9XG4gIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBlbnRyaWVzID0gY29sbGVjdGlvblxuICAgIC50b1NlcSgpXG4gICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW2ssIHYsIGluZGV4KyssIG1hcHBlciA/IG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKSA6IHZdOyB9KVxuICAgIC52YWx1ZVNlcSgpXG4gICAgLnRvQXJyYXkoKTtcbiAgZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdOyB9KS5mb3JFYWNoKFxuICAgIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICA/IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgZW50cmllc1tpXS5sZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgZW50cmllc1tpXSA9IHZbMV07XG4gICAgICAgIH1cbiAgKTtcbiAgcmV0dXJuIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgPyBLZXllZFNlcShlbnRyaWVzKVxuICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEluZGV4ZWRTZXEoZW50cmllcylcbiAgICAgIDogU2V0U2VxKGVudHJpZXMpO1xufVxuXG5mdW5jdGlvbiBtYXhGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cbiAgaWYgKG1hcHBlcikge1xuICAgIHZhciBlbnRyeSA9IGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbdiwgbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pXTsgfSlcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGEpOyB9KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSA/IGIgOiBhKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikge1xuICB2YXIgY29tcCA9IGNvbXBhcmF0b3IoYiwgYSk7XG4gIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcbiAgLy8gdGhleSBhcmUgbm90IGVxdWFsIGFuZCBiIGlzIGluIGZhY3QgYSBudWxsaXNoIHZhbHVlLlxuICByZXR1cm4gKFxuICAgIChjb21wID09PSAwICYmIGIgIT09IGEgJiYgKGIgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgIT09IGIpKSB8fFxuICAgIGNvbXAgPiAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIHppcFdpdGhGYWN0b3J5KGtleUl0ZXIsIHppcHBlciwgaXRlcnMsIHppcEFsbCkge1xuICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG4gIHZhciBzaXplcyA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNpemU7IH0pO1xuICB6aXBTZXF1ZW5jZS5zaXplID0gemlwQWxsID8gc2l6ZXMubWF4KCkgOiBzaXplcy5taW4oKTtcbiAgLy8gTm90ZTogdGhpcyBhIGdlbmVyaWMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBfX2l0ZXJhdGUgaW4gdGVybXMgb2ZcbiAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgemlwU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAvKiBnZW5lcmljOlxuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgICBpZiAoZm4oc3RlcC52YWx1ZVsxXSwgc3RlcC52YWx1ZVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAqL1xuICAgIC8vIGluZGV4ZWQ6XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgc3RlcDtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvcnMgPSBpdGVycy5tYXAoXG4gICAgICBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKChpID0gQ29sbGVjdGlvbihpKSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKTsgfVxuICAgICk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5uZXh0KCk7IH0pO1xuICAgICAgICBpc0RvbmUgPSB6aXBBbGwgPyBzdGVwcy5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KSA6IHN0ZXBzLnNvbWUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICB0eXBlLFxuICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgIHppcHBlci5hcHBseShudWxsLCBzdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudmFsdWU7IH0pKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHppcFNlcXVlbmNlO1xufVxuXG4vLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVpZnkoaXRlciwgc2VxKSB7XG4gIHJldHVybiBpdGVyID09PSBzZXEgPyBpdGVyIDogaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgPyBLZXllZENvbGxlY3Rpb25cbiAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgPyBJbmRleGVkQ29sbGVjdGlvblxuICAgICAgOiBTZXRDb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbikge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAoaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgPyBLZXllZFNlcVxuICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgICAgPyBJbmRleGVkU2VxXG4gICAgICAgIDogU2V0U2VxXG4gICAgKS5wcm90b3R5cGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICBpZiAodGhpcy5faXRlci5jYWNoZVJlc3VsdCkge1xuICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcbiAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuLy8gaHR0cDovL2pzcGVyZi5jb20vY29weS1hcnJheS1pbmxpbmVcbmZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCBhcnIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgbmV3QXJyW2lpXSA9IGFycltpaSArIG9mZnNldF07XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKGVycm9yKTsgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gIGludmFyaWFudChcbiAgICBzaXplICE9PSBJbmZpbml0eSxcbiAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29lcmNlS2V5UGF0aChrZXlQYXRoKSB7XG4gIGlmIChpc0FycmF5TGlrZShrZXlQYXRoKSAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ga2V5UGF0aDtcbiAgfVxuICBpZiAoaXNPcmRlcmVkKGtleVBhdGgpKSB7XG4gICAgcmV0dXJuIGtleVBhdGgudG9BcnJheSgpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0ludmFsaWQga2V5UGF0aDogZXhwZWN0ZWQgT3JkZXJlZCBDb2xsZWN0aW9uIG9yIEFycmF5OiAnICsga2V5UGF0aFxuICApO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluT2JqKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgJiZcbiAgICAodHlwZW9mIHZhbHVlLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JylcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgcG90ZW50aWFsbHktcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSwgZWl0aGVyXG4gKiBwcm92aWRlZCBieSBJbW11dGFibGUuanMgb3IgYSBwbGFpbiBBcnJheSBvciBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAoaXNJbW11dGFibGUodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmoodmFsdWUpKVxuICApO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgdmFsdWUgdG8gYSBzdHJpbmcsIGFkZGluZyBxdW90ZXMgaWYgYSBzdHJpbmcgd2FzIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgfSBjYXRjaCAoX2lnbm9yZUVycm9yKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXMoY29sbGVjdGlvbiwga2V5KSB7XG4gIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgID8gY29sbGVjdGlvbi5oYXMoa2V5KVxuICAgIDogaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pICYmIGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0KGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgPyBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldFZhbHVlKVxuICAgIDogIWhhcyhjb2xsZWN0aW9uLCBrZXkpXG4gICAgICA/IG5vdFNldFZhbHVlXG4gICAgICA6IHR5cGVvZiBjb2xsZWN0aW9uLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGtleSlcbiAgICAgICAgOiBjb2xsZWN0aW9uW2tleV07XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGZyb20pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbSkpIHtcbiAgICByZXR1cm4gYXJyQ29weShmcm9tKTtcbiAgfVxuICB2YXIgdG8gPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBrZXkpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnJlbW92ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnJlbW92ZSgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZShrZXkpO1xuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb25Db3B5KSkge1xuICAgIGNvbGxlY3Rpb25Db3B5LnNwbGljZShrZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbn1cblxuZnVuY3Rpb24gc2V0KGNvbGxlY3Rpb24sIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uLnNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnNldCgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpICYmIHZhbHVlID09PSBjb2xsZWN0aW9uW2tleV0pIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIGlmICghdXBkYXRlcikge1xuICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgaXNJbW11dGFibGUoY29sbGVjdGlvbiksXG4gICAgY29sbGVjdGlvbixcbiAgICBjb2VyY2VLZXlQYXRoKGtleVBhdGgpLFxuICAgIDAsXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApO1xuICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gbm90U2V0VmFsdWUgOiB1cGRhdGVkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluRGVlcGx5KFxuICBpbkltbXV0YWJsZSxcbiAgZXhpc3RpbmcsXG4gIGtleVBhdGgsXG4gIGksXG4gIG5vdFNldFZhbHVlLFxuICB1cGRhdGVyXG4pIHtcbiAgdmFyIHdhc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuICBpZiAoaSA9PT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHdhc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgdmFyIG5ld1ZhbHVlID0gdXBkYXRlcihleGlzdGluZ1ZhbHVlKTtcbiAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICB9XG4gIGlmICghd2FzTm90U2V0ICYmICFpc0RhdGFTdHJ1Y3R1cmUoZXhpc3RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgdXBkYXRlIHdpdGhpbiBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWUgaW4gcGF0aCBbJyArXG4gICAgICAgIGtleVBhdGguc2xpY2UoMCwgaSkubWFwKHF1b3RlU3RyaW5nKSArXG4gICAgICAgICddOiAnICtcbiAgICAgICAgZXhpc3RpbmdcbiAgICApO1xuICB9XG4gIHZhciBrZXkgPSBrZXlQYXRoW2ldO1xuICB2YXIgbmV4dEV4aXN0aW5nID0gd2FzTm90U2V0ID8gTk9UX1NFVCA6IGdldChleGlzdGluZywga2V5LCBOT1RfU0VUKTtcbiAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgbmV4dEV4aXN0aW5nID09PSBOT1RfU0VUID8gaW5JbW11dGFibGUgOiBpc0ltbXV0YWJsZShuZXh0RXhpc3RpbmcpLFxuICAgIG5leHRFeGlzdGluZyxcbiAgICBrZXlQYXRoLFxuICAgIGkgKyAxLFxuICAgIG5vdFNldFZhbHVlLFxuICAgIHVwZGF0ZXJcbiAgKTtcbiAgcmV0dXJuIG5leHRVcGRhdGVkID09PSBuZXh0RXhpc3RpbmdcbiAgICA/IGV4aXN0aW5nXG4gICAgOiBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVFxuICAgICAgPyByZW1vdmUoZXhpc3RpbmcsIGtleSlcbiAgICAgIDogc2V0KFxuICAgICAgICAgIHdhc05vdFNldCA/IChpbkltbXV0YWJsZSA/IGVtcHR5TWFwKCkgOiB7fSkgOiBleGlzdGluZyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV4dFVwZGF0ZWRcbiAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gc2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn1cblxuZnVuY3Rpb24gc2V0SW4kMShrZXlQYXRoLCB2KSB7XG4gIHJldHVybiBzZXRJbih0aGlzLCBrZXlQYXRoLCB2KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9UX1NFVDsgfSk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUluKGtleVBhdGgpIHtcbiAgcmV0dXJuIHJlbW92ZUluKHRoaXMsIGtleVBhdGgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwgW2tleV0sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlJDEoa2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8ga2V5KHRoaXMpXG4gICAgOiB1cGRhdGUodGhpcywga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluJDEoa2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VXaXRoKG1lcmdlcikge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgaWYgKHR5cGVvZiBtZXJnZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1lcmdlciBmdW5jdGlvbjogJyArIG1lcmdlcik7XG4gIH1cbiAgcmV0dXJuIG1lcmdlSW50b0tleWVkV2l0aCh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvS2V5ZWRXaXRoKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25zLCBtZXJnZXIpIHtcbiAgdmFyIGl0ZXJzID0gW107XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICB2YXIgY29sbGVjdGlvbiQxID0gS2V5ZWRDb2xsZWN0aW9uKGNvbGxlY3Rpb25zW2lpXSk7XG4gICAgaWYgKGNvbGxlY3Rpb24kMS5zaXplICE9PSAwKSB7XG4gICAgICBpdGVycy5wdXNoKGNvbGxlY3Rpb24kMSk7XG4gICAgfVxuICB9XG4gIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICBpZiAoXG4gICAgY29sbGVjdGlvbi50b1NlcSgpLnNpemUgPT09IDAgJiZcbiAgICAhY29sbGVjdGlvbi5fX293bmVySUQgJiZcbiAgICBpdGVycy5sZW5ndGggPT09IDFcbiAgKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICB9XG4gIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbWVyZ2VJbnRvQ29sbGVjdGlvbiA9IG1lcmdlclxuICAgICAgPyBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHVwZGF0ZShcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBOT1RfU0VULFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9sZFZhbCkgeyByZXR1cm4gKG9sZFZhbCA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKG9sZFZhbCwgdmFsdWUsIGtleSkpOyB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGl0ZXJzW2lpXS5mb3JFYWNoKG1lcmdlSW50b0NvbGxlY3Rpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlJDEoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGgkMShtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAoY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aChtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcikge1xuICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IG1lcmdlIGludG8gbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXJnZXIgPT09ICdmdW5jdGlvbicgJiYgY29sbGVjdGlvbi5tZXJnZVdpdGhcbiAgICAgID8gY29sbGVjdGlvbi5tZXJnZVdpdGguYXBwbHkoY29sbGVjdGlvbiwgWyBtZXJnZXIgXS5jb25jYXQoIHNvdXJjZXMgKSlcbiAgICAgIDogY29sbGVjdGlvbi5tZXJnZVxuICAgICAgICA/IGNvbGxlY3Rpb24ubWVyZ2UuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcylcbiAgICAgICAgOiBjb2xsZWN0aW9uLmNvbmNhdC5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbik7XG4gIHZhciBtZXJnZWQgPSBjb2xsZWN0aW9uO1xuICB2YXIgQ29sbGVjdGlvbiQkMSA9IGlzQXJyYXkgPyBJbmRleGVkQ29sbGVjdGlvbiA6IEtleWVkQ29sbGVjdGlvbjtcbiAgdmFyIG1lcmdlSXRlbSA9IGlzQXJyYXlcbiAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBoYXNWYWwgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG1lcmdlZCwga2V5KTtcbiAgICAgICAgdmFyIG5leHRWYWwgPVxuICAgICAgICAgIGhhc1ZhbCAmJiBtZXJnZXIgPyBtZXJnZXIobWVyZ2VkW2tleV0sIHZhbHVlLCBrZXkpIDogdmFsdWU7XG4gICAgICAgIGlmICghaGFzVmFsIHx8IG5leHRWYWwgIT09IG1lcmdlZFtrZXldKSB7XG4gICAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lcmdlZFtrZXldID0gbmV4dFZhbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgQ29sbGVjdGlvbiQkMShzb3VyY2VzW2ldKS5mb3JFYWNoKG1lcmdlSXRlbSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gaXNEYXRhU3RydWN0dXJlKG9sZFZhbHVlKSAmJiBpc0RhdGFTdHJ1Y3R1cmUobmV3VmFsdWUpXG4gICAgICA/IG1lcmdlV2l0aFNvdXJjZXMob2xkVmFsdWUsIFtuZXdWYWx1ZV0sIGRlZXBNZXJnZXIpXG4gICAgICA6IG1lcmdlclxuICAgICAgICA/IG1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSlcbiAgICAgICAgOiBuZXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVlcE1lcmdlcjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwJDEoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoJDEobWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW4oa2V5UGF0aCkge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcEluKGtleVBhdGgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBlbXB0eU1hcCgpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHdpdGhNdXRhdGlvbnMoZm4pIHtcbiAgdmFyIG11dGFibGUgPSB0aGlzLmFzTXV0YWJsZSgpO1xuICBmbihtdXRhYmxlKTtcbiAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFzTXV0YWJsZSgpIHtcbiAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbn1cblxuZnVuY3Rpb24gYXNJbW11dGFibGUoKSB7XG4gIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcbn1cblxuZnVuY3Rpb24gd2FzQWx0ZXJlZCgpIHtcbiAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xufVxuXG52YXIgTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5TWFwKClcbiAgICAgIDogaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24kJDEodmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIEtleWVkQ29sbGVjdGlvbiQkMSApIE1hcC5fX3Byb3RvX18gPSBLZXllZENvbGxlY3Rpb24kJDE7XG4gIE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZENvbGxlY3Rpb24kJDEgJiYgS2V5ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gIE1hcC5vZiA9IGZ1bmN0aW9uIG9mICgpIHtcbiAgICB2YXIga2V5VmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGtleVZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgICAgPyB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKVxuICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKGtleXMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IENvbGxlY3Rpb24oa2V5cyk7XG5cbiAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtYXAucmVtb3ZlKGtleSk7IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBtYXApKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuX3Jvb3QgJiZcbiAgICAgIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEpO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcDtcbn0oS2V5ZWRDb2xsZWN0aW9uKSk7XG5cbk1hcC5pc01hcCA9IGlzTWFwO1xuXG52YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbk1hcFByb3RvdHlwZVtJU19NQVBfU1lNQk9MXSA9IHRydWU7XG5NYXBQcm90b3R5cGVbREVMRVRFXSA9IE1hcFByb3RvdHlwZS5yZW1vdmU7XG5NYXBQcm90b3R5cGUucmVtb3ZlQWxsID0gTWFwUHJvdG90eXBlLmRlbGV0ZUFsbDtcbk1hcFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG5NYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW4gPSBkZWxldGVJbjtcbk1hcFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbk1hcFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG5NYXBQcm90b3R5cGUubWVyZ2UgPSBNYXBQcm90b3R5cGUuY29uY2F0ID0gbWVyZ2U7XG5NYXBQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG5NYXBQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5NYXBQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbk1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbk1hcFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbk1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbk1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQuc2V0KGFyclswXSwgYXJyWzFdKTtcbn07XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG4vLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxudmFyIEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBub3RTZXRWYWx1ZTtcbn07XG5cbkFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFNldFJlZihkaWRBbHRlcik7XG4gIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICBpZiAocmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiAhcmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA+PSBNQVhfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5TWFwTm9kZShvd25lcklELCBuZXdFbnRyaWVzKTtcbn07XG5cbnZhciBCaXRtYXBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gIHRoaXMubm9kZXMgPSBub2Rlcztcbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBiaXQgPSAxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSyk7XG4gIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwXG4gICAgPyBub3RTZXRWYWx1ZVxuICAgIDogdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoXG4gICAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICAgIGtleUhhc2gsXG4gICAgICAgIGtleSxcbiAgICAgICAgbm90U2V0VmFsdWVcbiAgICAgICk7XG59O1xuXG5CaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCArIFNISUZULFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKTtcblxuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICB9XG5cbiAgaWYgKFxuICAgIGV4aXN0cyAmJlxuICAgICFuZXdOb2RlICYmXG4gICAgbm9kZXMubGVuZ3RoID09PSAyICYmXG4gICAgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSlcbiAgKSB7XG4gICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICB9XG5cbiAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gKG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQpIDogYml0bWFwIHwgYml0O1xuICB2YXIgbmV3Tm9kZXMgPSBleGlzdHNcbiAgICA/IG5ld05vZGVcbiAgICAgID8gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSlcbiAgICAgIDogc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpXG4gICAgOiBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuY291bnQgPSBjb3VudDtcbiAgdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICByZXR1cm4gbm9kZVxuICAgID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSlcbiAgICA6IG5vdFNldFZhbHVlO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cbiAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICBub2RlLFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQgKyBTSElGVCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICk7XG4gIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICBpZiAoIW5vZGUpIHtcbiAgICBuZXdDb3VudCsrO1xuICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgbmV3Q291bnQtLTtcbiAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld05vZGVzID0gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5IYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vdFNldFZhbHVlO1xufTtcblxuSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG5cbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG59O1xuXG52YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cnkgPSBlbnRyeTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gIGlmIChyZW1vdmVkKSB7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoa2V5TWF0Y2gpIHtcbiAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uKFxuICBmbixcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uKFxuICBmbixcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgcmV0dXJuIGZuKHRoaXMuZW50cnkpO1xufTtcblxudmFyIE1hcEl0ZXJhdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSXRlcmF0b3IkJDEpIHtcbiAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICB9XG5cbiAgaWYgKCBJdGVyYXRvciQkMSApIE1hcEl0ZXJhdG9yLl9fcHJvdG9fXyA9IEl0ZXJhdG9yJCQxO1xuICBNYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciQkMSAmJiBJdGVyYXRvciQkMS5wcm90b3R5cGUgKTtcbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwSXRlcmF0b3I7XG5cbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICB2YXIgaW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgdmFyIG1heEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xufShJdGVyYXRvcikpO1xuXG5mdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG59XG5cbmZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgaW5kZXg6IDAsXG4gICAgX19wcmV2OiBwcmV2LFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gkJDEpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX3Jvb3QgPSByb290O1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2gkJDE7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX01BUDtcbmZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICB2YXIgbmV3Um9vdDtcbiAgdmFyIG5ld1NpemU7XG4gIGlmICghbWFwLl9yb290KSB7XG4gICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIG5ld1NpemUgPSAxO1xuICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoKTtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUoXG4gICAgICBtYXAuX3Jvb3QsXG4gICAgICBtYXAuX19vd25lcklELFxuICAgICAgMCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGssXG4gICAgICB2LFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/ICh2ID09PSBOT1RfU0VUID8gLTEgOiAxKSA6IDApO1xuICB9XG4gIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gIG5vZGUsXG4gIG93bmVySUQsXG4gIHNoaWZ0LFxuICBrZXlIYXNoLFxuICBrZXksXG4gIHZhbHVlLFxuICBkaWRDaGFuZ2VTaXplLFxuICBkaWRBbHRlclxuKSB7XG4gIGlmICghbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUudXBkYXRlKFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApO1xufVxuXG5mdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gIH1cblxuICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICB2YXIgbmV3Tm9kZTtcbiAgdmFyIG5vZGVzID1cbiAgICBpZHgxID09PSBpZHgyXG4gICAgICA/IFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV1cbiAgICAgIDogKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkpLFxuICAgICAgICBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG5cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFvd25lcklEKSB7XG4gICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gIH1cbiAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpaV07XG4gICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gIHZhciBiaXRtYXAgPSAwO1xuICB2YXIgcGFja2VkSUkgPSAwO1xuICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICBmb3IgKHZhciBpaSA9IDAsIGJpdCA9IDEsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyssIGJpdCA8PD0gMSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgYml0bWFwIHw9IGJpdDtcbiAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICB9XG4gIGV4cGFuZGVkTm9kZXNbaW5jbHVkaW5nXSA9IG5vZGU7XG4gIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gIHggLT0gKHggPj4gMSkgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICB4ID0gKHggKyAoeCA+PiA0KSkgJiAweDBmMGYwZjBmO1xuICB4ICs9IHggPj4gODtcbiAgeCArPSB4ID4+IDE2O1xuICByZXR1cm4geCAmIDB4N2Y7XG59XG5cbmZ1bmN0aW9uIHNldEF0KGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICB2YXIgYWZ0ZXIgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgIGFmdGVyID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgIGFycmF5LnBvcCgpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgdmFyIGFmdGVyID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICBhZnRlciA9IDE7XG4gICAgfVxuICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxudmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xudmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG52YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxudmFyIElTX0xJU1RfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG5mdW5jdGlvbiBpc0xpc3QobWF5YmVMaXN0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TWU1CT0xdKTtcbn1cblxudmFyIExpc3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgdmFyIGVtcHR5ID0gZW1wdHlMaXN0KCk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbiQkMSh2YWx1ZSk7XG4gICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgbGlzdC5zZXRTaXplKHNpemUpO1xuICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBsaXN0LnNldChpLCB2KTsgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uJCQxICkgTGlzdC5fX3Byb3RvX18gPSBJbmRleGVkQ29sbGVjdGlvbiQkMTtcbiAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXN0O1xuXG4gIExpc3Qub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICBpbmRleCArPSB0aGlzLl9vcmlnaW47XG4gICAgICB2YXIgbm9kZSA9IGxpc3ROb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdXBkYXRlTGlzdCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuaGFzKGluZGV4KVxuICAgICAgPyB0aGlzXG4gICAgICA6IGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5zaGlmdCgpXG4gICAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgICAgICA/IHRoaXMucG9wKClcbiAgICAgICAgICA6IHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuX2xldmVsID0gU0hJRlQ7XG4gICAgICB0aGlzLl9yb290ID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIExpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHNlcXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICB2YXIgc2VxID0gSW5kZXhlZENvbGxlY3Rpb24kJDEoXG4gICAgICAgIHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycgJiYgaGFzSXRlcmF0b3IoYXJndW1lbnQpXG4gICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgIDogW2FyZ3VtZW50XVxuICAgICAgKTtcbiAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgc2Vxcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHNlcXNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkgeyByZXR1cm4gc2VxLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXN0LnB1c2godmFsdWUpOyB9KTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzJDEuc2l6ZTsgaSsrKSB7XG4gICAgICAgIGxpc3Quc2V0KGksIG1hcHBlci5jYWxsKGNvbnRleHQsIGxpc3QuZ2V0KGkpLCBpLCBsaXN0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICBMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcbiAgICAgIHRoaXMsXG4gICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG4gICAgKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FXG4gICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyAtLWluZGV4IDogaW5kZXgrKywgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gdGhpcy5zaXplIDogMDtcbiAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgdmFyIHZhbHVlO1xuICAgIHdoaWxlICgodmFsdWUgPSB2YWx1ZXMoKSkgIT09IERPTkUpIHtcbiAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChcbiAgICAgIHRoaXMuX29yaWdpbixcbiAgICAgIHRoaXMuX2NhcGFjaXR5LFxuICAgICAgdGhpcy5fbGV2ZWwsXG4gICAgICB0aGlzLl9yb290LFxuICAgICAgdGhpcy5fdGFpbCxcbiAgICAgIG93bmVySUQsXG4gICAgICB0aGlzLl9faGFzaFxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIExpc3Q7XG59KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cbkxpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG52YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuTGlzdFByb3RvdHlwZVtJU19MSVNUX1NZTUJPTF0gPSB0cnVlO1xuTGlzdFByb3RvdHlwZVtERUxFVEVdID0gTGlzdFByb3RvdHlwZS5yZW1vdmU7XG5MaXN0UHJvdG90eXBlLm1lcmdlID0gTGlzdFByb3RvdHlwZS5jb25jYXQ7XG5MaXN0UHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbkxpc3RQcm90b3R5cGUuZGVsZXRlSW4gPSBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5MaXN0UHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG5MaXN0UHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuTGlzdFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuTGlzdFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbkxpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG5MaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5MaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG5MaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5wdXNoKGFycik7XG59O1xuTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlKGFycmF5LCBvd25lcklEKSB7XG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbn07XG5cbi8vIFRPRE86IHNlZW1zIGxpa2UgdGhlc2UgbWV0aG9kcyBhcmUgdmVyeSBzaW1pbGFyXG5cblZOb2RlLnByb3RvdHlwZS5yZW1vdmVCZWZvcmUgPSBmdW5jdGlvbiByZW1vdmVCZWZvcmUgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICBpZiAob3JpZ2luSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKFtdLCBvd25lcklEKTtcbiAgfVxuICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICB2YXIgbmV3Q2hpbGQ7XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICBuZXdDaGlsZCA9XG4gICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBpZiAobmV3Q2hpbGQpIHtcbiAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcbiAgfVxuICByZXR1cm4gZWRpdGFibGU7XG59O1xuXG5WTm9kZS5wcm90b3R5cGUucmVtb3ZlQWZ0ZXIgPSBmdW5jdGlvbiByZW1vdmVBZnRlciAob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gKGxldmVsID8gMSA8PCBsZXZlbCA6IDApIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHNpemVJbmRleCA9ICgoaW5kZXggLSAxKSA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgaWYgKHNpemVJbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkO1xuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtzaXplSW5kZXhdO1xuICAgIG5ld0NoaWxkID1cbiAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUFmdGVyKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICBlZGl0YWJsZS5hcnJheS5zcGxpY2Uoc2l6ZUluZGV4ICsgMSk7XG4gIGlmIChuZXdDaGlsZCkge1xuICAgIGVkaXRhYmxlLmFycmF5W3NpemVJbmRleF0gPSBuZXdDaGlsZDtcbiAgfVxuICByZXR1cm4gZWRpdGFibGU7XG59O1xuXG52YXIgRE9ORSA9IHt9O1xuXG5mdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gIHZhciBsZWZ0ID0gbGlzdC5fb3JpZ2luO1xuICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgdmFyIHRhaWwgPSBsaXN0Ll90YWlsO1xuXG4gIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgIHJldHVybiBsZXZlbCA9PT0gMFxuICAgICAgPyBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpXG4gICAgICA6IGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiBsZWZ0IC0gb2Zmc2V0O1xuICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgIHRvID0gU0laRTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgdmFyIHZhbHVlcztcbiAgICB2YXIgYXJyYXkgPSBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcbiAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgIHRvID0gU0laRTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IERPTkUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgIHZhbHVlcyA9IGl0ZXJhdGVOb2RlT3JMZWFmKFxuICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sXG4gICAgICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgICAgICBvZmZzZXQgKyAoaWR4IDw8IGxldmVsKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUxpc3Qob3JpZ2luLCBjYXBhY2l0eSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIGxpc3QgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUpO1xuICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcbiAgbGlzdC5fb3JpZ2luID0gb3JpZ2luO1xuICBsaXN0Ll9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuICBsaXN0Ll9yb290ID0gcm9vdDtcbiAgbGlzdC5fdGFpbCA9IHRhaWw7XG4gIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcbiAgbGlzdC5fX2hhc2ggPSBoYXNoO1xuICBsaXN0Ll9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbGlzdDtcbn1cblxudmFyIEVNUFRZX0xJU1Q7XG5mdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG4gIHJldHVybiBFTVBUWV9MSVNUIHx8IChFTVBUWV9MSVNUID0gbWFrZUxpc3QoMCwgMCwgU0hJRlQpKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaW5kZXggPSB3cmFwSW5kZXgobGlzdCwgaW5kZXgpO1xuXG4gIGlmIChpbmRleCAhPT0gaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIGlmIChpbmRleCA+PSBsaXN0LnNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgaW5kZXggPCAwXG4gICAgICAgID8gc2V0TGlzdEJvdW5kcyhsaXN0LCBpbmRleCkuc2V0KDAsIHZhbHVlKVxuICAgICAgICA6IHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGluZGV4ICs9IGxpc3QuX29yaWdpbjtcblxuICB2YXIgbmV3VGFpbCA9IGxpc3QuX3RhaWw7XG4gIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICBpZiAoaW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICB9IGVsc2Uge1xuICAgIG5ld1Jvb3QgPSB1cGRhdGVWTm9kZShcbiAgICAgIG5ld1Jvb3QsXG4gICAgICBsaXN0Ll9fb3duZXJJRCxcbiAgICAgIGxpc3QuX2xldmVsLFxuICAgICAgaW5kZXgsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgfVxuXG4gIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVWTm9kZShub2RlLCBvd25lcklELCBsZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcikge1xuICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG4gIGlmICghbm9kZUhhcyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgbmV3Tm9kZTtcblxuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuICAgIHZhciBuZXdMb3dlck5vZGUgPSB1cGRhdGVWTm9kZShcbiAgICAgIGxvd2VyTm9kZSxcbiAgICAgIG93bmVySUQsXG4gICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgaW5kZXgsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAobmV3TG93ZXJOb2RlID09PSBsb3dlck5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSBuZXdMb3dlck5vZGU7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBpZiAobm9kZUhhcyAmJiBub2RlLmFycmF5W2lkeF0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBpZiAoZGlkQWx0ZXIpIHtcbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICB9XG5cbiAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gIGlmIChvd25lcklEICYmIG5vZGUgJiYgb3duZXJJRCA9PT0gbm9kZS5vd25lcklEKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBWTm9kZShub2RlID8gbm9kZS5hcnJheS5zbGljZSgpIDogW10sIG93bmVySUQpO1xufVxuXG5mdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuICBpZiAocmF3SW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgfVxuICBpZiAocmF3SW5kZXggPCAxIDw8IChsaXN0Ll9sZXZlbCArIFNISUZUKSkge1xuICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICB3aGlsZSAobm9kZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICBsZXZlbCAtPSBTSElGVDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGJlZ2luIHw9IDA7XG4gIH1cbiAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kIHw9IDA7XG4gIH1cbiAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcbiAgdmFyIG9sZENhcGFjaXR5ID0gbGlzdC5fY2FwYWNpdHk7XG4gIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgdmFyIG5ld0NhcGFjaXR5ID1cbiAgICBlbmQgPT09IHVuZGVmaW5lZFxuICAgICAgPyBvbGRDYXBhY2l0eVxuICAgICAgOiBlbmQgPCAwXG4gICAgICAgID8gb2xkQ2FwYWNpdHkgKyBlbmRcbiAgICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gIH1cblxuICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLFxuICAgICAgb3duZXJcbiAgICApO1xuICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gIH1cbiAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgfVxuXG4gIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sXG4gICAgICBvd25lclxuICAgICk7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gIH1cblxuICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3VGFpbCA9XG4gICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgID8gbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKVxuICAgICAgOiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldFxuICAgICAgICA/IG5ldyBWTm9kZShbXSwgb3duZXIpXG4gICAgICAgIDogb2xkVGFpbDtcblxuICAvLyBNZXJnZSBUYWlsIGludG8gdHJlZS5cbiAgaWYgKFxuICAgIG9sZFRhaWwgJiZcbiAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJlxuICAgIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmXG4gICAgb2xkVGFpbC5hcnJheS5sZW5ndGhcbiAgKSB7XG4gICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgIHZhciBub2RlID0gbmV3Um9vdDtcbiAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG4gICAgfVxuICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBzaXplIGhhcyBiZWVuIHJlZHVjZWQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHRhaWwgbmVlZHMgdG8gYmUgdHJpbW1lZC5cbiAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdDYXBhY2l0eSk7XG4gIH1cblxuICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcbiAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgIG5ld0xldmVsID0gU0hJRlQ7XG4gICAgbmV3Um9vdCA9IG51bGw7XG4gICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSByb290IGhhcyBiZWVuIHRyaW1tZWQsIGdhcmJhZ2UgY29sbGVjdC5cbiAgfSBlbHNlIGlmIChuZXdPcmlnaW4gPiBvbGRPcmlnaW4gfHwgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAvLyBJZGVudGlmeSB0aGUgbmV3IHRvcCByb290IG5vZGUgb2YgdGhlIHN1YnRyZWUgb2YgdGhlIG9sZCByb290LlxuICAgIHdoaWxlIChuZXdSb290KSB7XG4gICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICBpZiAoKGJlZ2luSW5kZXggIT09IG5ld1RhaWxPZmZzZXQgPj4+IG5ld0xldmVsKSAmIE1BU0spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYmVnaW5JbmRleCkge1xuICAgICAgICBvZmZzZXRTaGlmdCArPSAoMSA8PCBuZXdMZXZlbCkgKiBiZWdpbkluZGV4O1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgLT0gU0hJRlQ7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5hcnJheVtiZWdpbkluZGV4XTtcbiAgICB9XG5cbiAgICAvLyBUcmltIHRoZSBuZXcgc2lkZXMgb2YgdGhlIG5ldyByb290LlxuICAgIGlmIChuZXdSb290ICYmIG5ld09yaWdpbiA+IG9sZE9yaWdpbikge1xuICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgIH1cbiAgICBpZiAobmV3Um9vdCAmJiBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIoXG4gICAgICAgIG93bmVyLFxuICAgICAgICBuZXdMZXZlbCxcbiAgICAgICAgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcbiAgICAgIG5ld0NhcGFjaXR5IC09IG9mZnNldFNoaWZ0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgIGxpc3Quc2l6ZSA9IG5ld0NhcGFjaXR5IC0gbmV3T3JpZ2luO1xuICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICBsaXN0Ll9jYXBhY2l0eSA9IG5ld0NhcGFjaXR5O1xuICAgIGxpc3QuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG59XG5cbmZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKChzaXplIC0gMSkgPj4+IFNISUZUKSA8PCBTSElGVDtcbn1cblxudmFyIE9yZGVyZWRNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXAkJDEpIHtcbiAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5T3JkZXJlZE1hcCgpXG4gICAgICA6IGlzT3JkZXJlZE1hcCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIE1hcCQkMSApIE9yZGVyZWRNYXAuX19wcm90b19fID0gTWFwJCQxO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcCQkMSAmJiBNYXAkJDEucHJvdG90eXBlICk7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICByZXR1cm4gaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2xpc3QuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCkgfHwgdGhpcy5fbGlzdC53YXNBbHRlcmVkKCk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSk7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICByZXR1cm4gT3JkZXJlZE1hcDtcbn0oTWFwKSk7XG5cbk9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG5PcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcblxuZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgb21hcC5fbWFwID0gbWFwO1xuICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gIHJldHVybiBvbWFwO1xufVxuXG52YXIgRU1QVFlfT1JERVJFRF9NQVA7XG5mdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gIHJldHVybiAoXG4gICAgRU1QVFlfT1JERVJFRF9NQVAgfHxcbiAgICAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9yZGVyZWRNYXAob21hcCwgaywgdikge1xuICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gIHZhciBpID0gbWFwLmdldChrKTtcbiAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgdmFyIG5ld01hcDtcbiAgdmFyIG5ld0xpc3Q7XG4gIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgLy8gcmVtb3ZlZFxuICAgIGlmICghaGFzKSB7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZW50cnksIGlkeCkgeyByZXR1cm4gZW50cnkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBpZHg7IH0pO1xuICAgICAgbmV3TWFwID0gbmV3TGlzdFxuICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeVswXTsgfSlcbiAgICAgICAgLmZsaXAoKVxuICAgICAgICAudG9NYXAoKTtcbiAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhcykge1xuICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIG5ld01hcCA9IG1hcDtcbiAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgfVxuICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgb21hcC5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cbiAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG59XG5cbnZhciBJU19TVEFDS19TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TVEFDS19fQEAnO1xuXG5mdW5jdGlvbiBpc1N0YWNrKG1heWJlU3RhY2spIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NZTUJPTF0pO1xufVxuXG52YXIgU3RhY2sgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBTdGFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5U3RhY2soKVxuICAgICAgOiBpc1N0YWNrKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlTdGFjaygpLnB1c2hBbGwodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiQkMSApIFN0YWNrLl9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uJCQxO1xuICBTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhY2s7XG5cbiAgU3RhY2sub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIHBlZWsgKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IGFyZ3VtZW50cyQxW2lpXSxcbiAgICAgICAgbmV4dDogaGVhZCxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uIHB1c2hBbGwgKGl0ZXIpIHtcbiAgICBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24kJDEoaXRlcik7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgaXNTdGFjayhpdGVyKSkge1xuICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgbmV3U2l6ZSsrO1xuICAgICAgaGVhZCA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgfTtcbiAgICB9LCAvKiByZXZlcnNlICovIHRydWUpO1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB9XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIGssIHRoaXMkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChmbihub2RlLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YWNrO1xufShJbmRleGVkQ29sbGVjdGlvbikpO1xuXG5TdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxudmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU1lNQk9MXSA9IHRydWU7XG5TdGFja1Byb3RvdHlwZS5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnBvcDtcblN0YWNrUHJvdG90eXBlLnVuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wdXNoO1xuU3RhY2tQcm90b3R5cGUudW5zaGlmdEFsbCA9IFN0YWNrUHJvdG90eXBlLnB1c2hBbGw7XG5TdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcblN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuU3RhY2tQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICByZXR1cm4gcmVzdWx0LnVuc2hpZnQoYXJyKTtcbn07XG5TdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTdGFjayhzaXplLCBoZWFkLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX2hlYWQgPSBoZWFkO1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2g7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX1NUQUNLO1xuZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG59XG5cbnZhciBJU19TRVRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbmZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICByZXR1cm4gaXNTZXQobWF5YmVPcmRlcmVkU2V0KSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkU2V0KTtcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICAhaXNDb2xsZWN0aW9uKGIpIHx8XG4gICAgKGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplKSB8fFxuICAgIChhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBiLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhLl9faGFzaCAhPT0gYi5fX2hhc2gpIHx8XG4gICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuICAgIGlzSW5kZXhlZChhKSAhPT0gaXNJbmRleGVkKGIpIHx8XG4gICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG4gIGlmIChpc09yZGVyZWQoYSkpIHtcbiAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgIHJldHVybiAoXG4gICAgICBiLmV2ZXJ5KGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMV0sIHYpICYmIChub3RBc3NvY2lhdGl2ZSB8fCBpcyhlbnRyeVswXSwgaykpO1xuICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZVxuICAgICk7XG4gIH1cblxuICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuXG4gIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBhLmNhY2hlUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICB2YXIgXyA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSBfO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgaWYgKFxuICAgICAgbm90QXNzb2NpYXRpdmVcbiAgICAgICAgPyAhYS5oYXModilcbiAgICAgICAgOiBmbGlwcGVkXG4gICAgICAgICAgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpXG4gICAgICAgICAgOiAhaXMoYS5nZXQoaywgTk9UX1NFVCksIHYpXG4gICAgKSB7XG4gICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGFsbEVxdWFsICYmIGEuc2l6ZSA9PT0gYlNpemU7XG59XG5cbi8qKlxuICogQ29udHJpYnV0ZXMgYWRkaXRpb25hbCBtZXRob2RzIHRvIGEgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gIH07XG4gIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICByZXR1cm4gY3Rvcjtcbn1cblxuZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gU2VxKHZhbHVlKTtcbiAgfVxuICBpZiAoaXNLZXllZCh2YWx1ZSkpIHtcbiAgICB2YXIgcmVzdWx0JDEgPSB7fTtcbiAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJlc3VsdCQxW2tdID0gdG9KUyh2KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0JDE7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXN1bHQucHVzaCh0b0pTKHYpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5U2V0KClcbiAgICAgIDogaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uJCQxKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXRDb2xsZWN0aW9uJCQxICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb24kJDE7XG4gIFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRDb2xsZWN0aW9uJCQxICYmIFNldENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cbiAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICB9O1xuXG4gIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZW1vdmVzID0gW107XG4gICAgdmFyIGFkZHMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgbWFwcGVkID0gbWFwcGVyLmNhbGwoY29udGV4dCwgdmFsdWUsIHZhbHVlLCB0aGlzJDEpO1xuICAgICAgaWYgKG1hcHBlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmVtb3Zlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgYWRkcy5wdXNoKG1hcHBlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICByZW1vdmVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQucmVtb3ZlKHZhbHVlKTsgfSk7XG4gICAgICBhZGRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uICgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNpemUgIT09IDA7IH0pO1xuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIFNldENvbGxlY3Rpb24kJDEoaXRlcnNbaWldKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0ICgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gU2V0Q29sbGVjdGlvbiQkMShpdGVyKTsgfSk7XG4gICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QgKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uJCQxKGl0ZXIpOyB9KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoaXRlcnMuc29tZShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChjb21wYXJhdG9yKSB7XG4gICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihrLCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgfTtcblxuICByZXR1cm4gU2V0O1xufShTZXRDb2xsZWN0aW9uKSk7XG5cblNldC5pc1NldCA9IGlzU2V0O1xuXG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG5TZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG5TZXRQcm90b3R5cGUubWVyZ2UgPSBTZXRQcm90b3R5cGUuY29uY2F0ID0gU2V0UHJvdG90eXBlLnVuaW9uO1xuU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5hZGQoYXJyKTtcbn07XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG5TZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VTZXQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZVNldChzZXQsIG5ld01hcCkge1xuICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuICAgIHNldC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgc2V0Ll9tYXAgPSBuZXdNYXA7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuICByZXR1cm4gbmV3TWFwID09PSBzZXQuX21hcFxuICAgID8gc2V0XG4gICAgOiBuZXdNYXAuc2l6ZSA9PT0gMFxuICAgICAgPyBzZXQuX19lbXB0eSgpXG4gICAgICA6IHNldC5fX21ha2UobmV3TWFwKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNldChtYXAsIG93bmVySUQpIHtcbiAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoU2V0UHJvdG90eXBlKTtcbiAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gIHNldC5fbWFwID0gbWFwO1xuICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHNldDtcbn1cblxudmFyIEVNUFRZX1NFVDtcbmZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuICByZXR1cm4gRU1QVFlfU0VUIHx8IChFTVBUWV9TRVQgPSBtYWtlU2V0KGVtcHR5TWFwKCkpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGF6eSBzZXEgb2YgbnVtcyBmcm9tIHN0YXJ0IChpbmNsdXNpdmUpIHRvIGVuZFxuICogKGV4Y2x1c2l2ZSksIGJ5IHN0ZXAsIHdoZXJlIHN0YXJ0IGRlZmF1bHRzIHRvIDAsIHN0ZXAgdG8gMSwgYW5kIGVuZCB0b1xuICogaW5maW5pdHkuIFdoZW4gc3RhcnQgaXMgZXF1YWwgdG8gZW5kLCByZXR1cm5zIGVtcHR5IGxpc3QuXG4gKi9cbnZhciBSYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEkJDEpIHtcbiAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgfVxuICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5hYnMoc3RlcCk7XG4gICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gLXN0ZXA7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKEVNUFRZX1JBTkdFKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgIH1cbiAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEkJDEgKSBSYW5nZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxJCQxO1xuICBSYW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gIFJhbmdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmdlO1xuXG4gIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICdSYW5nZSBbICcgK1xuICAgICAgdGhpcy5fc3RhcnQgK1xuICAgICAgJy4uLicgK1xuICAgICAgdGhpcy5fZW5kICtcbiAgICAgICh0aGlzLl9zdGVwICE9PSAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAnIF0nXG4gICAgKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpXG4gICAgICA/IHRoaXMuX3N0YXJ0ICsgd3JhcEluZGV4KHRoaXMsIGluZGV4KSAqIHRoaXMuX3N0ZXBcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgIHJldHVybiAoXG4gICAgICBwb3NzaWJsZUluZGV4ID49IDAgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleClcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChlbmQgPD0gYmVnaW4pIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICB0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuX3N0ZXBcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IG9mZnNldFZhbHVlIC8gdGhpcy5fc3RlcDtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICBpZiAoZm4odmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB2KTtcbiAgICB9KTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlXG4gICAgICA/IHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgICB0aGlzLl9lbmQgPT09IG90aGVyLl9lbmQgJiZcbiAgICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcFxuICAgICAgOiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIHJldHVybiBSYW5nZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkFOR0U7XG5cbmZ1bmN0aW9uIGdldEluKGNvbGxlY3Rpb24sIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gIHZhciBrZXlQYXRoID0gY29lcmNlS2V5UGF0aChzZWFyY2hLZXlQYXRoKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICBjb2xsZWN0aW9uID0gZ2V0KGNvbGxlY3Rpb24sIGtleVBhdGhbaSsrXSwgTk9UX1NFVCk7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldEluJDEoc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGdldEluKHRoaXMsIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaGFzSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICByZXR1cm4gZ2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG59XG5cbmZ1bmN0aW9uIGhhc0luJDEoc2VhcmNoS2V5UGF0aCkge1xuICByZXR1cm4gaGFzSW4odGhpcywgc2VhcmNoS2V5UGF0aCk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICB2YXIgb2JqZWN0ID0ge307XG4gIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgb2JqZWN0W2tdID0gdjtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIE5vdGU6IGFsbCBvZiB0aGVzZSBtZXRob2RzIGFyZSBkZXByZWNhdGVkLlxuQ29sbGVjdGlvbi5pc0l0ZXJhYmxlID0gaXNDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5pc0tleWVkID0gaXNLZXllZDtcbkNvbGxlY3Rpb24uaXNJbmRleGVkID0gaXNJbmRleGVkO1xuQ29sbGVjdGlvbi5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbkNvbGxlY3Rpb24uaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG5Db2xsZWN0aW9uLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbm1peGluKENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICB2YXIgdXNlVHVwbGVzID0gaXNLZXllZCh0aGlzKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIC8vIEtleWVkIGNvbGxlY3Rpb25zIHByb2R1Y2UgYW4gYXJyYXkgb2YgdHVwbGVzLlxuICAgICAgYXJyYXlbaSsrXSA9IHVzZVR1cGxlcyA/IFtrLCB2XSA6IHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24gdG9JbmRleGVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9JbmRleGVkU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgdG9KUzogZnVuY3Rpb24gdG9KUyQxKCkge1xuICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICB9LFxuXG4gIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgdG9NYXA6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09iamVjdDogdG9PYmplY3QsXG5cbiAgdG9PcmRlcmVkTWFwOiBmdW5jdGlvbiB0b09yZGVyZWRNYXAoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uIHRvT3JkZXJlZFNldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvU2V0OiBmdW5jdGlvbiB0b1NldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9TZXRTZXE6IGZ1bmN0aW9uIHRvU2V0U2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICB0b1NlcTogZnVuY3Rpb24gdG9TZXEoKSB7XG4gICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKVxuICAgICAgPyB0aGlzLnRvSW5kZXhlZFNlcSgpXG4gICAgICA6IGlzS2V5ZWQodGhpcylcbiAgICAgICAgPyB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICA6IHRoaXMudG9TZXRTZXEoKTtcbiAgfSxcblxuICB0b1N0YWNrOiBmdW5jdGlvbiB0b1N0YWNrKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvTGlzdDogZnVuY3Rpb24gdG9MaXN0KCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbQ29sbGVjdGlvbl0nO1xuICB9LFxuXG4gIF9fdG9TdHJpbmc6IGZ1bmN0aW9uIF9fdG9TdHJpbmcoaGVhZCwgdGFpbCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIGhlYWQgK1xuICAgICAgJyAnICtcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcilcbiAgICAgICAgLmpvaW4oJywgJykgK1xuICAgICAgJyAnICtcbiAgICAgIHRhaWxcbiAgICApO1xuICB9LFxuXG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gIH0sXG5cbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICB9LFxuXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICB9LFxuXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gIH0sXG5cbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChzaWRlRWZmZWN0LCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUoY29udGV4dCA/IHNpZGVFZmZlY3QuYmluZChjb250ZXh0KSA6IHNpZGVFZmZlY3QpO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuICAgIHZhciBqb2luZWQgPSAnJztcbiAgICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlzRmlyc3QgPyAoaXNGaXJzdCA9IGZhbHNlKSA6IChqb2luZWQgKz0gc2VwYXJhdG9yKTtcbiAgICAgIGpvaW5lZCArPSB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBqb2luZWQ7XG4gIH0sXG5cbiAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UkMShyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlZHVjZShcbiAgICAgIHRoaXMsXG4gICAgICByZWR1Y2VyLFxuICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfSxcblxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgIHJldHVybiByZWR1Y2UoXG4gICAgICB0aGlzLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGluaXRpYWxSZWR1Y3Rpb24sXG4gICAgICBjb250ZXh0LFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG4gIH0sXG5cbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcbiAgfSxcblxuICBzb21lOiBmdW5jdGlvbiBzb21lKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgfSxcblxuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTKTtcbiAgfSxcblxuICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICBidXRMYXN0OiBmdW5jdGlvbiBidXRMYXN0KCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gIH0sXG5cbiAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgcHJlZGljYXRlID8gdGhpcy50b1NlcSgpLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIDogdGhpc1xuICAgICk7XG4gIH0sXG5cbiAgY291bnRCeTogZnVuY3Rpb24gY291bnRCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gIH0sXG5cbiAgZW50cnlTZXE6IGZ1bmN0aW9uIGVudHJ5U2VxKCkge1xuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICBpZiAoY29sbGVjdGlvbi5fY2FjaGUpIHtcbiAgICAgIC8vIFdlIGNhY2hlIGFzIGFuIGVudHJpZXMgYXJyYXksIHNvIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgY2FjaGUhXG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKGNvbGxlY3Rpb24uX2NhY2hlKTtcbiAgICB9XG4gICAgdmFyIGVudHJpZXNTZXF1ZW5jZSA9IGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGVudHJ5TWFwcGVyKVxuICAgICAgLnRvSW5kZXhlZFNlcSgpO1xuICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLnRvU2VxKCk7IH07XG4gICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgfSxcblxuICBmaWx0ZXJOb3Q6IGZ1bmN0aW9uIGZpbHRlck5vdChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpbmRFbnRyeTogZnVuY3Rpb24gZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIGZvdW5kID0gW2ssIHZdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9LFxuXG4gIGZpbmRLZXk6IGZ1bmN0aW9uIGZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gIH0sXG5cbiAgZmluZExhc3Q6IGZ1bmN0aW9uIGZpbmRMYXN0KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uIGZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmaW5kTGFzdEtleTogZnVuY3Rpb24gZmluZExhc3RLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQocmV0dXJuVHJ1ZSwgbnVsbCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXRNYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICB9LFxuXG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgfSxcblxuICBmcm9tRW50cnlTZXE6IGZ1bmN0aW9uIGZyb21FbnRyeVNlcSgpIHtcbiAgICByZXR1cm4gbmV3IEZyb21FbnRyaWVzU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpOyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBnZXRJbjogZ2V0SW4kMSxcblxuICBncm91cEJ5OiBmdW5jdGlvbiBncm91cEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoc2VhcmNoS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH0sXG5cbiAgaGFzSW46IGhhc0luJDEsXG5cbiAgaXNTdWJzZXQ6IGZ1bmN0aW9uIGlzU3Vic2V0KGl0ZXIpIHtcbiAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaW5jbHVkZXMgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpOyB9KTtcbiAgfSxcblxuICBpc1N1cGVyc2V0OiBmdW5jdGlvbiBpc1N1cGVyc2V0KGl0ZXIpIHtcbiAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaXNTdWJzZXQgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcbiAgfSxcblxuICBrZXlPZjogZnVuY3Rpb24ga2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gIH0sXG5cbiAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TZXEoKVxuICAgICAgLm1hcChrZXlNYXBwZXIpXG4gICAgICAudG9JbmRleGVkU2VxKCk7XG4gIH0sXG5cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maXJzdChub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgbGFzdEtleU9mOiBmdW5jdGlvbiBsYXN0S2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiBtYXgoY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICB9LFxuXG4gIG1heEJ5OiBmdW5jdGlvbiBtYXhCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24gbWluKGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgIHRoaXMsXG4gICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3JcbiAgICApO1xuICB9LFxuXG4gIG1pbkJ5OiBmdW5jdGlvbiBtaW5CeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgIHRoaXMsXG4gICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3IsXG4gICAgICBtYXBwZXJcbiAgICApO1xuICB9LFxuXG4gIHJlc3Q6IGZ1bmN0aW9uIHJlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gIH0sXG5cbiAgc2tpcDogZnVuY3Rpb24gc2tpcChhbW91bnQpIHtcbiAgICByZXR1cm4gYW1vdW50ID09PSAwID8gdGhpcyA6IHRoaXMuc2xpY2UoTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgc2tpcExhc3Q6IGZ1bmN0aW9uIHNraXBMYXN0KGFtb3VudCkge1xuICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZSgwLCAtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gIH0sXG5cbiAgc2tpcFVudGlsOiBmdW5jdGlvbiBza2lwVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICBzb3J0Qnk6IGZ1bmN0aW9uIHNvcnRCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gIH0sXG5cbiAgdGFrZTogZnVuY3Rpb24gdGFrZShhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICB0YWtlTGFzdDogZnVuY3Rpb24gdGFrZUxhc3QoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoLU1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHRha2VXaGlsZTogZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCB0YWtlV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCkpO1xuICB9LFxuXG4gIHRha2VVbnRpbDogZnVuY3Rpb24gdGFrZVVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRha2VXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICByZXR1cm4gZm4odGhpcyk7XG4gIH0sXG5cbiAgdmFsdWVTZXE6IGZ1bmN0aW9uIHZhbHVlU2VxKCkge1xuICAgIHJldHVybiB0aGlzLnRvSW5kZXhlZFNlcSgpO1xuICB9LFxuXG4gIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICBoYXNoQ29kZTogZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19oYXNoIHx8ICh0aGlzLl9faGFzaCA9IGhhc2hDb2xsZWN0aW9uKHRoaXMpKTtcbiAgfSxcblxuICAvLyAjIyMgSW50ZXJuYWxcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cbiAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxufSk7XG5cbnZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5Db2xsZWN0aW9uUHJvdG90eXBlW0lTX0NPTExFQ1RJT05fU1lNQk9MXSA9IHRydWU7XG5Db2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnZhbHVlcztcbkNvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gQ29sbGVjdGlvblByb3RvdHlwZS50b0FycmF5O1xuQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG5Db2xsZWN0aW9uUHJvdG90eXBlLmluc3BlY3QgPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuQ29sbGVjdGlvblByb3RvdHlwZS5jaGFpbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZmxhdE1hcDtcbkNvbGxlY3Rpb25Qcm90b3R5cGUuY29udGFpbnMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuXG5taXhpbihLZXllZENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgZmxpcDogZnVuY3Rpb24gZmxpcCgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICB9LFxuXG4gIG1hcEVudHJpZXM6IGZ1bmN0aW9uIG1hcEVudHJpZXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBbaywgdl0sIGl0ZXJhdGlvbnMrKywgdGhpcyQxKTsgfSlcbiAgICAgICAgLmZyb21FbnRyeVNlcSgpXG4gICAgKTtcbiAgfSxcblxuICBtYXBLZXlzOiBmdW5jdGlvbiBtYXBLZXlzKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAuZmxpcCgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMSk7IH0pXG4gICAgICAgIC5mbGlwKClcbiAgICApO1xuICB9LFxufSk7XG5cbnZhciBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUgPSBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlO1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0tFWUVEX1NZTUJPTF0gPSB0cnVlO1xuS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmVudHJpZXM7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gdG9PYmplY3Q7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBxdW90ZVN0cmluZyhrKSArICc6ICcgKyBxdW90ZVN0cmluZyh2KTsgfTtcblxubWl4aW4oSW5kZXhlZENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcbiAgfSxcblxuICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICB9LFxuXG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgfSxcblxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICB9LFxuXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBrZXkgPSB0aGlzLmxhc3RLZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gIH0sXG5cbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcbiAgfSxcblxuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgcmVtb3ZlTnVtIC8qLCAuLi52YWx1ZXMqLykge1xuICAgIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfHwgMCwgMCk7XG4gICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAgLy8gY29sbGVjdGlvbi4gSG93ZXZlciBzaXplIG1heSBiZSBleHBlbnNpdmUgdG8gY29tcHV0ZSBpZiBub3QgY2FjaGVkLCBzb1xuICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcbiAgICB2YXIgc3BsaWNlZCA9IHRoaXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIHJldHVybiByZWlmeShcbiAgICAgIHRoaXMsXG4gICAgICBudW1BcmdzID09PSAxXG4gICAgICAgID8gc3BsaWNlZFxuICAgICAgICA6IHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG4gICAgKTtcbiAgfSxcblxuICAvLyAjIyMgTW9yZSBjb2xsZWN0aW9uIG1ldGhvZHNcblxuICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KDAsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKGRlcHRoKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCBmYWxzZSkpO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPCAwIHx8XG4gICAgICAodGhpcy5zaXplID09PSBJbmZpbml0eSB8fCAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPiB0aGlzLnNpemUpKVxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4ga2V5ID09PSBpbmRleDsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaW5kZXgpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGluZGV4ID49IDAgJiZcbiAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemVcbiAgICAgICAgOiB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMSlcbiAgICApO1xuICB9LFxuXG4gIGludGVycG9zZTogZnVuY3Rpb24gaW50ZXJwb3NlKHNlcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICB9LFxuXG4gIGludGVybGVhdmU6IGZ1bmN0aW9uIGludGVybGVhdmUoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGNvbGxlY3Rpb25zKTtcbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSB6aXBwZWQuZmxhdHRlbih0cnVlKTtcbiAgICBpZiAoemlwcGVkLnNpemUpIHtcbiAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGNvbGxlY3Rpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcbiAgfSxcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gUmFuZ2UoMCwgdGhpcy5zaXplKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KC0xLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICB9LFxuXG4gIHppcDogZnVuY3Rpb24gemlwKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgfSxcblxuICB6aXBBbGw6IGZ1bmN0aW9uIHppcEFsbCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zLCB0cnVlKSk7XG4gIH0sXG5cbiAgemlwV2l0aDogZnVuY3Rpb24gemlwV2l0aCh6aXBwZXIgLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgIGNvbGxlY3Rpb25zWzBdID0gdGhpcztcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICB9LFxufSk7XG5cbnZhciBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbkluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0lOREVYRURfU1lNQk9MXSA9IHRydWU7XG5JbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG5taXhpbihTZXRDb2xsZWN0aW9uLCB7XG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBnZXQ6IGZ1bmN0aW9uIGdldCh2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfSxcblxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXModmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlU2VxKCk7XG4gIH0sXG59KTtcblxuU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaGFzID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblNldENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaW5jbHVkZXM7XG5cbi8vIE1peGluIHN1YmNsYXNzZXNcblxubWl4aW4oS2V5ZWRTZXEsIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xubWl4aW4oSW5kZXhlZFNlcSwgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlKTtcbm1peGluKFNldFNlcSwgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4vLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIHJlZHVjZXIsIHJlZHVjdGlvbiwgY29udGV4dCwgdXNlRmlyc3QsIHJldmVyc2UpIHtcbiAgYXNzZXJ0Tm90SW5maW5pdGUoY29sbGVjdGlvbi5zaXplKTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICByZWR1Y3Rpb24gPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICB9XG4gIH0sIHJldmVyc2UpO1xuICByZXR1cm4gcmVkdWN0aW9uO1xufVxuXG5mdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICByZXR1cm4gaztcbn1cblxuZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICByZXR1cm4gW2ssIHZdO1xufVxuXG5mdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBuZWcocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICByZXR1cm4gYXJyQ29weShhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gaGFzaENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbi5zaXplID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBvcmRlcmVkID0gaXNPcmRlcmVkKGNvbGxlY3Rpb24pO1xuICB2YXIga2V5ZWQgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgdmFyIHNpemUgPSBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICBrZXllZFxuICAgICAgPyBvcmRlcmVkXG4gICAgICAgID8gZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICA6IG9yZGVyZWRcbiAgICAgICAgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICApO1xuICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbn1cblxuZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gIGggPSBpbXVsKGgsIDB4Y2M5ZTJkNTEpO1xuICBoID0gaW11bCgoaCA8PCAxNSkgfCAoaCA+Pj4gLTE1KSwgMHgxYjg3MzU5Myk7XG4gIGggPSBpbXVsKChoIDw8IDEzKSB8IChoID4+PiAtMTMpLCA1KTtcbiAgaCA9ICgoaCArIDB4ZTY1NDZiNjQpIHwgMCkgXiBzaXplO1xuICBoID0gaW11bChoIF4gKGggPj4+IDE2KSwgMHg4NWViY2E2Yik7XG4gIGggPSBpbXVsKGggXiAoaCA+Pj4gMTMpLCAweGMyYjJhZTM1KTtcbiAgaCA9IHNtaShoIF4gKGggPj4+IDE2KSk7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICByZXR1cm4gKGEgXiAoYiArIDB4OWUzNzc5YjkgKyAoYSA8PCA2KSArIChhID4+IDIpKSkgfCAwOyAvLyBpbnRcbn1cblxudmFyIE9yZGVyZWRTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXQkJDEpIHtcbiAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGVtcHR5T3JkZXJlZFNldCgpXG4gICAgICA6IGlzT3JkZXJlZFNldCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXQkJDEgKSBPcmRlcmVkU2V0Ll9fcHJvdG9fXyA9IFNldCQkMTtcbiAgT3JkZXJlZFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXQkJDEgJiYgU2V0JCQxLnByb3RvdHlwZSApO1xuICBPcmRlcmVkU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yZGVyZWRTZXQ7XG5cbiAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgfTtcblxuICBPcmRlcmVkU2V0LmZyb21LZXlzID0gZnVuY3Rpb24gZnJvbUtleXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gIH07XG5cbiAgT3JkZXJlZFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZFNldCB7JywgJ30nKTtcbiAgfTtcblxuICByZXR1cm4gT3JkZXJlZFNldDtcbn0oU2V0KSk7XG5cbk9yZGVyZWRTZXQuaXNPcmRlcmVkU2V0ID0gaXNPcmRlcmVkU2V0O1xuXG52YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuT3JkZXJlZFNldFByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuT3JkZXJlZFNldFByb3RvdHlwZS56aXAgPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXA7XG5PcmRlcmVkU2V0UHJvdG90eXBlLnppcFdpdGggPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXBXaXRoO1xuXG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG5mdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcbiAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBzZXQuX21hcCA9IG1hcDtcbiAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbmZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgcmV0dXJuIChcbiAgICBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpXG4gICk7XG59XG5cbnZhciBSZWNvcmQgPSBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICB9XG4gICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgIHZhciBpbmRpY2VzID0gKFJlY29yZFR5cGVQcm90b3R5cGUuX2luZGljZXMgPSB7fSk7XG4gICAgICAvLyBEZXByZWNhdGVkOiBsZWZ0IHRvIGF0dGVtcHQgbm90IHRvIGJyZWFrIGFueSBleHRlcm5hbCBjb2RlIHdoaWNoXG4gICAgICAvLyByZWxpZXMgb24gYSAuX25hbWUgcHJvcGVydHkgZXhpc3Rpbmcgb24gcmVjb3JkIGluc3RhbmNlcy5cbiAgICAgIC8vIFVzZSBSZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKCkgaW5zdGVhZFxuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IGtleXNbaV07XG4gICAgICAgIGluZGljZXNbcHJvcE5hbWVdID0gaTtcbiAgICAgICAgaWYgKFJlY29yZFR5cGVQcm90b3R5cGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdDYW5ub3QgZGVmaW5lICcgK1xuICAgICAgICAgICAgICAgIHJlY29yZE5hbWUodGhpcykgK1xuICAgICAgICAgICAgICAgICcgd2l0aCBwcm9wZXJ0eSBcIicgK1xuICAgICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAnXCIgc2luY2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGlzIHBhcnQgb2YgdGhlIFJlY29yZCBBUEkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQcm9wKFJlY29yZFR5cGVQcm90b3R5cGUsIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fb3duZXJJRCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZXMgPSBMaXN0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobCkge1xuICAgICAgbC5zZXRTaXplKHRoaXMkMS5fa2V5cy5sZW5ndGgpO1xuICAgICAgS2V5ZWRDb2xsZWN0aW9uKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBsLnNldCh0aGlzJDEuX2luZGljZXNba10sIHYgPT09IHRoaXMkMS5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSAoUmVjb3JkVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFxuICAgIFJlY29yZFByb3RvdHlwZVxuICApKTtcbiAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBSZWNvcmRUeXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgfVxuXG4gIHJldHVybiBSZWNvcmRUeXBlO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIHN0ciA9IHJlY29yZE5hbWUodGhpcykgKyAnIHsgJztcbiAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICB2YXIgaztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgc3RyICs9IChpID8gJywgJyA6ICcnKSArIGsgKyAnOiAnICsgcXVvdGVTdHJpbmcodGhpcy5nZXQoaykpO1xuICB9XG4gIHJldHVybiBzdHIgKyAnIH0nO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAob3RoZXIgJiZcbiAgICAgIHRoaXMuX2tleXMgPT09IG90aGVyLl9rZXlzICYmXG4gICAgICByZWNvcmRTZXEodGhpcykuZXF1YWxzKHJlY29yZFNlcShvdGhlcikpKVxuICApO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5oYXNoQ29kZSgpO1xufTtcblxuLy8gQHByYWdtYSBBY2Nlc3NcblxuUmVjb3JkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGspIHtcbiAgcmV0dXJuIHRoaXMuX2luZGljZXMuaGFzT3duUHJvcGVydHkoayk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9pbmRpY2VzW2tdO1xuICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXMuZ2V0KGluZGV4KTtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdIDogdmFsdWU7XG59O1xuXG4vLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG5SZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICBpZiAodGhpcy5oYXMoaykpIHtcbiAgICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLnNldChcbiAgICAgIHRoaXMuX2luZGljZXNba10sXG4gICAgICB2ID09PSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdlxuICAgICk7XG4gICAgaWYgKG5ld1ZhbHVlcyAhPT0gdGhpcy5fdmFsdWVzICYmICF0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICByZXR1cm4gdGhpcy5zZXQoayk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLmNsZWFyKCkuc2V0U2l6ZSh0aGlzLl9rZXlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZhbHVlcy53YXNBbHRlcmVkKCk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24gdG9TZXEgKCkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24gdG9KUyQxICgpIHtcbiAgcmV0dXJuIHRvSlModGhpcyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gIGlmICghb3duZXJJRCkge1xuICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLl92YWx1ZXMgPSBuZXdWYWx1ZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzLCBvd25lcklEKTtcbn07XG5cblJlY29yZC5pc1JlY29yZCA9IGlzUmVjb3JkO1xuUmVjb3JkLmdldERlc2NyaXB0aXZlTmFtZSA9IHJlY29yZE5hbWU7XG52YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcblJlY29yZFByb3RvdHlwZVtJU19SRUNPUkRfU1lNQk9MXSA9IHRydWU7XG5SZWNvcmRQcm90b3R5cGVbREVMRVRFXSA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmU7XG5SZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcblJlY29yZFByb3RvdHlwZS5nZXRJbiA9IGdldEluJDE7XG5SZWNvcmRQcm90b3R5cGUuaGFzSW4gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmhhc0luO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gbWVyZ2U7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcblJlY29yZFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbiQxO1xuUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcblJlY29yZFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuUmVjb3JkUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBSZWNvcmRQcm90b3R5cGUuZW50cmllcztcblJlY29yZFByb3RvdHlwZS50b0pTT04gPSBSZWNvcmRQcm90b3R5cGUudG9PYmplY3QgPVxuICBDb2xsZWN0aW9uUHJvdG90eXBlLnRvT2JqZWN0O1xuUmVjb3JkUHJvdG90eXBlLmluc3BlY3QgPSBSZWNvcmRQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gIHJlY29yZC5fdmFsdWVzID0gdmFsdWVzO1xuICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHJlY29yZDtcbn1cblxuZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgcmV0dXJuIHJlY29yZC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbn1cblxuZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICByZXR1cm4ga2V5ZWRTZXFGcm9tVmFsdWUocmVjb3JkLl9rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gW2ssIHJlY29yZC5nZXQoayldOyB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuX19vd25lcklELCAnQ2Fubm90IHNldCBvbiBhbiBpbW11dGFibGUgcmVjb3JkLicpO1xuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBsYXp5IFNlcSBvZiBgdmFsdWVgIHJlcGVhdGVkIGB0aW1lc2AgdGltZXMuIFdoZW4gYHRpbWVzYCBpc1xuICogdW5kZWZpbmVkLCByZXR1cm5zIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGB2YWx1ZWAuXG4gKi9cbnZhciBSZXBlYXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxJCQxKSB7XG4gIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXBlYXQodmFsdWUsIHRpbWVzKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnNpemUgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBNYXRoLm1heCgwLCB0aW1lcyk7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICByZXR1cm4gRU1QVFlfUkVQRUFUO1xuICAgICAgfVxuICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEkJDEgKSBSZXBlYXQuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgUmVwZWF0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEkJDEgJiYgSW5kZXhlZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgUmVwZWF0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGVhdDtcblxuICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICB9XG4gICAgcmV0dXJuICdSZXBlYXQgWyAnICsgdGhpcy5fdmFsdWUgKyAnICcgKyB0aGlzLnNpemUgKyAnIHRpbWVzIF0nO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgcmV0dXJuIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSlcbiAgICAgID8gdGhpc1xuICAgICAgOiBuZXcgUmVwZWF0KFxuICAgICAgICAgIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgIHJlc29sdmVFbmQoZW5kLCBzaXplKSAtIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSlcbiAgICAgICAgKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihcbiAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGkgPT09IHNpemVcbiAgICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzJDEuX3ZhbHVlKTsgfVxuICAgICk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVwZWF0XG4gICAgICA/IGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpXG4gICAgICA6IGRlZXBFcXVhbChvdGhlcik7XG4gIH07XG5cbiAgcmV0dXJuIFJlcGVhdDtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkVQRUFUO1xuXG5mdW5jdGlvbiBmcm9tSlModmFsdWUsIGNvbnZlcnRlcikge1xuICByZXR1cm4gZnJvbUpTV2l0aChcbiAgICBbXSxcbiAgICBjb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcixcbiAgICB2YWx1ZSxcbiAgICAnJyxcbiAgICBjb252ZXJ0ZXIgJiYgY29udmVydGVyLmxlbmd0aCA+IDIgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICB7ICcnOiB2YWx1ZSB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdmFsdWUsIGtleSwga2V5UGF0aCwgcGFyZW50VmFsdWUpIHtcbiAgdmFyIHRvU2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICA/IEluZGV4ZWRTZXFcbiAgICA6IGlzUGxhaW5PYmoodmFsdWUpXG4gICAgICA/IEtleWVkU2VxXG4gICAgICA6IG51bGw7XG4gIGlmICh0b1NlcSkge1xuICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGNpcmN1bGFyIHN0cnVjdHVyZSB0byBJbW11dGFibGUnKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAga2V5UGF0aCAmJiBrZXkgIT09ICcnICYmIGtleVBhdGgucHVzaChrZXkpO1xuICAgIHZhciBjb252ZXJ0ZWQgPSBjb252ZXJ0ZXIuY2FsbChcbiAgICAgIHBhcmVudFZhbHVlLFxuICAgICAga2V5LFxuICAgICAgdG9TZXEodmFsdWUpLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2LCBrLCBrZXlQYXRoLCB2YWx1ZSk7IH1cbiAgICAgICksXG4gICAgICBrZXlQYXRoICYmIGtleVBhdGguc2xpY2UoKVxuICAgICk7XG4gICAgc3RhY2sucG9wKCk7XG4gICAga2V5UGF0aCAmJiBrZXlQYXRoLnBvcCgpO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKGssIHYpIHtcbiAgcmV0dXJuIGlzS2V5ZWQodikgPyB2LnRvTWFwKCkgOiB2LnRvTGlzdCgpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNC4wLjAtcmMuMTFcIjtcblxudmFyIEltbXV0YWJsZSA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbixcblxuICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gIEl0ZXJhYmxlOiBDb2xsZWN0aW9uLFxuXG4gIFNlcTogU2VxLFxuICBNYXA6IE1hcCxcbiAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgTGlzdDogTGlzdCxcbiAgU3RhY2s6IFN0YWNrLFxuICBTZXQ6IFNldCxcbiAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcblxuICBSZWNvcmQ6IFJlY29yZCxcbiAgUmFuZ2U6IFJhbmdlLFxuICBSZXBlYXQ6IFJlcGVhdCxcblxuICBpczogaXMsXG4gIGZyb21KUzogZnJvbUpTLFxuICBoYXNoOiBoYXNoLFxuXG4gIGlzSW1tdXRhYmxlOiBpc0ltbXV0YWJsZSxcbiAgaXNDb2xsZWN0aW9uOiBpc0NvbGxlY3Rpb24sXG4gIGlzS2V5ZWQ6IGlzS2V5ZWQsXG4gIGlzSW5kZXhlZDogaXNJbmRleGVkLFxuICBpc0Fzc29jaWF0aXZlOiBpc0Fzc29jaWF0aXZlLFxuICBpc09yZGVyZWQ6IGlzT3JkZXJlZCxcbiAgaXNWYWx1ZU9iamVjdDogaXNWYWx1ZU9iamVjdCxcbiAgaXNTZXE6IGlzU2VxLFxuICBpc0xpc3Q6IGlzTGlzdCxcbiAgaXNNYXA6IGlzTWFwLFxuICBpc09yZGVyZWRNYXA6IGlzT3JkZXJlZE1hcCxcbiAgaXNTdGFjazogaXNTdGFjayxcbiAgaXNTZXQ6IGlzU2V0LFxuICBpc09yZGVyZWRTZXQ6IGlzT3JkZXJlZFNldCxcbiAgaXNSZWNvcmQ6IGlzUmVjb3JkLFxuXG4gIGdldDogZ2V0LFxuICBnZXRJbjogZ2V0SW4sXG4gIGhhczogaGFzLFxuICBoYXNJbjogaGFzSW4sXG4gIG1lcmdlOiBtZXJnZSQxLFxuICBtZXJnZURlZXA6IG1lcmdlRGVlcCxcbiAgbWVyZ2VXaXRoOiBtZXJnZVdpdGgkMSxcbiAgbWVyZ2VEZWVwV2l0aDogbWVyZ2VEZWVwV2l0aCxcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIHJlbW92ZUluOiByZW1vdmVJbixcbiAgc2V0OiBzZXQsXG4gIHNldEluOiBzZXRJbixcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIHVwZGF0ZUluOiB1cGRhdGVJbixcbn07XG5cbi8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbnZhciBJdGVyYWJsZSA9IENvbGxlY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IEltbXV0YWJsZTtcbmV4cG9ydCB7IHZlcnNpb24sIENvbGxlY3Rpb24sIEl0ZXJhYmxlLCBTZXEsIE1hcCwgT3JkZXJlZE1hcCwgTGlzdCwgU3RhY2ssIFNldCwgT3JkZXJlZFNldCwgUmVjb3JkLCBSYW5nZSwgUmVwZWF0LCBpcywgZnJvbUpTLCBoYXNoLCBpc0ltbXV0YWJsZSwgaXNDb2xsZWN0aW9uLCBpc0tleWVkLCBpc0luZGV4ZWQsIGlzQXNzb2NpYXRpdmUsIGlzT3JkZXJlZCwgaXNWYWx1ZU9iamVjdCwgZ2V0LCBnZXRJbiwgaGFzLCBoYXNJbiwgbWVyZ2UkMSBhcyBtZXJnZSwgbWVyZ2VEZWVwLCBtZXJnZVdpdGgkMSBhcyBtZXJnZVdpdGgsIG1lcmdlRGVlcFdpdGgsIHJlbW92ZSwgcmVtb3ZlSW4sIHNldCwgc2V0SW4sIHVwZGF0ZSwgdXBkYXRlSW4gfTtcbiIsImltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbmltcG9ydCB7XG4gIGdldFVuZXhwZWN0ZWRJbnZvY2F0aW9uUGFyYW1ldGVyTWVzc2FnZSxcbiAgdmFsaWRhdGVOZXh0U3RhdGVcbn0gZnJvbSAnLi91dGlsaXRpZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAocmVkdWNlcnM6IE9iamVjdCwgZ2V0RGVmYXVsdFN0YXRlOiA/RnVuY3Rpb24gPSBJbW11dGFibGUuTWFwKTogRnVuY3Rpb24gPT4ge1xuICBjb25zdCByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3BhY2UtaW5maXgtb3BzXG4gIHJldHVybiAoaW5wdXRTdGF0ZTogP0Z1bmN0aW9uID0gZ2V0RGVmYXVsdFN0YXRlKCksIGFjdGlvbjogT2JqZWN0KTogSW1tdXRhYmxlLk1hcCA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZEludm9jYXRpb25QYXJhbWV0ZXJNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24pO1xuXG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0U3RhdGVcbiAgICAgIC53aXRoTXV0YXRpb25zKCh0ZW1wb3JhcnlTdGF0ZSkgPT4ge1xuICAgICAgICByZWR1Y2VyS2V5cy5mb3JFYWNoKChyZWR1Y2VyTmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XG4gICAgICAgICAgY29uc3QgY3VycmVudERvbWFpblN0YXRlID0gdGVtcG9yYXJ5U3RhdGUuZ2V0KHJlZHVjZXJOYW1lKTtcbiAgICAgICAgICBjb25zdCBuZXh0RG9tYWluU3RhdGUgPSByZWR1Y2VyKGN1cnJlbnREb21haW5TdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHZhbGlkYXRlTmV4dFN0YXRlKG5leHREb21haW5TdGF0ZSwgcmVkdWNlck5hbWUsIGFjdGlvbik7XG5cbiAgICAgICAgICB0ZW1wb3JhcnlTdGF0ZS5zZXQocmVkdWNlck5hbWUsIG5leHREb21haW5TdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH07XG59O1xuIiwiZXhwb3J0IGNvbWJpbmVSZWR1Y2VycyBmcm9tICcuL2NvbWJpbmVSZWR1Y2Vycyc7XG4iLCJleHBvcnQgZGVmYXVsdCAoYWN0aW9uOiBPYmplY3QpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSAnQEByZWR1eC9JTklUJyA/ICdpbml0aWFsU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG59O1xuIiwiaW1wb3J0IEltbXV0YWJsZSBmcm9tICdpbW11dGFibGUnO1xuaW1wb3J0IGdldFN0YXRlTmFtZSBmcm9tICcuL2dldFN0YXRlTmFtZSc7XG5cbmV4cG9ydCBkZWZhdWx0IChzdGF0ZTogT2JqZWN0LCByZWR1Y2VyczogT2JqZWN0LCBhY3Rpb246IE9iamVjdCkgPT4ge1xuICBjb25zdCByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG5cbiAgaWYgKCFyZWR1Y2VyTmFtZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBjb25zdCBzdGF0ZU5hbWUgPSBnZXRTdGF0ZU5hbWUoYWN0aW9uKTtcblxuICBpZiAoSW1tdXRhYmxlLmlzSW1tdXRhYmxlID8gIUltbXV0YWJsZS5pc0ltbXV0YWJsZShzdGF0ZSkgOiAhSW1tdXRhYmxlLkl0ZXJhYmxlLmlzSXRlcmFibGUoc3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIHN0YXRlTmFtZSArICcgaXMgb2YgdW5leHBlY3RlZCB0eXBlLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBpbnN0YW5jZSBvZiBJbW11dGFibGUuQ29sbGVjdGlvbiBvciBJbW11dGFibGUuUmVjb3JkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBcIicgKyByZWR1Y2VyTmFtZXMuam9pbignXCIsIFwiJykgKyAnXCIuJztcbiAgfVxuXG4gIGNvbnN0IHVuZXhwZWN0ZWRTdGF0ZVByb3BlcnR5TmFtZXMgPSBzdGF0ZS50b1NlcSgpLmtleVNlcSgpLnRvQXJyYXkoKS5maWx0ZXIoKG5hbWUpID0+IHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZFN0YXRlUHJvcGVydHlOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZFN0YXRlUHJvcGVydHlOYW1lcy5sZW5ndGggPT09IDEgPyAncHJvcGVydHknIDogJ3Byb3BlcnRpZXMnKSArICcgXCInICsgdW5leHBlY3RlZFN0YXRlUHJvcGVydHlOYW1lcy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgc3RhdGVOYW1lICsgJy4gRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIgcHJvcGVydHkgbmFtZXMgaW5zdGVhZDogXCInICsgcmVkdWNlck5hbWVzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIHByb3BlcnRpZXMgd2lsbCBiZSBpZ25vcmVkLic7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG4iLCJleHBvcnQgZ2V0U3RhdGVOYW1lIGZyb20gJy4vZ2V0U3RhdGVOYW1lJztcbmV4cG9ydCBnZXRVbmV4cGVjdGVkSW52b2NhdGlvblBhcmFtZXRlck1lc3NhZ2UgZnJvbSAnLi9nZXRVbmV4cGVjdGVkSW52b2NhdGlvblBhcmFtZXRlck1lc3NhZ2UnO1xuZXhwb3J0IHZhbGlkYXRlTmV4dFN0YXRlIGZyb20gJy4vdmFsaWRhdGVOZXh0U3RhdGUnO1xuIiwiZXhwb3J0IGRlZmF1bHQgKG5leHRTdGF0ZSwgcmVkdWNlck5hbWU6IHN0cmluZywgYWN0aW9uOiBPYmplY3QpOiB2b2lkID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobmV4dFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsgcmVkdWNlck5hbWUgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gaGFuZGxpbmcgXCInICsgYWN0aW9uLnR5cGUgKyAnXCIgYWN0aW9uLiBUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJyk7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9